var O="intear://";function W(e){let t=atob(e.replace(/-/g,"+").replace(/_/g,"/"));return Uint8Array.from(t,n=>n.charCodeAt(0))}function E(e){let t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",n;e instanceof Uint8Array?n=e:n=Uint8Array.from(e);let o=0;for(;o<n.length&&n[o]===0;)o++;let s=[];for(let a=o;a<n.length;a++){let i=n[a];for(let l=0;l<s.length;l++)i+=s[l]<<8,s[l]=i%58,i=i/58|0;for(;i>0;)s.push(i%58),i=i/58|0}let r="";for(let a=0;a<o;a++)r+=t[0];for(let a=s.length-1;a>=0;a--)r+=t[s[a]];return r}async function q(e){let t=window.selector.open(`${e.walletUrl}/${e.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes");if((await t.id()===null||t.closed)&&(await window.selector.ui.whenApprove({title:`App asks you to ${e.description}`,button:e.button}),t=window.selector.open(`${e.walletUrl}/${e.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes"),await t.id()===null||t.closed))throw new Error("Popup blocked");return new Promise((n,o)=>{let s=!1,r=()=>{window.removeEventListener("message",a),i&&clearInterval(i)},a=async l=>{try{let c=l.data;if(c.type==="ready")t.postMessage({type:e.sendMessageType,data:e.sendData},e.walletUrl);else if(c.type===e.successMessageType&&!s){s=!0,r(),t.close();try{n(await e.onSuccess(c))}catch(p){o(p)}}else c.type==="error"&&!s&&(s=!0,r(),t.close(),e.isUserRejection?.(c.message)?n(null):o(new Error(c.message||"Operation failed")))}catch{}};window.addEventListener("message",a);let i=setInterval(()=>{t.closed&&!s&&(r(),s||n(null))},100)})}async function Q(e){let n=`${e.logoutBridgeUrl}/api/session/create`;return new Promise((o,s)=>{let r=!1,a=null,i=()=>{a&&(a.close(),a=null)};try{a=new WebSocket(n)}catch(l){s(new Error(`Failed to connect to logout bridge: ${l}`));return}a.onmessage=async l=>{try{let c=JSON.parse(l.data);if(c.session_id&&!r){let p=c.session_id;a.send(JSON.stringify({type:e.sendMessageType,data:e.sendData}));let U=`${O}${e.method}?session_id=${encodeURIComponent(p)}`;await window.selector.ui.whenApprove({title:`App asks you to ${e.description}`,button:e.button});let f=await window.selector.openNativeApp(U)}else if(c.type===e.successMessageType&&!r){r=!0,i();try{o(await e.onSuccess(c))}catch(p){s(p)}}else c.type==="error"&&!r&&(r=!0,i(),e.isUserRejection?.(c.message)?o(null):s(new Error(c.message||"Operation failed")))}catch{}},a.onerror=l=>{r||(i(),s(new Error("WebSocket connection error to logout bridge")))},a.onclose=()=>{r||o(null)}})}async function _(e){return e.walletUrl===O?Q(e):q(e)}var M=class{accountId;disconnected;#e;constructor(t,n){this.accountId=t,this.#e=n,this.disconnected=!1}disconnect(){this.#e.disconnect()}async signMessage(t){if(this.disconnected)throw new Error("Account is disconnected");if(t.nonce.length!==32)throw new Error("Nonce must be 32 bytes");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let n=await this.#e.storage.get(T);if(!n)throw new Error("Private key not found in storage");let o=await crypto.subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),s=W(n.x),a=`ed25519:${E(s)}`,i=JSON.stringify({message:t.message,nonce:Array.from(t.nonce),recipient:t.recipient,callback_url:t.callbackUrl??null,state:t.state??null}),l=Date.now(),c=`${l}|${i}`,p=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(c)),U=await crypto.subtle.sign({name:"Ed25519"},o,p),f=new Uint8Array(U),A=`ed25519:${E(f)}`,k={message:i,accountId:this.accountId,publicKey:a,nonce:l,signature:A},K=this.#e.walletUrl,v=this.#e.logoutBridgeUrl;return _({method:"sign-message",walletUrl:K,logoutBridgeUrl:v,sendMessageType:"signMessage",sendData:k,successMessageType:"signed",onSuccess:async y=>({accountId:y.signature.accountId,publicKey:y.signature.publicKey,signature:y.signature.signature,state:y.signature.state}),isUserRejection:y=>y==="User rejected the signature",description:"sign a message",button:"Open Wallet"})}async sendTransactions(t,n=!1){if(this.disconnected)throw new Error("Account is disconnected");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let o=await this.#e.storage.get(T);if(!o)throw new Error("Private key not found in storage");let s=await crypto.subtle.importKey("jwk",o,{name:"Ed25519"},!0,["sign"]),r=W(o.x),i=`ed25519:${E(r)}`,l=t.map(h=>({signerId:h.signerId,receiverId:h.receiverId,actions:h.actions})),c=JSON.stringify(l),p=Date.now(),U=`${p}|${c}`,f=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(U)),I=await crypto.subtle.sign({name:"Ed25519"},s,f),A=new Uint8Array(I),K=`ed25519:${E(A)}`,v={accountId:this.accountId,publicKey:i,nonce:p,signature:K,transactions:c,mode:n?"SignDelegateActions":"Send"},y=this.#e.walletUrl,N=this.#e.logoutBridgeUrl;return _({method:"send-transactions",walletUrl:y,logoutBridgeUrl:N,sendMessageType:"signAndSendTransactions",sendData:v,successMessageType:"sent",onSuccess:async h=>{if(h.outcomes)return{outcomes:h.outcomes};if(h.signedDelegateActions)return{signedDelegateActions:h.signedDelegateActions};throw new Error("No outcomes or signedDelegateActions returned from wallet, this should never happen, a bug on wallet side")},isUserRejection:h=>h==="User rejected the transactions",description:"send a transaction",button:"Open Wallet"})}},S="accountId",T="appPrivateKey",D="walletUrl",P="logoutBridgeUrl",$=class e{#e;walletUrl;logoutBridgeUrl;storage;static async loadFrom(t){if(!t)throw new Error("loadFrom: Invalid arguments");let n=await t.get(S),o=await t.get(D),s=await t.get(P),r=new e(t,null,o,s),a=n?new M(n,r):null;return r.#e=a,r}constructor(t,n,o,s){this.storage=t,this.#e=n,this.walletUrl=o,this.logoutBridgeUrl=s}get connectedAccount(){return this.#e}async requestConnection(t={}){if(this.#e!==null)throw new Error("Already connected");let{networkId:n="mainnet",walletUrl:o="iframe:https://wallet.intear.tech",logoutBridgeUrl:s="wss://logout-bridge-service.intear.tech",messageToSign:r,relayerId:a=null}=t;if(r&&r.nonce.length!==32)throw new Error("Nonce must be 32 bytes");let i=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign"]),l=await crypto.subtle.exportKey("raw",i.publicKey),c=new Uint8Array(l),U=`ed25519:${E(c)}`,f;r?f={messageToSign:JSON.stringify({message:r.message,nonce:Array.from(r.nonce),recipient:r.recipient,callback_url:r.callbackUrl??null,state:r.state??null})}:f={};let I=JSON.stringify(f),A=Date.now(),k=`${A}|${I}`,K=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(k)),v=await crypto.subtle.sign({name:"Ed25519"},i.privateKey,K),y=new Uint8Array(v),h=`ed25519:${E(y)}`;if(o.startsWith("iframe:")){let g=new Promise(m=>{let b=null,w=setInterval(()=>{b&&(clearInterval(w),m(b))},100),B=u=>{u.data.origin&&(b=u.data.origin,window.removeEventListener("message",B))};window.addEventListener("message",B)}),x=o.substring(7),d=document.createElement("iframe");return d.src=`${x}/hot-wallet-connector-iframe.html`,d.style.position="fixed",d.style.inset="0",d.style.width="100vw",d.style.height="100vh",d.style.border="none",d.style.zIndex="100000",d.onload=()=>{window.selector.ui.showIframe(),g.then(m=>{d.contentWindow?.postMessage({type:"hotConnectorData",origin:m,location:window.selector.location},"*")})},document.body.appendChild(d),new Promise((m,b)=>{let w={},B=async u=>{if(u.data.status){d.contentWindow?.postMessage(u.data,"*");return}switch(u.data.type){case"ready":let G={publicKey:U,networkId:n,nonce:A,message:I,signature:h,version:"V3",relayerId:a};d.contentWindow?.postMessage({type:"signIn",data:G},"*");break;case"connected":let V=u.data.accountId,J=o===u.data.useBridge?O:u.data.walletUrl;this.walletUrl=J,this.logoutBridgeUrl=s,w={privateKeyJwk:await crypto.subtle.exportKey("jwk",i.privateKey),walletUrl:J,logoutBridgeUrl:s,accountId:V,signedMessage:u.data.signedMessage},d.contentWindow?.postMessage({type:"close"},"*");break;case"error":d.contentWindow?.postMessage({type:"close",message:u.data.message},"*");break;case"close":if(console.log("Closing with",w),d.remove(),window.removeEventListener("message",B),u.data.message)u.data.message=="User closed the modal"||u.data.message=="User rejected the connection"?m(null):b(new Error(u.data.message));else{this.#e=new M(w.accountId,this),await this.storage.set(T,w.privateKeyJwk),await this.storage.set(D,w.walletUrl),await this.storage.set(P,w.logoutBridgeUrl),await this.storage.set(S,w.accountId);let L={account:this.#e};if(r){if(!u.data.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");L.signedMessage={accountId:w.signedMessage.accountId,publicKey:w.signedMessage.publicKey,signature:w.signedMessage.signature,state:w.signedMessage.state}}m(L)}break}};window.addEventListener("message",B)})}else return _({method:"connect",walletUrl:o,logoutBridgeUrl:s,sendMessageType:"signIn",sendData:signInData,successMessageType:"connected",onSuccess:async g=>{let x=g.accountId;this.#e=new M(x,this);let d=o===g.useBridge?O:g.walletUrl;this.walletUrl=d,this.logoutBridgeUrl=s;let m=await crypto.subtle.exportKey("jwk",i.privateKey);await this.storage.set(T,m),await this.storage.set(D,d),await this.storage.set(P,s),await this.storage.set(S,x);let b={account:this.#e};if(r){if(!g.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");b.signedMessage={accountId:g.signedMessage.accountId,publicKey:g.signedMessage.publicKey,signature:g.signedMessage.signature,state:g.signedMessage.state}}return b},isUserRejection:g=>g==="User rejected the connection",description:"sign in with Intear Wallet",button:"Open Wallet"})}async disconnect(){if(this.#e!==null)this.#e.disconnected=!0,this.#e=null,this.walletUrl=void 0,this.logoutBridgeUrl=void 0,await this.storage.remove(S),await this.storage.remove(T),await this.storage.remove(D),await this.storage.remove(P);else throw new Error("Account is not connected")}};var j=$;var C={get:async e=>JSON.parse(await window.selector.storage.get(e))??null,set:async(e,t)=>{let n=await C.get(e);return await window.selector.storage.set(e,JSON.stringify(t)),n},remove:async e=>{let t=await C.get(e);return await window.selector.storage.remove(e),t}},R=class{constructor(t){this.near=t}async signIn({network:t,contractId:n,methodNames:o}){this.near.connectedAccount&&await this.signOut({network:t}),(n||o)&&console.warn("[Intear Adapter] Contract ID and method names are not supported in near selector afaik. If you believe this is a mistake, or it's already supported, please write to intear wallet support or in telegram and it will be fixed asap.");let s=await this.near.requestConnection({networkId:t}).catch(r=>(console.error("Error in signIn",r),null));return s===null?[]:[{accountId:s.account.accountId}]}async signOut({network:t}){this.near.disconnect()}async getAccounts({network:t}){return this.near.connectedAccount?[{accountId:this.near.connectedAccount.accountId}]:[]}async signMessage({network:t,message:n,nonce:o,recipient:s}){if(!this.near.connectedAccount)throw new Error("Account is not connected");let r=await this.near.connectedAccount.signMessage({message:n,nonce:o,recipient:s});if(r!==null)return r;throw new Error("User rejected the message")}async signAndSendTransaction({network:t,signerId:n,receiverId:o,actions:s}){if(!this.near.connectedAccount)throw new Error("Account is not connected");n=n??this.near.connectedAccount.accountId,s.forEach(H);let r=await this.near.connectedAccount.sendTransactions([{signerId:n,receiverId:o,actions:s}]);if(r!==null)return r.outcomes[0];throw new Error("User rejected the transaction")}async signAndSendTransactions({network:t,transactions:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");n=n.map(s=>(s.actions.forEach(H),{signerId:s.signerId??this.near.connectedAccount.accountId,receiverId:s.receiverId,actions:s.actions}));let o=await this.near.connectedAccount.sendTransactions(n);if(o!==null)return o.outcomes;throw new Error("User rejected the transactions")}};async function X(){return new R(await j.loadFrom(C))}function H(e){e.params?.code instanceof Uint8Array&&(e.params.code=Array.from(e.params.code)),e.deployContract?.code instanceof Uint8Array&&(e.deployContract.code=Array.from(e.deployContract.code)),e.deployGlobalContract?.code instanceof Uint8Array&&(e.deployGlobalContract.code=Array.from(e.deployGlobalContract.code))}X().then(e=>{window.selector.ready(e)});
