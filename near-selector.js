var _="intear://";function L(e){let t=atob(e.replace(/-/g,"+").replace(/_/g,"/"));return Uint8Array.from(t,s=>s.charCodeAt(0))}function A(e){let t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",s;e instanceof Uint8Array?s=e:s=Uint8Array.from(e);let o=0;for(;o<s.length&&s[o]===0;)o++;let n=[];for(let a=o;a<s.length;a++){let i=s[a];for(let l=0;l<n.length;l++)i+=n[l]<<8,n[l]=i%58,i=i/58|0;for(;i>0;)n.push(i%58),i=i/58|0}let r="";for(let a=0;a<o;a++)r+=t[0];for(let a=n.length-1;a>=0;a--)r+=t[n[a]];return r}async function q(e){let t=window.selector.open(`${e.walletUrl}/${e.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes");if((await t.id()===null||t.closed)&&(await window.selector.ui.whenApprove({title:`App asks you to ${e.description}`,button:e.button}),t=window.selector.open(`${e.walletUrl}/${e.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes"),await t.id()===null||t.closed))throw new Error("Popup blocked");return new Promise((s,o)=>{let n=!1,r=()=>{window.removeEventListener("message",a),i&&clearInterval(i)},a=async l=>{try{let c=l.data;if(c.type==="ready")t.postMessage({type:e.sendMessageType,data:e.sendData},e.walletUrl);else if(c.type===e.successMessageType&&!n){n=!0,r(),t.close();try{s(await e.onSuccess(c))}catch(h){o(h)}}else c.type==="error"&&!n&&(n=!0,r(),t.close(),e.isUserRejection?.(c.message)?s(null):o(new Error(c.message||"Operation failed")))}catch{}};window.addEventListener("message",a);let i=setInterval(()=>{t.closed&&!n&&(r(),n||s(null))},100)})}async function Q(e){let s=`${e.logoutBridgeUrl}/api/session/create`;return new Promise((o,n)=>{let r=!1,a=null,i=()=>{a&&(a.close(),a=null)};try{a=new WebSocket(s)}catch(l){n(new Error(`Failed to connect to logout bridge: ${l}`));return}a.onmessage=async l=>{try{let c=JSON.parse(l.data);if(c.session_id&&!r){let h=c.session_id;a.send(JSON.stringify({type:e.sendMessageType,data:e.sendData}));let U=`${_}${e.method}?session_id=${encodeURIComponent(h)}`;await window.selector.ui.whenApprove({title:`App asks you to ${e.description}`,button:e.button});let y=await window.selector.openNativeApp(U)}else if(c.type===e.successMessageType&&!r){r=!0,i();try{o(await e.onSuccess(c))}catch(h){n(h)}}else c.type==="error"&&!r&&(r=!0,i(),e.isUserRejection?.(c.message)?o(null):n(new Error(c.message||"Operation failed")))}catch{}},a.onerror=l=>{r||(i(),n(new Error("WebSocket connection error to logout bridge")))},a.onclose=()=>{r||o(null)}})}async function $(e){return e.walletUrl===_?Q(e):q(e)}var T=class{accountId;disconnected;#e;constructor(t,s){this.accountId=t,this.#e=s,this.disconnected=!1}disconnect(){this.#e.disconnect()}async signMessage(t){if(this.disconnected)throw new Error("Account is disconnected");if(t.nonce.length!==32)throw new Error("Nonce must be 32 bytes");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let s=await this.#e.storage.get(k);if(!s)throw new Error("Private key not found in storage");let o=await crypto.subtle.importKey("jwk",s,{name:"Ed25519"},!0,["sign"]),n=L(s.x),a=`ed25519:${A(n)}`,i=JSON.stringify({message:t.message,nonce:Array.from(t.nonce),recipient:t.recipient,callback_url:t.callbackUrl??null,state:t.state??null}),l=Date.now(),c=`${l}|${i}`,h=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(c)),U=await crypto.subtle.sign({name:"Ed25519"},o,h),y=new Uint8Array(U),I=`ed25519:${A(y)}`,K={message:i,accountId:this.accountId,publicKey:a,nonce:l,signature:I},v=this.#e.walletUrl,B=this.#e.logoutBridgeUrl;return $({method:"sign-message",walletUrl:v,logoutBridgeUrl:B,sendMessageType:"signMessage",sendData:K,successMessageType:"signed",onSuccess:p=>({accountId:p.signature.accountId,publicKey:p.signature.publicKey,signature:p.signature.signature,state:p.signature.state}),isUserRejection:p=>p==="User rejected the signature",description:"sign a message",button:"Open Wallet"})}async sendTransactions(t){if(this.disconnected)throw new Error("Account is disconnected");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let s=await this.#e.storage.get(k);if(!s)throw new Error("Private key not found in storage");let o=await crypto.subtle.importKey("jwk",s,{name:"Ed25519"},!0,["sign"]),n=L(s.x),a=`ed25519:${A(n)}`,i=t.map(f=>({signerId:f.signerId,receiverId:f.receiverId,actions:f.actions})),l=JSON.stringify(i),c=Date.now(),h=`${c}|${l}`,U=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(h)),y=await crypto.subtle.sign({name:"Ed25519"},o,U),E=new Uint8Array(y),K=`ed25519:${A(E)}`,v={accountId:this.accountId,publicKey:a,nonce:c,signature:K,transactions:l},B=this.#e.walletUrl,p=this.#e.logoutBridgeUrl;return $({method:"send-transactions",walletUrl:B,logoutBridgeUrl:p,sendMessageType:"signAndSendTransactions",sendData:v,successMessageType:"sent",onSuccess:f=>({outcomes:f.outcomes}),isUserRejection:f=>f==="User rejected the transactions",description:"send a transaction",button:"Open Wallet"})}},S="accountId",k="appPrivateKey",P="walletUrl",O="logoutBridgeUrl",C=class e{#e;walletUrl;logoutBridgeUrl;storage;static async loadFrom(t){if(!t)throw new Error("loadFrom: Invalid arguments");let s=await t.get(S),o=await t.get(P),n=await t.get(O),r=new e(t,null,o,n),a=s?new T(s,r):null;return r.#e=a,r}constructor(t,s,o,n){this.storage=t,this.#e=s,this.walletUrl=o,this.logoutBridgeUrl=n}get connectedAccount(){return this.#e}async requestConnection(t={}){if(this.#e!==null)throw new Error("Already connected");let{networkId:s="mainnet",walletUrl:o="iframe:https://wallet.intear.tech",logoutBridgeUrl:n="wss://logout-bridge-service.intear.tech",messageToSign:r,relayerId:a=null}=t;if(r&&r.nonce.length!==32)throw new Error("Nonce must be 32 bytes");let i=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign"]),l=await crypto.subtle.exportKey("raw",i.publicKey),c=new Uint8Array(l),U=`ed25519:${A(c)}`,y;r?y={messageToSign:JSON.stringify({message:r.message,nonce:Array.from(r.nonce),recipient:r.recipient,callback_url:r.callbackUrl??null,state:r.state??null})}:y={};let E=JSON.stringify(y),I=Date.now(),K=`${I}|${E}`,v=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(K)),B=await crypto.subtle.sign({name:"Ed25519"},i.privateKey,v),p=new Uint8Array(B),H=`ed25519:${A(p)}`;if(o.startsWith("iframe:")){let g=new Promise(m=>{let b=null,w=setInterval(()=>{b&&(clearInterval(w),m(b))},100),M=u=>{u.data.origin&&(b=u.data.origin,window.removeEventListener("message",M))};window.addEventListener("message",M)}),x=o.substring(7),d=document.createElement("iframe");return d.src=`${x}/hot-wallet-connector-iframe.html`,d.style.position="fixed",d.style.inset="0",d.style.width="100vw",d.style.height="100vh",d.style.border="none",d.style.zIndex="100000",d.onload=()=>{window.selector.ui.showIframe(),g.then(m=>{d.contentWindow?.postMessage({type:"hotConnectorData",origin:m,location:window.selector.location},"*")})},document.body.appendChild(d),new Promise((m,b)=>{let w={},M=async u=>{if(u.data.status){d.contentWindow?.postMessage(u.data,"*");return}switch(u.data.type){case"ready":let G={publicKey:U,networkId:s,nonce:I,message:E,signature:H,version:"V3",relayerId:a};d.contentWindow?.postMessage({type:"signIn",data:G},"*");break;case"connected":let V=u.data.accountId,N=o===u.data.useBridge?_:u.data.walletUrl;this.walletUrl=N,this.logoutBridgeUrl=n,w={privateKeyJwk:await crypto.subtle.exportKey("jwk",i.privateKey),walletUrl:N,logoutBridgeUrl:n,accountId:V,signedMessage:u.data.signedMessage},d.contentWindow?.postMessage({type:"close"},"*");break;case"error":d.contentWindow?.postMessage({type:"close",message:u.data.message},"*");break;case"close":if(console.log("Closing with",w),d.remove(),window.removeEventListener("message",M),u.data.message)u.data.message=="User closed the modal"||u.data.message=="User rejected the connection"?m(null):b(new Error(u.data.message));else{this.#e=new T(w.accountId,this),await this.storage.set(k,w.privateKeyJwk),await this.storage.set(P,w.walletUrl),await this.storage.set(O,w.logoutBridgeUrl),await this.storage.set(S,w.accountId);let J={account:this.#e};if(r){if(!u.data.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");J.signedMessage={accountId:w.signedMessage.accountId,publicKey:w.signedMessage.publicKey,signature:w.signedMessage.signature,state:w.signedMessage.state}}m(J)}break}};window.addEventListener("message",M)})}else return $({method:"connect",walletUrl:o,logoutBridgeUrl:n,sendMessageType:"signIn",sendData:signInData,successMessageType:"connected",onSuccess:async g=>{let x=g.accountId;this.#e=new T(x,this);let d=o===g.useBridge?_:g.walletUrl;this.walletUrl=d,this.logoutBridgeUrl=n;let m=await crypto.subtle.exportKey("jwk",i.privateKey);await this.storage.set(k,m),await this.storage.set(P,d),await this.storage.set(O,n),await this.storage.set(S,x);let b={account:this.#e};if(r){if(!g.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");b.signedMessage={accountId:g.signedMessage.accountId,publicKey:g.signedMessage.publicKey,signature:g.signedMessage.signature,state:g.signedMessage.state}}return b},isUserRejection:g=>g==="User rejected the connection",description:"sign in with Intear Wallet",button:"Open Wallet"})}async disconnect(){if(this.#e!==null)this.#e.disconnected=!0,this.#e=null,this.walletUrl=void 0,this.logoutBridgeUrl=void 0,await this.storage.remove(S),await this.storage.remove(k),await this.storage.remove(P),await this.storage.remove(O);else throw new Error("Account is not connected")}};var W=C;var R={get:async e=>JSON.parse(await window.selector.storage.get(e))??null,set:async(e,t)=>{let s=await R.get(e);return await window.selector.storage.set(e,JSON.stringify(t)),s},remove:async e=>{let t=await R.get(e);return await window.selector.storage.remove(e),t}},D=class{constructor(t){this.near=t}async signIn({network:t,contractId:s,methodNames:o}){this.near.connectedAccount&&await this.signOut({network:t}),(s||o)&&console.warn("[Intear Adapter] Contract ID and method names are not supported in near selector afaik. If you believe this is a mistake, or it's already supported, please write to intear wallet support or in telegram and it will be fixed asap.");let n=await this.near.requestConnection({networkId:t}).catch(r=>(console.error("Error in signIn",r),null));return n===null?[]:[{accountId:n.account.accountId}]}async signOut({network:t}){this.near.disconnect()}async getAccounts({network:t}){return this.near.connectedAccount?[{accountId:this.near.connectedAccount.accountId}]:[]}async signMessage({network:t,message:s,nonce:o,recipient:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");let r=await this.near.connectedAccount.signMessage({message:s,nonce:o,recipient:n});if(r!==null)return r;throw new Error("User rejected the message")}async signAndSendTransaction({network:t,signerId:s,receiverId:o,actions:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");s=s??this.near.connectedAccount.accountId,n.forEach(j);let r=await this.near.connectedAccount.sendTransactions([{signerId:s,receiverId:o,actions:n}]);if(r!==null)return r.outcomes[0];throw new Error("User rejected the transaction")}async signAndSendTransactions({network:t,transactions:s}){if(!this.near.connectedAccount)throw new Error("Account is not connected");s=s.map(n=>(n.actions.forEach(j),{signerId:n.signerId??this.near.connectedAccount.accountId,receiverId:n.receiverId,actions:n.actions}));let o=await this.near.connectedAccount.sendTransactions(s);if(o!==null)return o.outcomes;throw new Error("User rejected the transactions")}};async function X(){return new D(await W.loadFrom(R))}function j(e){e.params?.code instanceof Uint8Array&&(e.params.code=Array.from(e.params.code)),e.deployContract?.code instanceof Uint8Array&&(e.deployContract.code=Array.from(e.deployContract.code)),e.deployGlobalContract?.code instanceof Uint8Array&&(e.deployGlobalContract.code=Array.from(e.deployGlobalContract.code))}X().then(e=>{window.selector.ready(e)});
