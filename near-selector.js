var O="intear://";function H(t){let s=atob(t.replace(/-/g,"+").replace(/_/g,"/"));return Uint8Array.from(s,a=>a.charCodeAt(0))}function E(t){let s="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",a;t instanceof Uint8Array?a=t:a=Uint8Array.from(t);let o=0;for(;o<a.length&&a[o]===0;)o++;let n=[];for(let e=o;e<a.length;e++){let i=a[e];for(let l=0;l<n.length;l++)i+=n[l]<<8,n[l]=i%58,i=i/58|0;for(;i>0;)n.push(i%58),i=i/58|0}let r="";for(let e=0;e<o;e++)r+=s[0];for(let e=n.length-1;e>=0;e--)r+=s[n[e]];return r}function M(t){let s="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",a={};for(let e=0;e<s.length;e++)a[s[e]]=e;let o=0;for(;o<t.length&&t[o]===s[0];)o++;let n=[];for(let e=o;e<t.length;e++){let i=t[e];if(!(i in a))throw new Error(`Invalid base58 character: ${i}`);let l=a[i];for(let c=0;c<n.length;c++)l+=n[c]*58,n[c]=l&255,l>>=8;for(;l>0;)n.push(l&255),l>>=8}let r=new Uint8Array(o+n.length);for(let e=0;e<o;e++)r[e]=0;for(let e=0;e<n.length;e++)r[o+n.length-1-e]=n[e];return r}async function Q(t){let s=window.selector.open(`${t.walletUrl}/${t.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes");if((await s.id()===null||s.closed)&&(await window.selector.ui.whenApprove({title:`App asks you to ${t.description}`,button:t.button}),s=window.selector.open(`${t.walletUrl}/${t.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes"),await s.id()===null||s.closed))throw new Error("Popup blocked");return new Promise((a,o)=>{let n=!1,r=()=>{window.removeEventListener("message",e),i&&clearInterval(i)},e=async l=>{try{let c=l.data;if(c.type==="ready")s.postMessage({type:t.sendMessageType,data:t.sendData},t.walletUrl);else if(c.type===t.successMessageType&&!n){n=!0,r(),s.close();try{a(await t.onSuccess(c))}catch(h){o(h)}}else c.type==="error"&&!n&&(n=!0,r(),s.close(),t.isUserRejection?.(c.message)?a(null):o(new Error(c.message||"Operation failed")))}catch{}};window.addEventListener("message",e);let i=setInterval(()=>{s.closed&&!n&&(r(),n||a(null))},100)})}async function X(t){let a=`${t.logoutBridgeUrl}/api/session/create`;return new Promise((o,n)=>{let r=!1,e=null,i=()=>{e&&(e.close(),e=null)};try{e=new WebSocket(a)}catch(l){n(new Error(`Failed to connect to logout bridge: ${l}`));return}e.onmessage=async l=>{try{let c=JSON.parse(l.data);if(c.session_id&&!r){let h=c.session_id;e.send(JSON.stringify({type:t.sendMessageType,data:t.sendData}));let A=`${O}${t.method}?session_id=${encodeURIComponent(h)}`;await window.selector.ui.whenApprove({title:`App asks you to ${t.description}`,button:t.button});let f=await window.selector.openNativeApp(A)}else if(c.type===t.successMessageType&&!r){r=!0,i();try{o(await t.onSuccess(c))}catch(h){n(h)}}else c.type==="error"&&!r&&(r=!0,i(),t.isUserRejection?.(c.message)?o(null):n(new Error(c.message||"Operation failed")))}catch{}},e.onerror=l=>{r||(i(),n(new Error("WebSocket connection error to logout bridge")))},e.onclose=()=>{r||o(null)}})}async function $(t){return t.walletUrl===O?X(t):Q(t)}var B=class{accountId;disconnected;#e;constructor(s,a){this.accountId=s,this.#e=a,this.disconnected=!1}disconnect(){this.#e.disconnect()}async signMessage(s){if(this.disconnected)throw new Error("Account is disconnected");if(s.nonce.length!==32)throw new Error("Nonce must be 32 bytes");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let a=await this.#e.storage.get(_);if(!a)throw new Error("Private key not found in storage");let o=await crypto.subtle.importKey("jwk",a,{name:"Ed25519"},!0,["sign"]),n=H(a.x),e=`ed25519:${E(n)}`,i=JSON.stringify({message:s.message,nonce:Array.from(s.nonce),recipient:s.recipient,callback_url:s.callbackUrl??null,state:s.state??null}),l=Date.now(),c=`${l}|${i}`,h=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(c)),A=await crypto.subtle.sign({name:"Ed25519"},o,h),f=new Uint8Array(A),U=`ed25519:${E(f)}`,T={message:i,accountId:this.accountId,publicKey:e,nonce:l,signature:U},K=this.#e.walletUrl,v=this.#e.logoutBridgeUrl;return $({method:"sign-message",walletUrl:K,logoutBridgeUrl:v,sendMessageType:"signMessage",sendData:T,successMessageType:"signed",onSuccess:async y=>({accountId:y.signature.accountId,publicKey:y.signature.publicKey,signature:y.signature.signature,state:y.signature.state}),isUserRejection:y=>y==="User rejected the signature",description:"sign a message",button:"Open Wallet"})}async sendTransactions(s,a=!1){if(this.disconnected)throw new Error("Account is disconnected");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let o=await this.#e.storage.get(_);if(!o)throw new Error("Private key not found in storage");let n=await crypto.subtle.importKey("jwk",o,{name:"Ed25519"},!0,["sign"]),r=H(o.x),i=`ed25519:${E(r)}`,l=s.map(p=>({signerId:p.signerId,receiverId:p.receiverId,actions:p.actions})),c=JSON.stringify(l),h=Date.now(),A=`${h}|${c}`,f=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(A)),I=await crypto.subtle.sign({name:"Ed25519"},n,f),U=new Uint8Array(I),K=`ed25519:${E(U)}`,v={accountId:this.accountId,publicKey:i,nonce:h,signature:K,transactions:c,mode:a?"SignDelegateActions":"Send"},y=this.#e.walletUrl,L=this.#e.logoutBridgeUrl;return $({method:"send-transactions",walletUrl:y,logoutBridgeUrl:L,sendMessageType:"signAndSendTransactions",sendData:v,successMessageType:"sent",onSuccess:async p=>{if(p.outcomes)return{outcomes:p.outcomes};if(p.signedDelegateActions)return{signedDelegateActions:p.signedDelegateActions};throw new Error("No outcomes or signedDelegateActions returned from wallet, this should never happen, a bug on wallet side")},isUserRejection:p=>p==="User rejected the transactions",description:"send a transaction",button:"Open Wallet"})}},x="accountId",_="appPrivateKey",D="walletUrl",P="logoutBridgeUrl",C=class t{#e;walletUrl;logoutBridgeUrl;storage;static async loadFrom(s){if(!s)throw new Error("loadFrom: Invalid arguments");let a=await s.get(x),o=await s.get(D),n=await s.get(P),r=new t(s,null,o,n),e=a?new B(a,r):null;return r.#e=e,r}constructor(s,a,o,n){this.storage=s,this.#e=a,this.walletUrl=o,this.logoutBridgeUrl=n}get connectedAccount(){return this.#e}async requestConnection(s={}){if(this.#e!==null)throw new Error("Already connected");let{networkId:a="mainnet",walletUrl:o="iframe:https://wallet.intear.tech",logoutBridgeUrl:n="wss://logout-bridge-service.intear.tech",messageToSign:r,relayerId:e=null}=s;if(r&&r.nonce.length!==32)throw new Error("Nonce must be 32 bytes");let i=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign"]),l=await crypto.subtle.exportKey("raw",i.publicKey),c=new Uint8Array(l),A=`ed25519:${E(c)}`,f;r?f={messageToSign:JSON.stringify({message:r.message,nonce:Array.from(r.nonce),recipient:r.recipient,callback_url:r.callbackUrl??null,state:r.state??null})}:f={};let I=JSON.stringify(f),U=Date.now(),T=`${U}|${I}`,K=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(T)),v=await crypto.subtle.sign({name:"Ed25519"},i.privateKey,K),y=new Uint8Array(v),p=`ed25519:${E(y)}`;if(o.startsWith("iframe:")){let g=new Promise(m=>{let b=null,w=setInterval(()=>{b&&(clearInterval(w),m(b))},100),k=u=>{u.data.origin&&(b=u.data.origin,window.removeEventListener("message",k))};window.addEventListener("message",k)}),S=o.substring(7),d=document.createElement("iframe");return d.src=`${S}/hot-wallet-connector-iframe.html`,d.style.position="fixed",d.style.inset="0",d.style.width="100vw",d.style.height="100vh",d.style.border="none",d.style.zIndex="100000",d.onload=()=>{window.selector.ui.showIframe(),g.then(m=>{d.contentWindow?.postMessage({type:"hotConnectorData",origin:m,location:window.selector.location},"*")})},document.body.appendChild(d),new Promise((m,b)=>{let w={},k=async u=>{if(u.data.status){d.contentWindow?.postMessage(u.data,"*");return}switch(u.data.type){case"ready":let V={publicKey:A,networkId:a,nonce:U,message:I,signature:p,version:"V3",relayerId:e};d.contentWindow?.postMessage({type:"signIn",data:V},"*");break;case"connected":let z=u.data.accountId,W=o===u.data.useBridge?O:u.data.walletUrl;this.walletUrl=W,this.logoutBridgeUrl=n,w={privateKeyJwk:await crypto.subtle.exportKey("jwk",i.privateKey),walletUrl:W,logoutBridgeUrl:n,accountId:z,signedMessage:u.data.signedMessage},d.contentWindow?.postMessage({type:"close"},"*");break;case"error":d.contentWindow?.postMessage({type:"close",message:u.data.message},"*");break;case"close":if(console.log("Closing with",w),d.remove(),window.removeEventListener("message",k),u.data.message)u.data.message=="User closed the modal"||u.data.message=="User rejected the connection"?m(null):b(new Error(u.data.message));else{this.#e=new B(w.accountId,this),await this.storage.set(_,w.privateKeyJwk),await this.storage.set(D,w.walletUrl),await this.storage.set(P,w.logoutBridgeUrl),await this.storage.set(x,w.accountId);let j={account:this.#e};if(r){if(!u.data.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");j.signedMessage={accountId:w.signedMessage.accountId,publicKey:w.signedMessage.publicKey,signature:w.signedMessage.signature,state:w.signedMessage.state}}m(j)}break}};window.addEventListener("message",k)})}else return $({method:"connect",walletUrl:o,logoutBridgeUrl:n,sendMessageType:"signIn",sendData:signInData,successMessageType:"connected",onSuccess:async g=>{let S=g.accountId;this.#e=new B(S,this);let d=o===g.useBridge?O:g.walletUrl;this.walletUrl=d,this.logoutBridgeUrl=n;let m=await crypto.subtle.exportKey("jwk",i.privateKey);await this.storage.set(_,m),await this.storage.set(D,d),await this.storage.set(P,n),await this.storage.set(x,S);let b={account:this.#e};if(r){if(!g.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");b.signedMessage={accountId:g.signedMessage.accountId,publicKey:g.signedMessage.publicKey,signature:g.signedMessage.signature,state:g.signedMessage.state}}return b},isUserRejection:g=>g==="User rejected the connection",description:"sign in with Intear Wallet",button:"Open Wallet"})}async disconnect(){if(this.#e!==null)this.#e.disconnected=!0,this.#e=null,this.walletUrl=void 0,this.logoutBridgeUrl=void 0,await this.storage.remove(x),await this.storage.remove(_),await this.storage.remove(D),await this.storage.remove(P);else throw new Error("Account is not connected")}};var G=C;var N={get:async t=>JSON.parse(await window.selector.storage.get(t))??null,set:async(t,s)=>{let a=await N.get(t);return await window.selector.storage.set(t,JSON.stringify(s)),a},remove:async t=>{let s=await N.get(t);return await window.selector.storage.remove(t),s}},J=class{constructor(s){this.near=s}async signIn({network:s,contractId:a,methodNames:o}){this.near.connectedAccount&&await this.signOut({network:s}),(a||o)&&console.warn("[Intear Adapter] Contract ID and method names are not supported in near selector afaik. If you believe this is a mistake, or it's already supported, please write to intear wallet support or in telegram and it will be fixed asap.");let n=await this.near.requestConnection({networkId:s}).catch(r=>(console.error("Error in signIn",r),null));return n===null?[]:[{accountId:n.account.accountId}]}async signOut({network:s}){this.near.disconnect()}async getAccounts({network:s}){return this.near.connectedAccount?[{accountId:this.near.connectedAccount.accountId}]:[]}async signMessage({network:s,message:a,nonce:o,recipient:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");let r=await this.near.connectedAccount.signMessage({message:a,nonce:o,recipient:n});if(r!==null)return r;throw new Error("User rejected the message")}async signAndSendTransaction({network:s,signerId:a,receiverId:o,actions:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");a=a??this.near.connectedAccount.accountId,n.forEach(R);let r=await this.near.connectedAccount.sendTransactions([{signerId:a,receiverId:o,actions:n}]);if(r!==null)return r.outcomes[0];throw new Error("User rejected the transaction")}async signAndSendTransactions({network:s,transactions:a}){if(!this.near.connectedAccount)throw new Error("Account is not connected");a=a.map(n=>(n.actions.forEach(R),{signerId:n.signerId??this.near.connectedAccount.accountId,receiverId:n.receiverId,actions:n.actions}));let o=await this.near.connectedAccount.sendTransactions(a);if(o!==null)return o.outcomes;throw new Error("User rejected the transactions")}async signDelegateActions({network:s,signerId:a,delegateActions:o}){if(!this.near.connectedAccount)throw new Error("Account is not connected");o=o.map(r=>(r.actions.forEach(R),{signerId:a??this.near.connectedAccount.accountId,receiverId:r.receiverId,actions:r.actions}));let n=await this.near.connectedAccount.sendTransactions(transactions);if(n!==null)return{signedDelegateActions:n.signedDelegateActions.map(e=>({delegateHash:null,signedDelegate:{delegateAction:{senderId:e.delegate_action.sender_id,receiverId:e.delegate_action.receiver_id,actions:e.delegate_action.actions,nonce:BigInt(e.delegate_action.nonce),maxBlockHeight:BigInt(e.delegate_action.max_block_height),publicKey:{enum:e.delegate_action.public_key.split(":")[0]=="ed25519"?"ed25519Key":"secp256k1Key",ed25519Key:e.delegate_action.public_key.split(":")[0]=="ed25519"?{keyType:0,data:M(e.delegate_action.public_key.split(":")[1])}:void 0,secp256k1Key:e.delegate_action.public_key.split(":")[0]=="secp256k1"?{keyType:1,data:M(e.delegate_action.public_key.split(":")[1])}:void 0},signature:{enum:e.signature.split(":")[0]=="ed25519"?"ed25519Signature":"secp256k1Signature",ed25519Signature:e.signature.split(":")[0]=="ed25519"?{keyType:0,data:M(e.signature.split(":")[1])}:void 0,secp256k1Signature:e.signature.split(":")[0]=="secp256k1"?{keyType:1,data:M(e.signature.split(":")[1])}:void 0}}}}))};throw new Error("User rejected signing the delegate actions")}};async function Z(){return new J(await G.loadFrom(N))}function R(t){t.params?.code instanceof Uint8Array&&(t.params.code=Array.from(t.params.code)),t.deployContract?.code instanceof Uint8Array&&(t.deployContract.code=Array.from(t.deployContract.code)),t.deployGlobalContract?.code instanceof Uint8Array&&(t.deployGlobalContract.code=Array.from(t.deployGlobalContract.code))}Z().then(t=>{window.selector.ready(t)});
