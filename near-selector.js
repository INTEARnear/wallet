var C="intear://";function L(e){let t=atob(e.replace(/-/g,"+").replace(/_/g,"/"));return Uint8Array.from(t,s=>s.charCodeAt(0))}function A(e){let t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",s;e instanceof Uint8Array?s=e:s=Uint8Array.from(e);let a=0;for(;a<s.length&&s[a]===0;)a++;let n=[];for(let o=a;o<s.length;o++){let i=s[o];for(let l=0;l<n.length;l++)i+=n[l]<<8,n[l]=i%58,i=i/58|0;for(;i>0;)n.push(i%58),i=i/58|0}let r="";for(let o=0;o<a;o++)r+=t[0];for(let o=n.length-1;o>=0;o--)r+=t[n[o]];return r}async function q(e){let t=window.selector.open(`${e.walletUrl}/${e.method}`,"dontcare","width=400,height=700,scrollbars=yes,resizable=yes");if(await t.id()===null||t.closed)throw new Error("Popup blocked");return new Promise((s,a)=>{let n=!1,r=()=>{window.removeEventListener("message",o),i&&clearInterval(i)},o=async l=>{try{let c=l.data;if(c.type==="ready")t.postMessage({type:e.sendMessageType,data:e.sendData},e.walletUrl);else if(c.type===e.successMessageType&&!n){n=!0,r(),t.close();try{s(await e.onSuccess(c))}catch(h){a(h)}}else c.type==="error"&&!n&&(n=!0,r(),t.close(),e.isUserRejection?.(c.message)?s(null):a(new Error(c.message||"Operation failed")))}catch{}};window.addEventListener("message",o);let i=setInterval(()=>{t.closed&&!n&&(r(),n||s(null))},100)})}async function Q(e){let s=`${e.logoutBridgeUrl}/api/session/create`;return new Promise((a,n)=>{let r=!1,o=null,i=()=>{o&&(o.close(),o=null)};try{o=new WebSocket(s)}catch(l){n(new Error(`Failed to connect to logout bridge: ${l}`));return}o.onmessage=async l=>{try{let c=JSON.parse(l.data);if(c.session_id&&!r){let h=c.session_id;o.send(JSON.stringify({type:e.sendMessageType,data:e.sendData}));let b=`intear://${e.method}?session_id=${encodeURIComponent(h)}`;window.selector.openNativeApp(b)}else if(c.type===e.successMessageType&&!r){r=!0,i();try{a(await e.onSuccess(c))}catch(h){n(h)}}else c.type==="error"&&!r&&(r=!0,i(),e.isUserRejection?.(c.message)?a(null):n(new Error(c.message||"Operation failed")))}catch{}},o.onerror=l=>{r||(i(),n(new Error("WebSocket connection error to logout bridge")))},o.onclose=()=>{r||a(null)}})}async function O(e){return e.walletUrl===C||e.walletUrl=="tauri://localhost"?Q(e):q(e)}var T=class{accountId;disconnected;#e;constructor(t,s){this.accountId=t,this.#e=s,this.disconnected=!1}disconnect(){this.#e.disconnect()}async signMessage(t){if(this.disconnected)throw new Error("Account is disconnected");if(t.nonce.length!==32)throw new Error("Nonce must be 32 bytes");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let s=await this.#e.storage.get(k);if(!s)throw new Error("Private key not found in storage");let a=await crypto.subtle.importKey("jwk",s,{name:"Ed25519"},!0,["sign"]),n=L(s.x),o=`ed25519:${A(n)}`,i=JSON.stringify({message:t.message,nonce:Array.from(t.nonce),recipient:t.recipient,callback_url:t.callbackUrl??null,state:t.state??null}),l=Date.now(),c=`${l}|${i}`,h=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(c)),b=await crypto.subtle.sign({name:"Ed25519"},a,h),U=new Uint8Array(b),I=`ed25519:${A(U)}`,K={message:i,accountId:this.accountId,publicKey:o,nonce:l,signature:I},v=this.#e.walletUrl,B=this.#e.logoutBridgeUrl;return O({method:"sign-message",walletUrl:v,logoutBridgeUrl:B,sendMessageType:"signMessage",sendData:K,successMessageType:"signed",onSuccess:p=>({accountId:p.signature.accountId,publicKey:p.signature.publicKey,signature:p.signature.signature,state:p.signature.state}),isUserRejection:p=>p==="User rejected the signature"})}async sendTransactions(t){if(this.disconnected)throw new Error("Account is disconnected");if(!this.#e.walletUrl||!this.#e.logoutBridgeUrl)throw new Error("Wallet URL not available");let s=await this.#e.storage.get(k);if(!s)throw new Error("Private key not found in storage");let a=await crypto.subtle.importKey("jwk",s,{name:"Ed25519"},!0,["sign"]),n=L(s.x),o=`ed25519:${A(n)}`,i=t.map(y=>({signerId:y.signerId,receiverId:y.receiverId,actions:y.actions})),l=JSON.stringify(i),c=Date.now(),h=`${c}|${l}`,b=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(h)),U=await crypto.subtle.sign({name:"Ed25519"},a,b),E=new Uint8Array(U),K=`ed25519:${A(E)}`,v={accountId:this.accountId,publicKey:o,nonce:c,signature:K,transactions:l},B=this.#e.walletUrl,p=this.#e.logoutBridgeUrl;return O({method:"send-transactions",walletUrl:B,logoutBridgeUrl:p,sendMessageType:"signAndSendTransactions",sendData:v,successMessageType:"sent",onSuccess:y=>({outcomes:y.outcomes}),isUserRejection:y=>y==="User rejected the transactions"})}},S="accountId",k="appPrivateKey",P="walletUrl",_="logoutBridgeUrl",R=class e{#e;walletUrl;logoutBridgeUrl;storage;static async loadFrom(t){if(!t)throw new Error("loadFrom: Invalid arguments");let s=await t.get(S),a=await t.get(P),n=await t.get(_),r=new e(t,null,a,n),o=s?new T(s,r):null;return r.#e=o,r}constructor(t,s,a,n){this.storage=t,this.#e=s,this.walletUrl=a,this.logoutBridgeUrl=n}get connectedAccount(){return this.#e}async requestConnection(t={}){if(this.#e!==null)throw new Error("Already connected");let{networkId:s="mainnet",walletUrl:a="iframe:https://wallet.intear.tech",logoutBridgeUrl:n="wss://logout-bridge-service.intear.tech",messageToSign:r,relayerId:o=null}=t;if(r&&r.nonce.length!==32)throw new Error("Nonce must be 32 bytes");let i=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign"]),l=await crypto.subtle.exportKey("raw",i.publicKey),c=new Uint8Array(l),b=`ed25519:${A(c)}`,U;r?U={messageToSign:JSON.stringify({message:r.message,nonce:Array.from(r.nonce),recipient:r.recipient,callback_url:r.callbackUrl??null,state:r.state??null})}:U={};let E=JSON.stringify(U),I=Date.now(),K=`${I}|${E}`,v=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(K)),B=await crypto.subtle.sign({name:"Ed25519"},i.privateKey,v),p=new Uint8Array(B),H=`ed25519:${A(p)}`;if(a.startsWith("iframe:")){let g=new Promise(f=>{let m=null,w=setInterval(()=>{m&&(clearInterval(w),f(m))},100),M=u=>{u.data.origin&&(m=u.data.origin,window.removeEventListener("message",M))};window.addEventListener("message",M)}),x=a.substring(7),d=document.createElement("iframe");return d.src=`${x}/hot-wallet-connector-iframe.html`,d.style.position="fixed",d.style.inset="0",d.style.width="100vw",d.style.height="100vh",d.style.border="none",d.style.zIndex="100000",d.onload=()=>{window.selector.ui.showIframe(),g.then(f=>{d.contentWindow?.postMessage({type:"hotConnectorData",origin:f,location:window.selector.location},"*")})},document.body.appendChild(d),new Promise((f,m)=>{let w={},M=async u=>{if(u.data.status){d.contentWindow?.postMessage(u.data,"*");return}switch(u.data.type){case"ready":let G={publicKey:b,networkId:s,nonce:I,message:E,signature:H,version:"V3",relayerId:o};d.contentWindow?.postMessage({type:"signIn",data:G},"*");break;case"connected":let V=u.data.accountId,$=a===u.data.useBridge?C:u.data.walletUrl;this.walletUrl=$,this.logoutBridgeUrl=n,w={privateKeyJwk:await crypto.subtle.exportKey("jwk",i.privateKey),walletUrl:$,logoutBridgeUrl:n,accountId:V,signedMessage:u.data.signedMessage},d.contentWindow?.postMessage({type:"close"},"*");break;case"error":d.contentWindow?.postMessage({type:"close",message:u.data.message},"*");break;case"close":if(console.log("Closing with",w),d.remove(),window.removeEventListener("message",M),u.data.message)u.data.message=="User closed the modal"||u.data.message=="User rejected the connection"?f(null):m(new Error(u.data.message));else{this.#e=new T(w.accountId,this),await this.storage.set(k,w.privateKeyJwk),await this.storage.set(P,w.walletUrl),await this.storage.set(_,w.logoutBridgeUrl),await this.storage.set(S,w.accountId);let J={account:this.#e};if(r){if(!u.data.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");J.signedMessage={accountId:w.signedMessage.accountId,publicKey:w.signedMessage.publicKey,signature:w.signedMessage.signature,state:w.signedMessage.state}}f(J)}break}};window.addEventListener("message",M)})}else return O({method:"connect",walletUrl:a,logoutBridgeUrl:n,sendMessageType:"signIn",sendData:signInData,successMessageType:"connected",onSuccess:async g=>{let x=g.accountId;this.#e=new T(x,this);let d=a===g.useBridge?C:g.walletUrl;this.walletUrl=d,this.logoutBridgeUrl=n;let f=await crypto.subtle.exportKey("jwk",i.privateKey);await this.storage.set(k,f),await this.storage.set(P,d),await this.storage.set(_,n),await this.storage.set(S,x);let m={account:this.#e};if(r){if(!g.signedMessage)throw new Error("No signed message returned from wallet, this should never happen, a bug on wallet side");m.signedMessage={accountId:g.signedMessage.accountId,publicKey:g.signedMessage.publicKey,signature:g.signedMessage.signature,state:g.signedMessage.state}}return m},isUserRejection:g=>g==="User rejected the connection"})}async disconnect(){if(this.#e!==null)this.#e.disconnected=!0,this.#e=null,this.walletUrl=void 0,this.logoutBridgeUrl=void 0,await this.storage.remove(S),await this.storage.remove(k),await this.storage.remove(P),await this.storage.remove(_);else throw new Error("Account is not connected")}};var W=R;var D={get:async e=>JSON.parse(await window.selector.storage.get(e))??null,set:async(e,t)=>{let s=await D.get(e);return await window.selector.storage.set(e,JSON.stringify(t)),s},remove:async e=>{let t=await D.get(e);return await window.selector.storage.remove(e),t}},N=class{constructor(t){this.near=t}async signIn({network:t,contractId:s,methodNames:a}){this.near.connectedAccount&&await this.signOut({network:t}),(s||a)&&console.warn("[Intear Adapter] Contract ID and method names are not supported in near selector afaik. If you believe this is a mistake, or it's already supported, please write to intear wallet support or in telegram and it will be fixed asap.");let n=await this.near.requestConnection({networkId:t}).catch(r=>(console.error("Error in signIn",r),null));return n===null?[]:[{accountId:n.account.accountId}]}async signOut({network:t}){this.near.disconnect()}async getAccounts({network:t}){return this.near.connectedAccount?[{accountId:this.near.connectedAccount.accountId}]:[]}async signMessage({network:t,message:s,nonce:a,recipient:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");return this.near.connectedAccount.signMessage({message:s,nonce:a,recipient:n}).catch(async r=>{if(r.message==="Popup blocked")return await window.selector.ui.whenApprove({title:"App asks you to sign a message",button:"Sign"}),await this.near.connectedAccount.signMessage({message:s,nonce:a,recipient:n});throw r})}async signAndSendTransaction({network:t,signerId:s,receiverId:a,actions:n}){if(!this.near.connectedAccount)throw new Error("Account is not connected");return s=s??this.near.connectedAccount.accountId,n.forEach(j),(await this.near.connectedAccount.sendTransactions([{signerId:s,receiverId:a,actions:n}])).outcomes[0]}async signAndSendTransactions({network:t,transactions:s}){if(!this.near.connectedAccount)throw new Error("Account is not connected");return s=s.map(n=>({signerId:n.signerId??this.near.connectedAccount.accountId,receiverId:n.receiverId,actions:n.actions.forEach(j)})),(await this.near.connectedAccount.sendTransactions(s)).outcomes}};async function X(){return new N(await W.loadFrom(D))}function j(e){e.params?.code instanceof Uint8Array&&(e.params.code=Array.from(e.params.code)),e.deployContract?.code instanceof Uint8Array&&(e.deployContract.code=Array.from(e.deployContract.code)),e.deployGlobalContract?.code instanceof Uint8Array&&(e.deployGlobalContract.code=Array.from(e.deployGlobalContract.code))}X().then(e=>{window.selector.ready(e)});
