import{b as D,m as x,u as H,v as Q,y as L}from"./chunk-BJGTEFIT.js";import"./chunk-3LXE7Q4X.js";import"./chunk-7O2PPVEZ.js";import{w as j,z as E}from"./chunk-COAJKL54.js";import"./chunk-65GJ65H6.js";import"./chunk-FILZKAK2.js";import{C as b,la as W,o as z,qa as C,s as P,va as q}from"./chunk-OZZRRPYE.js";import"./chunk-FXML5DPA.js";import"./chunk-6OI5GZ4U.js";import"./chunk-YRGGSJIG.js";import{h as I,j as A,n as U}from"./chunk-KGCAX4NX.js";I();U();A();I();U();A();R.type="coinbaseWallet";function R(u={}){return u.version==="3"||u.headlessMode?Y(u):V(u)}function V(u){let v,w,p,l;return c=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:R.type,async connect({chainId:r,...a}={}){try{let i=await this.getProvider(),s=(await i.request({method:"eth_requestAccounts",params:"instantOnboarding"in a&&a.instantOnboarding?[{onboarding:"instant"}]:[]})).map(o=>b(o));w||(w=this.onAccountsChanged.bind(this),i.on("accountsChanged",w)),p||(p=this.onChainChanged.bind(this),i.on("chainChanged",p)),l||(l=this.onDisconnect.bind(this),i.on("disconnect",l));let t=await this.getChainId();return r&&t!==r&&(t=(await this.switchChain({chainId:r}).catch(e=>{if(e.code===C.code)throw e;return{id:t}}))?.id??t),{accounts:s,chainId:t}}catch(i){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(i.message)?new C(i):i}},async disconnect(){let r=await this.getProvider();w&&(r.removeListener("accountsChanged",w),w=void 0),p&&(r.removeListener("chainChanged",p),p=void 0),l&&(r.removeListener("disconnect",l),l=void 0),r.disconnect(),r.close?.()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(a=>b(a))},async getChainId(){let a=await(await this.getProvider()).request({method:"eth_chainId"});return Number(a)},async getProvider(){if(!v){let r=typeof u.preference=="string"?{options:u.preference}:{...u.preference,options:u.preference?.options??"all"},{createCoinbaseWalletSDK:a}=await import("./dist-2D4D6YJL.js");v=a({...u,appChainIds:c.chains.map(s=>s.id),preference:r}).getProvider()}return v},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:r,chainId:a}){let i=c.chains.find(t=>t.id===a);if(!i)throw new q(new D);let s=await this.getProvider();try{return await s.request({method:"wallet_switchEthereumChain",params:[{chainId:P(i.id)}]}),i}catch(t){if(t.code===4902)try{let o;r?.blockExplorerUrls?o=r.blockExplorerUrls:o=i.blockExplorers?.default.url?[i.blockExplorers?.default.url]:[];let e;r?.rpcUrls?.length?e=r.rpcUrls:e=[i.rpcUrls.default?.http[0]??""];let n={blockExplorerUrls:o,chainId:P(a),chainName:r?.chainName??i.name,iconUrls:r?.iconUrls,nativeCurrency:r?.nativeCurrency??i.nativeCurrency,rpcUrls:e};return await s.request({method:"wallet_addEthereumChain",params:[n]}),i}catch(o){throw new C(o)}throw new q(t)}},onAccountsChanged(r){r.length===0?this.onDisconnect():c.emitter.emit("change",{accounts:r.map(a=>b(a))})},onChainChanged(r){let a=Number(r);c.emitter.emit("change",{chainId:a})},async onDisconnect(r){c.emitter.emit("disconnect");let a=await this.getProvider();w&&(a.removeListener("accountsChanged",w),w=void 0),p&&(a.removeListener("chainChanged",p),p=void 0),l&&(a.removeListener("disconnect",l),l=void 0)}})}function Y(u){let w,p,l,c,r;return a=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:R.type,async connect({chainId:i}={}){try{let s=await this.getProvider(),t=(await s.request({method:"eth_requestAccounts"})).map(e=>b(e));l||(l=this.onAccountsChanged.bind(this),s.on("accountsChanged",l)),c||(c=this.onChainChanged.bind(this),s.on("chainChanged",c)),r||(r=this.onDisconnect.bind(this),s.on("disconnect",r));let o=await this.getChainId();return i&&o!==i&&(o=(await this.switchChain({chainId:i}).catch(n=>{if(n.code===C.code)throw n;return{id:o}}))?.id??o),{accounts:t,chainId:o}}catch(s){throw/(user closed modal|accounts received is empty|user denied account)/i.test(s.message)?new C(s):s}},async disconnect(){let i=await this.getProvider();l&&(i.removeListener("accountsChanged",l),l=void 0),c&&(i.removeListener("chainChanged",c),c=void 0),r&&(i.removeListener("disconnect",r),r=void 0),i.disconnect(),i.close()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(s=>b(s))},async getChainId(){let s=await(await this.getProvider()).request({method:"eth_chainId"});return Number(s)},async getProvider(){if(!p){let i=await(async()=>{let{default:n}=await import("./dist-DQGFJYX4.js");return typeof n!="function"&&typeof n.default=="function"?n.default:n})();w=new i({...u,reloadOnDisconnect:!1});let s=w.walletExtension?.getChainId(),t=a.chains.find(n=>u.chainId?n.id===u.chainId:n.id===s)||a.chains[0],o=u.chainId||t?.id,e=u.jsonRpcUrl||t?.rpcUrls.default.http[0];p=w.makeWeb3Provider(e,o)}return p},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:i,chainId:s}){let t=a.chains.find(e=>e.id===s);if(!t)throw new q(new D);let o=await this.getProvider();try{return await o.request({method:"wallet_switchEthereumChain",params:[{chainId:P(t.id)}]}),t}catch(e){if(e.code===4902)try{let n;i?.blockExplorerUrls?n=i.blockExplorerUrls:n=t.blockExplorers?.default.url?[t.blockExplorers?.default.url]:[];let h;i?.rpcUrls?.length?h=i.rpcUrls:h=[t.rpcUrls.default?.http[0]??""];let d={blockExplorerUrls:n,chainId:P(s),chainName:i?.chainName??t.name,iconUrls:i?.iconUrls,nativeCurrency:i?.nativeCurrency??t.nativeCurrency,rpcUrls:h};return await o.request({method:"wallet_addEthereumChain",params:[d]}),t}catch(n){throw new C(n)}throw new q(e)}},onAccountsChanged(i){i.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:i.map(s=>b(s))})},onChainChanged(i){let s=Number(i);a.emitter.emit("change",{chainId:s})},async onDisconnect(i){a.emitter.emit("disconnect");let s=await this.getProvider();l&&(s.removeListener("accountsChanged",l),l=void 0),c&&(s.removeListener("chainChanged",c),c=void 0),r&&(s.removeListener("disconnect",r),r=void 0)}})}I();U();A();K.type="metaMask";function K(u={}){let v,w,p,l,c,r,a,i;return s=>({id:"metaMaskSDK",name:"MetaMask",rdns:["io.metamask","io.metamask.mobile"],type:K.type,async setup(){let t=await this.getProvider();t?.on&&(r||(r=this.onConnect.bind(this),t.on("connect",r)),l||(l=this.onAccountsChanged.bind(this),t.on("accountsChanged",l)))},async connect({chainId:t,isReconnecting:o}={}){let e=await this.getProvider();a||(a=this.onDisplayUri,e.on("display_uri",a));let n=[];o&&(n=await this.getAccounts().catch(()=>[]));try{let h,d;n?.length||(u.connectAndSign||u.connectWith?(u.connectAndSign?h=await v.connectAndSign({msg:u.connectAndSign}):u.connectWith&&(d=await v.connectWith({method:u.connectWith.method,params:u.connectWith.params})),n=await this.getAccounts()):n=(await v.connect()).map(m=>b(m)));let f=await this.getChainId();return t&&f!==t&&(f=(await this.switchChain({chainId:t}).catch(m=>{if(m.code===C.code)throw m;return{id:f}}))?.id??f),a&&(e.removeListener("display_uri",a),a=void 0),h?e.emit("connectAndSign",{accounts:n,chainId:f,signResponse:h}):d&&e.emit("connectWith",{accounts:n,chainId:f,connectWithResponse:d}),r&&(e.removeListener("connect",r),r=void 0),l||(l=this.onAccountsChanged.bind(this),e.on("accountsChanged",l)),c||(c=this.onChainChanged.bind(this),e.on("chainChanged",c)),i||(i=this.onDisconnect.bind(this),e.on("disconnect",i)),{accounts:n,chainId:f}}catch(h){let d=h;throw d.code===C.code?new C(d):d.code===W.code?new W(d):d}},async disconnect(){let t=await this.getProvider();c&&(t.removeListener("chainChanged",c),c=void 0),i&&(t.removeListener("disconnect",i),i=void 0),r||(r=this.onConnect.bind(this),t.on("connect",r)),await v.terminate()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(e=>b(e))},async getChainId(){let t=await this.getProvider(),o=t.getChainId()||await t?.request({method:"eth_chainId"});return Number(o)},async getProvider(){async function t(){let o=await(async()=>{let{default:d}=await import("./metamask-sdk-PGXO7PUI.js");return typeof d!="function"&&typeof d.default=="function"?d.default:d})(),e={};for(let d of s.chains)e[P(d.id)]=L({chain:d,transports:s.transports})?.[0];v=new o({_source:"wagmi",forceDeleteProvider:!1,forceInjectProvider:!1,injectProvider:!1,...u,readonlyRPCMap:e,dappMetadata:{...u.dappMetadata,name:u.dappMetadata?.name?u.dappMetadata?.name:"wagmi",url:u.dappMetadata?.url?u.dappMetadata?.url:typeof window<"u"?window.location.origin:"https://wagmi.sh"},useDeeplink:u.useDeeplink??!0});let n=await v.init(),h=n?.activeProvider?n.activeProvider:v.getProvider();if(!h)throw new x;return h}return w||(p||(p=t()),w=await p),w},async isAuthorized(){try{return!!(await j(()=>E(()=>this.getAccounts(),{timeout:200}),{delay:201,retryCount:3})).length}catch{return!1}},async switchChain({addEthereumChainParameter:t,chainId:o}){let e=await this.getProvider(),n=s.chains.find(f=>f.id===o);if(!n)throw new q(new D);try{return await e.request({method:"wallet_switchEthereumChain",params:[{chainId:P(o)}]}),await h(),await d(o),n}catch(f){let y=f;if(y.code===C.code)throw new C(y);if(y.code===4902||y?.data?.originalError?.code===4902)try{return await e.request({method:"wallet_addEthereumChain",params:[{blockExplorerUrls:(()=>{let{default:m,...g}=n.blockExplorers??{};if(t?.blockExplorerUrls)return t.blockExplorerUrls;if(m)return[m.url,...Object.values(g).map(S=>S.url)]})(),chainId:P(o),chainName:t?.chainName??n.name,iconUrls:t?.iconUrls,nativeCurrency:t?.nativeCurrency??n.nativeCurrency,rpcUrls:t?.rpcUrls?.length?t.rpcUrls:[n.rpcUrls.default?.http[0]??""]}]}),await h(),await d(o),n}catch(m){let g=m;throw g.code===C.code?new C(g):new q(g)}throw new q(y)}async function h(){await j(async()=>{let f=z(await e.request({method:"eth_chainId"}));if(f!==o)throw new Error("User rejected switch after adding network.");return f},{delay:50,retryCount:20})}async function d(f){await new Promise(y=>{let m=g=>{"chainId"in g&&g.chainId===f&&(s.emitter.off("change",m),y())};s.emitter.on("change",m),s.emitter.emit("change",{chainId:f})})}},async onAccountsChanged(t){if(t.length===0)if(v.isExtensionActive())this.onDisconnect();else return;else if(s.emitter.listenerCount("connect")){let o=(await this.getChainId()).toString();this.onConnect({chainId:o})}else s.emitter.emit("change",{accounts:t.map(o=>b(o))})},onChainChanged(t){let o=Number(t);s.emitter.emit("change",{chainId:o})},async onConnect(t){let o=await this.getAccounts();if(o.length===0)return;let e=Number(t.chainId);s.emitter.emit("connect",{accounts:o,chainId:e});let n=await this.getProvider();r&&(n.removeListener("connect",r),r=void 0),l||(l=this.onAccountsChanged.bind(this),n.on("accountsChanged",l)),c||(c=this.onChainChanged.bind(this),n.on("chainChanged",c)),i||(i=this.onDisconnect.bind(this),n.on("disconnect",i))},async onDisconnect(t){let o=await this.getProvider();t&&t.code===1013&&o&&(await this.getAccounts()).length||(s.emitter.emit("disconnect"),c&&(o.removeListener("chainChanged",c),c=void 0),i&&(o.removeListener("disconnect",i),i=void 0),r||(r=this.onConnect.bind(this),o.on("connect",r)))},onDisplayUri(t){s.emitter.emit("message",{type:"display_uri",data:t})}})}I();U();A();O.type="safe";function O(u={}){let{shimDisconnect:v=!1}=u,w,p;return l=>({id:"safe",name:"Safe",type:O.type,async connect(){let c=await this.getProvider();if(!c)throw new x;let r=await this.getAccounts(),a=await this.getChainId();return p||(p=this.onDisconnect.bind(this),c.on("disconnect",p)),v&&await l.storage?.removeItem("safe.disconnected"),{accounts:r,chainId:a}},async disconnect(){let c=await this.getProvider();if(!c)throw new x;p&&(c.removeListener("disconnect",p),p=void 0),v&&await l.storage?.setItem("safe.disconnected",!0)},async getAccounts(){let c=await this.getProvider();if(!c)throw new x;return(await c.request({method:"eth_accounts"})).map(b)},async getProvider(){if(typeof window<"u"&&window?.parent!==window){if(!w){let{default:r}=await import("./esm-2CDEY2ZE.js"),a=new r(u),i=await E(()=>a.safe.getInfo(),{timeout:u.unstable_getInfoTimeout??10});if(!i)throw new Error("Could not load Safe information");let s=await(async()=>{let t=await import("./dist-V3IAXC56.js");return typeof t.SafeAppProvider!="function"&&typeof t.default.SafeAppProvider=="function"?t.default.SafeAppProvider:t.SafeAppProvider})();w=new s(i,a)}return w}},async getChainId(){let c=await this.getProvider();if(!c)throw new x;return Number(c.chainId)},async isAuthorized(){try{return v&&await l.storage?.getItem("safe.disconnected")?!1:!!(await this.getAccounts()).length}catch{return!1}},onAccountsChanged(){},onChainChanged(){},onDisconnect(){l.emitter.emit("disconnect")}})}I();U();A();F.type="walletConnect";function F(u){let v=u.isNewChainsStale??!0,w,p,l="eip155",c,r,a,i,s,t;return o=>({id:"walletConnect",name:"WalletConnect",type:F.type,async setup(){let e=await this.getProvider().catch(()=>null);e&&(a||(a=this.onConnect.bind(this),e.on("connect",a)),s||(s=this.onSessionDelete.bind(this),e.on("session_delete",s)))},async connect({chainId:e,...n}={}){try{let h=await this.getProvider();if(!h)throw new x;i||(i=this.onDisplayUri,h.on("display_uri",i));let d=e;if(!d){let g=await o.storage?.getItem("state")??{};o.chains.some(M=>M.id===g.chainId)?d=g.chainId:d=o.chains[0]?.id}if(!d)throw new Error("No chains found on connector.");let f=await this.isChainsStale();if(h.session&&f&&await h.disconnect(),!h.session||f){let g=o.chains.filter(S=>S.id!==d).map(S=>S.id);await h.connect({optionalChains:[d,...g],..."pairingTopic"in n?{pairingTopic:n.pairingTopic}:{}}),this.setRequestedChainsIds(o.chains.map(S=>S.id))}let y=(await h.enable()).map(g=>b(g)),m=await this.getChainId();return i&&(h.removeListener("display_uri",i),i=void 0),a&&(h.removeListener("connect",a),a=void 0),c||(c=this.onAccountsChanged.bind(this),h.on("accountsChanged",c)),r||(r=this.onChainChanged.bind(this),h.on("chainChanged",r)),t||(t=this.onDisconnect.bind(this),h.on("disconnect",t)),s||(s=this.onSessionDelete.bind(this),h.on("session_delete",s)),{accounts:y,chainId:m}}catch(h){throw/(user rejected|connection request reset)/i.test(h?.message)?new C(h):h}},async disconnect(){let e=await this.getProvider();try{await e?.disconnect()}catch(n){if(!/No matching key/i.test(n.message))throw n}finally{r&&(e?.removeListener("chainChanged",r),r=void 0),t&&(e?.removeListener("disconnect",t),t=void 0),a||(a=this.onConnect.bind(this),e?.on("connect",a)),c&&(e?.removeListener("accountsChanged",c),c=void 0),s&&(e?.removeListener("session_delete",s),s=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(n=>b(n))},async getProvider({chainId:e}={}){async function n(){let h=o.chains.map(f=>f.id);if(!h.length)return;let{EthereumProvider:d}=await import("./index.es-UDPBN4AN.js");return await d.init({...u,disableProviderPing:!0,optionalChains:h,projectId:u.projectId,rpcMap:Object.fromEntries(o.chains.map(f=>{let[y]=L({chain:f,transports:o.transports});return[f.id,y]})),showQrModal:u.showQrModal??!0})}return w||(p||(p=n()),w=await p,w?.events.setMaxListeners(Number.POSITIVE_INFINITY)),e&&await this.switchChain?.({chainId:e}),w},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{let[e,n]=await Promise.all([this.getAccounts(),this.getProvider()]);return e.length?await this.isChainsStale()&&n.session?(await n.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:n}){let h=await this.getProvider();if(!h)throw new x;let d=o.chains.find(f=>f.id===n);if(!d)throw new q(new D);try{await Promise.all([new Promise(y=>{let m=({chainId:g})=>{g===n&&(o.emitter.off("change",m),y())};o.emitter.on("change",m)}),h.request({method:"wallet_switchEthereumChain",params:[{chainId:P(n)}]})]);let f=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...f,n]),d}catch(f){let y=f;if(/(user rejected)/i.test(y.message))throw new C(y);try{let m;e?.blockExplorerUrls?m=e.blockExplorerUrls:m=d.blockExplorers?.default.url?[d.blockExplorers?.default.url]:[];let g;e?.rpcUrls?.length?g=e.rpcUrls:g=[...d.rpcUrls.default.http];let S={blockExplorerUrls:m,chainId:P(n),chainName:e?.chainName??d.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??d.nativeCurrency,rpcUrls:g};await h.request({method:"wallet_addEthereumChain",params:[S]});let M=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...M,n]),d}catch(m){throw new C(m)}}},onAccountsChanged(e){e.length===0?this.onDisconnect():o.emitter.emit("change",{accounts:e.map(n=>b(n))})},onChainChanged(e){let n=Number(e);o.emitter.emit("change",{chainId:n})},async onConnect(e){let n=Number(e.chainId),h=await this.getAccounts();o.emitter.emit("connect",{accounts:h,chainId:n})},async onDisconnect(e){this.setRequestedChainsIds([]),o.emitter.emit("disconnect");let n=await this.getProvider();c&&(n.removeListener("accountsChanged",c),c=void 0),r&&(n.removeListener("chainChanged",r),r=void 0),t&&(n.removeListener("disconnect",t),t=void 0),s&&(n.removeListener("session_delete",s),s=void 0),a||(a=this.onConnect.bind(this),n.on("connect",a))},onDisplayUri(e){o.emitter.emit("message",{type:"display_uri",data:e})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){return w?w.session?.namespaces[l]?.accounts?.map(n=>Number.parseInt(n.split(":")[1]||""))??[]:[]},async getRequestedChainsIds(){return await o.storage?.getItem(this.requestedChainsStorageKey)??[]},async isChainsStale(){if(!v)return!1;let e=o.chains.map(d=>d.id),n=this.getNamespaceChainsIds();if(n.length&&!n.some(d=>e.includes(d)))return!1;let h=await this.getRequestedChainsIds();return!e.every(d=>h.includes(d))},async setRequestedChainsIds(e){await o.storage?.setItem(this.requestedChainsStorageKey,e)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}I();U();A();var $="5.8.3";export{R as coinbaseWallet,H as injected,K as metaMask,Q as mock,O as safe,$ as version,F as walletConnect};
