import"./chunk-OIGRERY3.js";import"./chunk-R3ZLVNED.js";import"./chunk-AC32W45S.js";import"./chunk-XQPJEOS5.js";import{b as ke,d as lo}from"./chunk-LSFPNUYI.js";import{D as je,F as Kt,L as co,N as uo,b as ee,g as so,j as En,k as oo,l as io,o as ao}from"./chunk-WYPOXQ7L.js";import{a as xr,d as Ys,h as Xs,i as Br,j as Js,k as Zs,l as Qs}from"./chunk-MAV5EFVZ.js";import"./chunk-HG3QHOOL.js";import{a as Ur}from"./chunk-3LXE7Q4X.js";import{a as eo,b as to}from"./chunk-7B43BGZA.js";import"./chunk-7O2PPVEZ.js";import{c as no,d as ro}from"./chunk-B6CGM4M7.js";import"./chunk-6N5K4EEA.js";import"./chunk-6YRCTRZB.js";import"./chunk-GYTDKIFP.js";import"./chunk-237QXMMD.js";import"./chunk-FS4YWWYV.js";import"./chunk-UDTBWQKV.js";import{d as Ds,e as Ms,g as zs,h as Fs}from"./chunk-ETAVA44A.js";import{a as fe}from"./chunk-KIG3ADHQ.js";import"./chunk-JK5MJGFP.js";import"./chunk-COAJKL54.js";import{a as Pr}from"./chunk-65GJ65H6.js";import{a as Us}from"./chunk-E3J3KTZS.js";import"./chunk-H6T4G3YK.js";import"./chunk-JBYAY2RL.js";import"./chunk-PIVQIF3J.js";import{a as Pe,b as xe,c as Hs,d as Lr,e as An,f as qs,g as Gs,h as js,i as Rn}from"./chunk-YO3XBZXY.js";import{b as Ks}from"./chunk-FILZKAK2.js";import{w as Or}from"./chunk-OZZRRPYE.js";import"./chunk-FXML5DPA.js";import{c as yn,e as $s,h as mn,j as Tr,k as We,l as kr,o as Nt,s as Vs,t as vr}from"./chunk-6OI5GZ4U.js";import{H as Ws}from"./chunk-YRGGSJIG.js";import"./chunk-5RP2GFJC.js";import{c as Ge,f as tt,g as Nr,h as p,j as g,k as y,l as ia,m as Cr,n as _}from"./chunk-KGCAX4NX.js";var mo=Ge((Mp,yo)=>{"use strict";p();_();g();var wn=to().Buffer;function ya(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<s.length;n++){var r=s.charAt(n),o=r.charCodeAt(0);if(e[o]!==255)throw new TypeError(r+" is ambiguous");e[o]=n}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),h=Math.log(256)/Math.log(i);function d(m){if((Array.isArray(m)||m instanceof Uint8Array)&&(m=wn.from(m)),!wn.isBuffer(m))throw new TypeError("Expected Buffer");if(m.length===0)return"";for(var E=0,A=0,S=0,P=m.length;S!==P&&m[S]===0;)S++,E++;for(var F=(P-S)*h+1>>>0,se=new Uint8Array(F);S!==P;){for(var x=m[S],ae=0,ce=F-1;(x!==0||ae<A)&&ce!==-1;ce--,ae++)x+=256*se[ce]>>>0,se[ce]=x%i>>>0,x=x/i>>>0;if(x!==0)throw new Error("Non-zero carry");A=ae,S++}for(var G=F-A;G!==F&&se[G]===0;)G++;for(var _e=a.repeat(E);G<F;++G)_e+=s.charAt(se[G]);return _e}function w(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return wn.alloc(0);for(var E=0,A=0,S=0;m[E]===a;)A++,E++;for(var P=(m.length-E)*c+1>>>0,F=new Uint8Array(P);E<m.length;){var se=m.charCodeAt(E);if(se>255)return;var x=e[se];if(x===255)return;for(var ae=0,ce=P-1;(x!==0||ae<S)&&ce!==-1;ce--,ae++)x+=i*F[ce]>>>0,F[ce]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");S=ae,E++}for(var G=P-S;G!==P&&F[G]===0;)G++;var _e=wn.allocUnsafe(A+(P-G));_e.fill(0,0,A);for(var It=A;G!==P;)_e[It++]=F[G++];return _e}function v(m){var E=w(m);if(E)return E;throw new Error("Non-base"+i+" character")}return{encode:d,decodeUnsafe:w,decode:v}}yo.exports=ya});var Ro=Ge((Kp,Ao)=>{p();_();g();var ma=mo(),Aa="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";Ao.exports=ma(Aa)});var wo=Ge((qp,Eo)=>{"use strict";p();_();g();var Sn=to().Buffer;function Ra(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<s.length;n++){var r=s.charAt(n),o=r.charCodeAt(0);if(e[o]!==255)throw new TypeError(r+" is ambiguous");e[o]=n}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),h=Math.log(256)/Math.log(i);function d(m){if((Array.isArray(m)||m instanceof Uint8Array)&&(m=Sn.from(m)),!Sn.isBuffer(m))throw new TypeError("Expected Buffer");if(m.length===0)return"";for(var E=0,A=0,S=0,P=m.length;S!==P&&m[S]===0;)S++,E++;for(var F=(P-S)*h+1>>>0,se=new Uint8Array(F);S!==P;){for(var x=m[S],ae=0,ce=F-1;(x!==0||ae<A)&&ce!==-1;ce--,ae++)x+=256*se[ce]>>>0,se[ce]=x%i>>>0,x=x/i>>>0;if(x!==0)throw new Error("Non-zero carry");A=ae,S++}for(var G=F-A;G!==F&&se[G]===0;)G++;for(var _e=a.repeat(E);G<F;++G)_e+=s.charAt(se[G]);return _e}function w(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return Sn.alloc(0);for(var E=0,A=0,S=0;m[E]===a;)A++,E++;for(var P=(m.length-E)*c+1>>>0,F=new Uint8Array(P);E<m.length;){var se=m.charCodeAt(E);if(se>255)return;var x=e[se];if(x===255)return;for(var ae=0,ce=P-1;(x!==0||ae<S)&&ce!==-1;ce--,ae++)x+=i*F[ce]>>>0,F[ce]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");S=ae,E++}for(var G=P-S;G!==P&&F[G]===0;)G++;var _e=Sn.allocUnsafe(A+(P-G));_e.fill(0,0,A);for(var It=A;G!==P;)_e[It++]=F[G++];return _e}function v(m){var E=w(m);if(E)return E;throw new Error("Non-base"+i+" character")}return{encode:d,decodeUnsafe:w,decode:v}}Eo.exports=Ra});var bo=Ge((Xp,So)=>{p();_();g();var Ea=wo(),wa="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";So.exports=Ea(wa)});var Io=Ge(Fr=>{"use strict";p();_();g();function Ye(s,e,t){return e<=s&&s<=t}function On(s){if(s===void 0)return{};if(s===Object(s))return s;throw TypeError("Could not convert argument to dictionary")}function Sa(s){for(var e=String(s),t=e.length,n=0,r=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)r.push(o);else if(56320<=o&&o<=57343)r.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)r.push(65533);else{var i=s.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;r.push(65536+(a<<10)+c),n+=1}else r.push(65533)}n+=1}return r}function ba(s){for(var e="",t=0;t<s.length;++t){var n=s[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var bn=-1;function zr(s){this.tokens=[].slice.call(s)}zr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():bn},prepend:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(s)},push:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.push(e.shift());else this.tokens.push(s)}};var Ct=-1;function Mr(s,e){if(s)throw TypeError("Decoder error");return e||65533}var In="utf-8";function Nn(s,e){if(!(this instanceof Nn))return new Nn(s,e);if(s=s!==void 0?String(s).toLowerCase():In,s!==In)throw new Error("Encoding not supported. Only utf-8 is supported");e=On(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}Nn.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=On(t),this._streaming||(this._decoder=new Ia({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var r=new zr(n),o=[],i;!r.endOfStream()&&(i=this._decoder.handler(r,r.read()),i!==Ct);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(r,r.read()),i===Ct)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!r.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),ba(o)}};function Cn(s,e){if(!(this instanceof Cn))return new Cn(s,e);if(s=s!==void 0?String(s).toLowerCase():In,s!==In)throw new Error("Encoding not supported. Only utf-8 is supported");e=On(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}Cn.prototype={encode:function(e,t){e=e?String(e):"",t=On(t),this._streaming||(this._encoder=new Na(this._options)),this._streaming=!!t.stream;for(var n=[],r=new zr(Sa(e)),o;!r.endOfStream()&&(o=this._encoder.handler(r,r.read()),o!==Ct);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(r,r.read()),o!==Ct;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function Ia(s){var e=s.fatal,t=0,n=0,r=0,o=128,i=191;this.handler=function(a,c){if(c===bn&&r!==0)return r=0,Mr(e);if(c===bn)return Ct;if(r===0){if(Ye(c,0,127))return c;if(Ye(c,194,223))r=1,t=c-192;else if(Ye(c,224,239))c===224&&(o=160),c===237&&(i=159),r=2,t=c-224;else if(Ye(c,240,244))c===240&&(o=144),c===244&&(i=143),r=3,t=c-240;else return Mr(e);return t=t<<6*r,null}if(!Ye(c,o,i))return t=r=n=0,o=128,i=191,a.prepend(c),Mr(e);if(o=128,i=191,n+=1,t+=c-128<<6*(r-n),n!==r)return null;var h=t;return t=r=n=0,h}}function Na(s){var e=s.fatal;this.handler=function(t,n){if(n===bn)return Ct;if(Ye(n,0,127))return n;var r,o;Ye(n,128,2047)?(r=1,o=192):Ye(n,2048,65535)?(r=2,o=224):Ye(n,65536,1114111)&&(r=3,o=240);for(var i=[(n>>6*r)+o];r>0;){var a=n>>6*(r-1);i.push(128|a&63),r-=1}return i}}Fr.TextEncoder=Cn;Fr.TextDecoder=Nn});var ko=Ge(Z=>{"use strict";p();_();g();var Ca=Z&&Z.__createBinding||(Object.create?function(s,e,t,n){n===void 0&&(n=t),Object.defineProperty(s,n,{enumerable:!0,get:function(){return e[t]}})}:function(s,e,t,n){n===void 0&&(n=t),s[n]=e[t]}),Oa=Z&&Z.__setModuleDefault||(Object.create?function(s,e){Object.defineProperty(s,"default",{enumerable:!0,value:e})}:function(s,e){s.default=e}),$e=Z&&Z.__decorate||function(s,e,t,n){var r=arguments.length,o=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(s,e,t,n);else for(var a=s.length-1;a>=0;a--)(i=s[a])&&(o=(r<3?i(o):r>3?i(e,t,o):i(e,t))||o);return r>3&&o&&Object.defineProperty(e,t,o),o},Ta=Z&&Z.__importStar||function(s){if(s&&s.__esModule)return s;var e={};if(s!=null)for(var t in s)t!=="default"&&Object.hasOwnProperty.call(s,t)&&Ca(e,s,t);return Oa(e,s),e},No=Z&&Z.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(Z,"__esModule",{value:!0});Z.deserializeUnchecked=Z.deserialize=Z.serialize=Z.BinaryReader=Z.BinaryWriter=Z.BorshError=Z.baseDecode=Z.baseEncode=void 0;var nt=No(eo()),Co=No(bo()),ka=Ta(Io()),va=typeof TextDecoder!="function"?ka.TextDecoder:TextDecoder,La=new va("utf-8",{fatal:!0});function Pa(s){return typeof s=="string"&&(s=y.from(s,"utf8")),Co.default.encode(y.from(s))}Z.baseEncode=Pa;function xa(s){return y.from(Co.default.decode(s))}Z.baseDecode=xa;var Wr=1024,pe=class extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}};Z.BorshError=pe;var Tn=class{constructor(){this.buf=y.alloc(Wr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=y.concat([this.buf,y.alloc(Wr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(y.from(new nt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(y.from(new nt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(y.from(new nt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(y.from(new nt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=y.concat([y.from(this.buf.subarray(0,this.length)),e,y.alloc(Wr)]),this.length+=e.length}writeString(e){this.maybeResize();let t=y.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(y.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(let n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}};Z.BinaryWriter=Tn;function Ve(s,e,t){let n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(o){if(o instanceof RangeError){let i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new pe("Reached the end of buffer when deserializing")}throw o}}}var Ee=class{constructor(e){this.buf=e,this.offset=0}readU8(){let e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){let e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){let e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){let e=this.readBuffer(8);return new nt.default(e,"le")}readU128(){let e=this.readBuffer(16);return new nt.default(e,"le")}readU256(){let e=this.readBuffer(32);return new nt.default(e,"le")}readU512(){let e=this.readBuffer(64);return new nt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new pe(`Expected buffer length ${e} isn't within bounds`);let t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){let e=this.readU32(),t=this.readBuffer(e);try{return La.decode(t)}catch(n){throw new pe(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){let t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}};$e([Ve],Ee.prototype,"readU8",null);$e([Ve],Ee.prototype,"readU16",null);$e([Ve],Ee.prototype,"readU32",null);$e([Ve],Ee.prototype,"readU64",null);$e([Ve],Ee.prototype,"readU128",null);$e([Ve],Ee.prototype,"readU256",null);$e([Ve],Ee.prototype,"readU512",null);$e([Ve],Ee.prototype,"readString",null);$e([Ve],Ee.prototype,"readFixedArray",null);$e([Ve],Ee.prototype,"readArray",null);Z.BinaryReader=Ee;function Oo(s){return s.charAt(0).toUpperCase()+s.slice(1)}function pt(s,e,t,n,r){try{if(typeof n=="string")r[`write${Oo(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new pe(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new pe(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)pt(s,null,t[o],n[0],r)}else r.writeArray(t,o=>{pt(s,e,o,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),pt(s,e,t,n.type,r));break}case"map":{r.writeU32(t.size),t.forEach((o,i)=>{pt(s,e,i,n.key,r),pt(s,e,o,n.value,r)});break}default:throw new pe(`FieldType ${n} unrecognized`)}else To(s,t,r)}catch(o){throw o instanceof pe&&o.addToFieldPath(e),o}}function To(s,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}let n=s.get(e.constructor);if(!n)throw new pe(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,o])=>{pt(s,r,e[r],o,t)});else if(n.kind==="enum"){let r=e[n.field];for(let o=0;o<n.values.length;++o){let[i,a]=n.values[o];if(i===r){t.writeU8(o),pt(s,i,e[i],a,t);break}}}else throw new pe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ba(s,e,t=Tn){let n=new t;return To(s,e,n),n.toArray()}Z.serialize=Ba;function gt(s,e,t,n){try{if(typeof t=="string")return n[`read${Oo(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){let r=[];for(let o=0;o<t[1];o++)r.push(gt(s,null,t[0],n));return r}else return n.readArray(()=>gt(s,e,t[0],n))}if(t.kind==="option")return n.readU8()?gt(s,e,t.type,n):void 0;if(t.kind==="map"){let r=new Map,o=n.readU32();for(let i=0;i<o;i++){let a=gt(s,e,t.key,n),c=gt(s,e,t.value,n);r.set(a,c)}return r}return Kr(s,t,n)}catch(r){throw r instanceof pe&&r.addToFieldPath(e),r}}function Kr(s,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);let n=s.get(e);if(!n)throw new pe(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){let r={};for(let[o,i]of s.get(e).fields)r[o]=gt(s,o,i,t);return new e(r)}if(n.kind==="enum"){let r=t.readU8();if(r>=n.values.length)throw new pe(`Enum index: ${r} is out of range`);let[o,i]=n.values[r],a=gt(s,o,i,t);return new e({[o]:a})}throw new pe(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ua(s,e,t,n=Ee){let r=new n(t),o=Kr(s,e,r);if(r.offset<t.length)throw new pe(`Unexpected ${t.length-r.offset} bytes after deserialized data`);return o}Z.deserialize=Ua;function Da(s,e,t,n=Ee){let r=new n(t);return Kr(s,e,r)}Z.deserializeUnchecked=Da});var qr=Ge(f=>{"use strict";p();_();g();Object.defineProperty(f,"__esModule",{value:!0});f.s16=f.s8=f.nu64be=f.u48be=f.u40be=f.u32be=f.u24be=f.u16be=f.nu64=f.u48=f.u40=f.u32=f.u24=f.u16=f.u8=f.offset=f.greedy=f.Constant=f.UTF8=f.CString=f.Blob=f.Boolean=f.BitField=f.BitStructure=f.VariantLayout=f.Union=f.UnionLayoutDiscriminator=f.UnionDiscriminator=f.Structure=f.Sequence=f.DoubleBE=f.Double=f.FloatBE=f.Float=f.NearInt64BE=f.NearInt64=f.NearUInt64BE=f.NearUInt64=f.IntBE=f.Int=f.UIntBE=f.UInt=f.OffsetLayout=f.GreedyCount=f.ExternalLayout=f.bindConstructorLayout=f.nameWithProperty=f.Layout=f.uint8ArrayToBuffer=f.checkUint8Array=void 0;f.constant=f.utf8=f.cstr=f.blob=f.unionLayoutDiscriminator=f.union=f.seq=f.bits=f.struct=f.f64be=f.f64=f.f32be=f.f32=f.ns64be=f.s48be=f.s40be=f.s32be=f.s24be=f.s16be=f.ns64=f.s48=f.s40=f.s32=f.s24=void 0;var Vr=(Cr(),Nr(ia));function kt(s){if(!(s instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}f.checkUint8Array=kt;function Y(s){return kt(s),Vr.Buffer.from(s.buffer,s.byteOffset,s.length)}f.uint8ArrayToBuffer=Y;var X=class{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){let t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}};f.Layout=X;function Hr(s,e){return e.property?s+"["+e.property+"]":s}f.nameWithProperty=Hr;function Ma(s,e){if(typeof s!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(s,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof X))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");s.layout_=e,e.boundConstructor_=s,e.makeDestinationObject=()=>new s,Object.defineProperty(s.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(s,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}f.bindConstructorLayout=Ma;var me=class extends X{isCount(){throw new Error("ExternalLayout is abstract")}};f.ExternalLayout=me;var kn=class extends me{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){kt(e);let n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}};f.GreedyCount=kn;var Vt=class extends me{constructor(e,t=0,n){if(!(e instanceof X))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof we||this.layout instanceof be}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}};f.OffsetLayout=Vt;var we=class extends X{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Y(e).readUIntLE(t,this.span)}encode(e,t,n=0){return Y(t).writeUIntLE(e,n,this.span),this.span}};f.UInt=we;var be=class extends X{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Y(e).readUIntBE(t,this.span)}encode(e,t,n=0){return Y(t).writeUIntBE(e,n,this.span),this.span}};f.UIntBE=be;var Xe=class extends X{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Y(e).readIntLE(t,this.span)}encode(e,t,n=0){return Y(t).writeIntLE(e,n,this.span),this.span}};f.Int=Xe;var rt=class extends X{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return Y(e).readIntBE(t,this.span)}encode(e,t,n=0){return Y(t).writeIntBE(e,n,this.span),this.span}};f.IntBE=rt;var $r=Math.pow(2,32);function Gn(s){let e=Math.floor(s/$r),t=s-e*$r;return{hi32:e,lo32:t}}function jn(s,e){return s*$r+e}var vn=class extends X{constructor(e){super(8,e)}decode(e,t=0){let n=Y(e),r=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return jn(o,r)}encode(e,t,n=0){let r=Gn(e),o=Y(t);return o.writeUInt32LE(r.lo32,n),o.writeUInt32LE(r.hi32,n+4),8}};f.NearUInt64=vn;var Ln=class extends X{constructor(e){super(8,e)}decode(e,t=0){let n=Y(e),r=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return jn(r,o)}encode(e,t,n=0){let r=Gn(e),o=Y(t);return o.writeUInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}};f.NearUInt64BE=Ln;var Pn=class extends X{constructor(e){super(8,e)}decode(e,t=0){let n=Y(e),r=n.readUInt32LE(t),o=n.readInt32LE(t+4);return jn(o,r)}encode(e,t,n=0){let r=Gn(e),o=Y(t);return o.writeUInt32LE(r.lo32,n),o.writeInt32LE(r.hi32,n+4),8}};f.NearInt64=Pn;var xn=class extends X{constructor(e){super(8,e)}decode(e,t=0){let n=Y(e),r=n.readInt32BE(t),o=n.readUInt32BE(t+4);return jn(r,o)}encode(e,t,n=0){let r=Gn(e),o=Y(t);return o.writeInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}};f.NearInt64BE=xn;var Bn=class extends X{constructor(e){super(4,e)}decode(e,t=0){return Y(e).readFloatLE(t)}encode(e,t,n=0){return Y(t).writeFloatLE(e,n),4}};f.Float=Bn;var Un=class extends X{constructor(e){super(4,e)}decode(e,t=0){return Y(e).readFloatBE(t)}encode(e,t,n=0){return Y(t).writeFloatBE(e,n),4}};f.FloatBE=Un;var Dn=class extends X{constructor(e){super(8,e)}decode(e,t=0){return Y(e).readDoubleLE(t)}encode(e,t,n=0){return Y(t).writeDoubleLE(e,n),8}};f.Double=Dn;var Mn=class extends X{constructor(e){super(8,e)}decode(e,t=0){return Y(e).readDoubleBE(t)}encode(e,t,n=0){return Y(t).writeDoubleBE(e,n),8}};f.DoubleBE=Mn;var zn=class extends X{constructor(e,t,n){if(!(e instanceof X))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof me&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;!(t instanceof me)&&0<e.span&&(r=t*e.span),super(r,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,r=this.count;if(r instanceof me&&(r=r.decode(e,t)),0<this.elementLayout.span)n=r*this.elementLayout.span;else{let o=0;for(;o<r;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){let n=[],r=0,o=this.count;for(o instanceof me&&(o=o.decode(e,t));r<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return n}encode(e,t,n=0){let r=this.elementLayout,o=e.reduce((i,a)=>i+r.encode(a,t,n+i),0);return this.count instanceof me&&this.count.encode(e.length,t,n),o}};f.Sequence=zn;var Fn=class extends X{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof X,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(let o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(r,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((r,o)=>{let i=o.getSpan(e,t);return t+=i,r+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){kt(e);let n=this.makeDestinationObject();for(let r of this.fields)if(r.property!==void 0&&(n[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){let r=n,o=0,i=0;for(let a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){let h=e[a.property];h!==void 0&&(i=a.encode(h,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-r}fromArray(e){let t=this.makeDestinationObject();for(let n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(let n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}};f.Structure=Fn;var Ht=class{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}};f.UnionDiscriminator=Ht;var Tt=class extends Ht{constructor(e,t){if(!(e instanceof me&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}};f.UnionLayoutDiscriminator=Tt;var qt=class extends X{constructor(e,t,n){let r;if(e instanceof we||e instanceof be)r=new Tt(new Vt(e));else if(e instanceof me&&e.isCount())r=new Tt(e);else if(e instanceof Ht)r=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof X))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof we||e instanceof be)&&(o+=r.layout.span)),super(o,n),this.discriminator=r,this.usesPrefixDiscriminator=e instanceof we||e instanceof be,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;let n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;let t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(let t in this.registry){let n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n,r=this.discriminator,o=r.decode(e,t),i=this.registry[o];if(i===void 0){let a=this.defaultLayout,c=0;this.usesPrefixDiscriminator&&(c=r.layout.span),n=this.makeDestinationObject(),n[r.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){let r=this.getSourceVariant(e);if(r===void 0){let o=this.discriminator,i=this.defaultLayout,a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return r.encode(e,t,n)}addVariant(e,t,n){let r=new Wn(this,e,t,n);return this.registry[e]=r,r}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}};f.Union=qt;var Wn=class extends X{constructor(e,t,n,r){if(!(e instanceof qt))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&r===void 0&&(r=n,n=null),n){if(!(n instanceof X))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof r!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,r),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let r=0;return this.layout&&(r=this.layout.getSpan(e,t+n)),n+r}decode(e,t=0){let n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=r;if(this.layout&&(this.layout.encode(e[this.property],t,n+r),o+=this.layout.getSpan(t,n+r),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}};f.VariantLayout=Wn;function Ot(s){return 0>s&&(s+=4294967296),s}var Gt=class extends X{constructor(e,t,n){if(!(e instanceof we||e instanceof be))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(o){return r=Ot(o),this},this._packedGetValue=function(){return r}}decode(e,t=0){let n=this.makeDestinationObject(),r=this.word.decode(e,t);this._packedSetValue(r);for(let o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){let r=this.word.decode(t,n);this._packedSetValue(r);for(let o of this.fields)if(o.property!==void 0){let i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){let n=new jt(this,e,t);return this.fields.push(n),n}addBoolean(e){let t=new Kn(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}};f.BitStructure=Gt;var jt=class{constructor(e,t,n){if(!(e instanceof Gt))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");let r=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>r)throw new Error("bits too long for span remainder ("+(r-o)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=r-o-t),this.wordMask=Ot(this.valueMask<<this.start),this.property=n}decode(e,t){let n=this.container._packedGetValue();return Ot(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==Ot(e&this.valueMask))throw new TypeError(Hr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let t=this.container._packedGetValue(),n=Ot(e<<this.start);this.container._packedSetValue(Ot(t&~this.wordMask)|n)}};f.BitField=jt;var Kn=class extends jt{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};f.Boolean=Kn;var $n=class extends X{constructor(e,t){if(!(e instanceof me&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof me||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),Y(e).slice(t,t+n)}encode(e,t,n){let r=this.length;if(this.length instanceof me&&(r=e.length),!(e instanceof Uint8Array&&r===e.length))throw new TypeError(Hr("Blob.encode",this)+" requires (length "+r+") Uint8Array as src");if(n+r>t.length)throw new RangeError("encoding overruns Uint8Array");let o=Y(e);return Y(t).write(o.toString("hex"),n,r,"hex"),this.length instanceof me&&this.length.encode(r,t,n),r}};f.Blob=$n;var Vn=class extends X{constructor(e){super(-1,e)}getSpan(e,t=0){kt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){let n=this.getSpan(e,t);return Y(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let r=Vr.Buffer.from(e,"utf8"),o=r.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");let i=Y(t);return r.copy(i,n),i[n+o]=0,o+1}};f.CString=Vn;var Hn=class extends X{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return kt(e),e.length-t}decode(e,t=0){let n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return Y(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let r=Vr.Buffer.from(e,"utf8"),o=r.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return r.copy(Y(t),n),o}};f.UTF8=Hn;var qn=class extends X{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}};f.Constant=qn;f.greedy=(s,e)=>new kn(s,e);f.offset=(s,e,t)=>new Vt(s,e,t);f.u8=s=>new we(1,s);f.u16=s=>new we(2,s);f.u24=s=>new we(3,s);f.u32=s=>new we(4,s);f.u40=s=>new we(5,s);f.u48=s=>new we(6,s);f.nu64=s=>new vn(s);f.u16be=s=>new be(2,s);f.u24be=s=>new be(3,s);f.u32be=s=>new be(4,s);f.u40be=s=>new be(5,s);f.u48be=s=>new be(6,s);f.nu64be=s=>new Ln(s);f.s8=s=>new Xe(1,s);f.s16=s=>new Xe(2,s);f.s24=s=>new Xe(3,s);f.s32=s=>new Xe(4,s);f.s40=s=>new Xe(5,s);f.s48=s=>new Xe(6,s);f.ns64=s=>new Pn(s);f.s16be=s=>new rt(2,s);f.s24be=s=>new rt(3,s);f.s32be=s=>new rt(4,s);f.s40be=s=>new rt(5,s);f.s48be=s=>new rt(6,s);f.ns64be=s=>new xn(s);f.f32=s=>new Bn(s);f.f32be=s=>new Un(s);f.f64=s=>new Dn(s);f.f64be=s=>new Mn(s);f.struct=(s,e,t)=>new Fn(s,e,t);f.bits=(s,e,t)=>new Gt(s,e,t);f.seq=(s,e,t)=>new zn(s,e,t);f.union=(s,e,t)=>new qt(s,e,t);f.unionLayoutDiscriminator=(s,e)=>new Tt(s,e);f.blob=(s,e)=>new $n(s,e);f.cstr=s=>new Vn(s);f.utf8=(s,e)=>new Hn(s,e);f.constant=(s,e)=>new qn(s,e)});var Xo=Ge((Pg,Yo)=>{"use strict";p();_();g();var Xl=(ro(),Nr(no)).v4,Jl=function(s,e,t,n){if(typeof s!="string")throw new TypeError(s+" must be a string");n=n||{};let r=typeof n.version=="number"?n.version:2;if(r!==1&&r!==2)throw new TypeError(r+" must be 1 or 2");let o={method:s};if(r===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){let i=typeof n.generator=="function"?n.generator:function(){return Xl()};o.id=i(o,n)}else r===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};Yo.exports=Jl});var Zo=Ge((Dg,Jo)=>{"use strict";p();_();g();var Zl=(ro(),Nr(no)).v4,Ql=Xo(),Jt=function(s,e){if(!(this instanceof Jt))return new Jt(s,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Zl()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=s};Jo.exports=Jt;Jt.prototype.request=function(s,e,t,n){let r=this,o=null,i=Array.isArray(s)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&s&&typeof s=="object"&&typeof e=="function")n=e,o=s;else{typeof t=="function"&&(n=t,t=void 0);let h=typeof n=="function";try{o=Ql(s,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(d){if(h)return n(d);throw d}if(!h)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(h){return n(h)}return this.callServer(c,function(h,d){r._parseResponse(h,d,n)}),o};Jt.prototype._parseResponse=function(s,e,t){if(s){t(s);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(r){return t(r)}if(t.length===3)if(Array.isArray(n)){let r=function(i){return typeof i.error<"u"},o=function(i){return!r(i)};return t(null,n.filter(r),n.filter(o))}else return t(null,n.error,n.result);t(null,n)}});p();_();g();var Me=tt(Us(),1);p();_();g();var $t=Ds({connection:null}),ht={state:$t,subscribeKey(s,e){return Fs($t,s,e)},subscribe(s){return Ms($t,()=>s($t))},setConnection(s){$t.connection=zs(s)}};p();_();g();p();_();g();Cr();p();_();g();p();_();g();var Ke=BigInt(0),Re=BigInt(1),ho=BigInt(2),aa=BigInt(8),ca={zip215:!0};function ua(s){let e=js(s);return Vs(s,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function fo(s){let e=ua(s),{Fp:t,n,prehash:r,hash:o,randomBytes:i,nByteLength:a,h:c}=e,h=ho<<BigInt(a*8)-Re,d=t.create,w=An(e.n,e.nBitLength);function v(z,I){let U=t.sqr(z),M=t.sqr(I),V=t.add(t.mul(e.a,U),M),j=t.add(t.ONE,t.mul(e.d,t.mul(U,M)));return t.eql(V,j)}if(!v(e.Gx,e.Gy))throw new Error("bad curve params: generator point");let m=e.uvRatio||((z,I)=>{try{return{isValid:!0,value:t.sqrt(z*t.inv(I))}}catch{return{isValid:!1,value:Ke}}}),E=e.adjustScalarBytes||(z=>z),A=e.domain||((z,I,U)=>{if(yn("phflag",U),I.length||U)throw new Error("Contexts/pre-hash are not supported");return z});function S(z,I,U=!1){let M=U?Re:Ke;Nt("coordinate "+z,I,M,h)}function P(z){if(!(z instanceof x))throw new Error("ExtendedPoint expected")}let F=vr((z,I)=>{let{ex:U,ey:M,ez:V}=z,j=z.is0();I==null&&(I=j?aa:t.inv(V));let oe=d(U*I),le=d(M*I),ne=d(V*I);if(j)return{x:Ke,y:Re};if(ne!==Re)throw new Error("invZ was invalid");return{x:oe,y:le}}),se=vr(z=>{let{a:I,d:U}=e;if(z.is0())throw new Error("bad point: ZERO");let{ex:M,ey:V,ez:j,et:oe}=z,le=d(M*M),ne=d(V*V),de=d(j*j),ye=d(de*de),Se=d(le*I),ze=d(de*d(Se+ne)),Fe=d(ye+d(U*d(le*ne)));if(ze!==Fe)throw new Error("bad point: equation left != right (1)");let Te=d(M*V),et=d(j*oe);if(Te!==et)throw new Error("bad point: equation left != right (2)");return!0});class x{constructor(I,U,M,V){S("x",I),S("y",U),S("z",M,!0),S("t",V),this.ex=I,this.ey=U,this.ez=M,this.et=V,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(I){if(I instanceof x)throw new Error("extended point not allowed");let{x:U,y:M}=I||{};return S("x",U),S("y",M),new x(U,M,Re,d(U*M))}static normalizeZ(I){let U=Lr(t,I.map(M=>M.ez));return I.map((M,V)=>M.toAffine(U[V])).map(x.fromAffine)}static msm(I,U){return Gs(x,w,I,U)}_setWindowSize(I){G.setWindowSize(this,I)}assertValidity(){se(this)}equals(I){P(I);let{ex:U,ey:M,ez:V}=this,{ex:j,ey:oe,ez:le}=I,ne=d(U*le),de=d(j*V),ye=d(M*le),Se=d(oe*V);return ne===de&&ye===Se}is0(){return this.equals(x.ZERO)}negate(){return new x(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){let{a:I}=e,{ex:U,ey:M,ez:V}=this,j=d(U*U),oe=d(M*M),le=d(ho*d(V*V)),ne=d(I*j),de=U+M,ye=d(d(de*de)-j-oe),Se=ne+oe,ze=Se-le,Fe=ne-oe,Te=d(ye*ze),et=d(Se*Fe),lt=d(ye*Fe),_n=d(ze*Se);return new x(Te,et,_n,lt)}add(I){P(I);let{a:U,d:M}=e,{ex:V,ey:j,ez:oe,et:le}=this,{ex:ne,ey:de,ez:ye,et:Se}=I,ze=d(V*ne),Fe=d(j*de),Te=d(le*M*Se),et=d(oe*ye),lt=d((V+j)*(ne+de)-ze-Fe),_n=et-Te,xs=et+Te,Bs=d(Fe-U*ze),na=d(lt*_n),ra=d(xs*Bs),sa=d(lt*Bs),oa=d(_n*xs);return new x(na,ra,oa,sa)}subtract(I){return this.add(I.negate())}wNAF(I){return G.wNAFCached(this,I,x.normalizeZ)}multiply(I){let U=I;Nt("scalar",U,Re,n);let{p:M,f:V}=this.wNAF(U);return x.normalizeZ([M,V])[0]}multiplyUnsafe(I,U=x.ZERO){let M=I;return Nt("scalar",M,Ke,n),M===Ke?ce:this.is0()||M===Re?this:G.wNAFCachedUnsafe(this,M,x.normalizeZ,U)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return G.unsafeLadder(this,n).is0()}toAffine(I){return F(this,I)}clearCofactor(){let{h:I}=e;return I===Re?this:this.multiplyUnsafe(I)}static fromHex(I,U=!1){let{d:M,a:V}=e,j=t.BYTES;I=We("pointHex",I,j),yn("zip215",U);let oe=I.slice(),le=I[j-1];oe[j-1]=le&-129;let ne=mn(oe),de=U?h:t.ORDER;Nt("pointHex.y",ne,Ke,de);let ye=d(ne*ne),Se=d(ye-Re),ze=d(M*ye-V),{isValid:Fe,value:Te}=m(Se,ze);if(!Fe)throw new Error("Point.fromHex: invalid y coordinate");let et=(Te&Re)===Re,lt=(le&128)!==0;if(!U&&Te===Ke&&lt)throw new Error("Point.fromHex: x=0 and x_0=1");return lt!==et&&(Te=d(-Te)),x.fromAffine({x:Te,y:ne})}static fromPrivateKey(I){let{scalar:U}=Ps(I);return ae.multiply(U)}toRawBytes(){let{x:I,y:U}=this.toAffine(),M=Tr(U,t.BYTES);return M[M.length-1]|=I&Re?128:0,M}toHex(){return $s(this.toRawBytes())}}x.BASE=new x(e.Gx,e.Gy,Re,d(e.Gx*e.Gy)),x.ZERO=new x(Ke,Re,Re,Ke);let{BASE:ae,ZERO:ce}=x,G=qs(x,a*8);function _e(z){return Pe(z,n)}function It(z){return _e(mn(z))}function Ps(z){let I=t.BYTES;z=We("private key",z,I);let U=We("hashed private key",o(z),2*I),M=E(U.slice(0,I)),V=U.slice(I,2*I),j=It(M);return{head:M,prefix:V,scalar:j}}function br(z){let{head:I,prefix:U,scalar:M}=Ps(z),V=ae.multiply(M),j=V.toRawBytes();return{head:I,prefix:U,scalar:M,point:V,pointBytes:j}}function Zi(z){return br(z).pointBytes}function Ir(z=Uint8Array.of(),...I){let U=kr(...I);return It(o(A(U,We("context",z),!!r)))}function Qi(z,I,U={}){z=We("message",z),r&&(z=r(z));let{prefix:M,scalar:V,pointBytes:j}=br(I),oe=Ir(U.context,M,z),le=ae.multiply(oe).toRawBytes(),ne=Ir(U.context,le,j,z),de=_e(oe+ne*V);Nt("signature.s",de,Ke,n);let ye=kr(le,Tr(de,t.BYTES));return We("result",ye,t.BYTES*2)}let ea=ca;function ta(z,I,U,M=ea){let{context:V,zip215:j}=M,oe=t.BYTES;z=We("signature",z,2*oe),I=We("message",I),U=We("publicKey",U,oe),j!==void 0&&yn("zip215",j),r&&(I=r(I));let le=mn(z.slice(oe,2*oe)),ne,de,ye;try{ne=x.fromHex(U,j),de=x.fromHex(z.slice(0,oe),j),ye=ae.multiplyUnsafe(le)}catch{return!1}if(!j&&ne.isSmallOrder())return!1;let Se=Ir(V,de.toRawBytes(),ne.toRawBytes(),I);return de.add(ne.multiplyUnsafe(Se)).subtract(ye).clearCofactor().equals(x.ZERO)}return ae._setWindowSize(8),{CURVE:e,getPublicKey:Zi,sign:Qi,verify:ta,ExtendedPoint:x,utils:{getExtendedPublicKey:br,randomPrivateKey:()=>i(t.BYTES),precompute(z=8,I=x.BASE){return I._setWindowSize(z),I.multiply(BigInt(3)),I}}}}var Dr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),po=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Lp=BigInt(0),da=BigInt(1),go=BigInt(2),Pp=BigInt(3),la=BigInt(5),ha=BigInt(8);function fa(s){let e=BigInt(10),t=BigInt(20),n=BigInt(40),r=BigInt(80),o=Dr,a=s*s%o*s%o,c=xe(a,go,o)*a%o,h=xe(c,da,o)*s%o,d=xe(h,la,o)*h%o,w=xe(d,e,o)*d%o,v=xe(w,t,o)*w%o,m=xe(v,n,o)*v%o,E=xe(m,r,o)*m%o,A=xe(E,r,o)*m%o,S=xe(A,e,o)*d%o;return{pow_p_5_8:xe(S,go,o)*s%o,b2:a}}function pa(s){return s[0]&=248,s[31]&=127,s[31]|=64,s}function ga(s,e){let t=Dr,n=Pe(e*e*e,t),r=Pe(n*n*e,t),o=fa(s*r).pow_p_5_8,i=Pe(s*n*o,t),a=Pe(e*i*i,t),c=i,h=Pe(i*po,t),d=a===s,w=a===Pe(-s,t),v=a===Pe(-s*po,t);return d&&(i=c),(w||v)&&(i=h),Hs(i,t)&&(i=Pe(-i,t)),{isValid:d||w,value:i}}var _o=An(Dr,void 0,!0),_a={a:_o.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:_o,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:ha,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ks,randomBytes:Ws,adjustScalarBytes:pa,uvRatio:ga},ft=fo(_a);var ls=tt(eo()),he=tt(Ro());var Dt=tt(ko()),u=tt(qr()),Ai=tt(qr());p();_();g();p();_();g();var za=1,Fa=2,Wa=3,Ka=4,$a=5,Va=6,Ha=7,qa=8,Ga=9,ja=10,Ya=-32700,Xa=-32603,Ja=-32602,Za=-32601,Qa=-32600,ec=-32016,tc=-32015,nc=-32014,rc=-32013,sc=-32012,oc=-32011,ic=-32010,ac=-32009,cc=-32008,uc=-32007,dc=-32006,lc=-32005,hc=-32004,fc=-32003,pc=-32002,gc=-32001,_c=28e5,yc=2800001,mc=2800002,Ac=2800003,Rc=2800004,Ec=2800005,wc=2800006,Sc=2800007,bc=2800008,Ic=2800009,Nc=2800010,Cc=323e4,Oc=32300001,Tc=3230002,kc=3230003,vc=3230004,Lc=361e4,Pc=3610001,xc=3610002,Bc=3610003,Uc=3610004,Dc=3610005,Mc=3610006,zc=3610007,Fc=3611e3,Wc=3704e3,Kc=3704001,$c=3704002,Vc=3704003,Hc=3704004,qc=4128e3,Gc=4128001,jc=4128002,Yc=4615e3,Xc=4615001,Jc=4615002,Zc=4615003,Qc=4615004,eu=4615005,tu=4615006,nu=4615007,ru=4615008,su=4615009,ou=4615010,iu=4615011,au=4615012,cu=4615013,uu=4615014,du=4615015,lu=4615016,hu=4615017,fu=4615018,pu=4615019,gu=4615020,_u=4615021,yu=4615022,mu=4615023,Au=4615024,Ru=4615025,Eu=4615026,wu=4615027,Su=4615028,bu=4615029,Iu=4615030,Nu=4615031,Cu=4615032,Ou=4615033,Tu=4615034,ku=4615035,vu=4615036,Lu=4615037,Pu=4615038,xu=4615039,Bu=4615040,Uu=4615041,Du=4615042,Mu=4615043,zu=4615044,Fu=4615045,Wu=4615046,Ku=4615047,$u=4615048,Vu=4615049,Hu=4615050,qu=4615051,Gu=4615052,ju=4615053,Yu=4615054,Xu=5508e3,Ju=5508001,Zu=5508002,Qu=5508003,ed=5508004,td=5508005,nd=5508006,rd=5508007,sd=5508008,od=5508009,id=5508010,ad=5508011,cd=5663e3,ud=5663001,dd=5663002,ld=5663003,hd=5663004,fd=5663005,pd=5663006,gd=5663007,_d=5663008,yd=5663009,md=5663010,Ad=5663011,Rd=5663012,Ed=5663013,wd=5663014,Sd=5663015,bd=5663016,Id=5663017,Nd=5663018,Cd=5663019,Od=705e4,Td=7050001,kd=7050002,vd=7050003,Ld=7050004,Pd=7050005,xd=7050006,Bd=7050007,Ud=7050008,Dd=7050009,Md=7050010,zd=7050011,Fd=7050012,Wd=7050013,Kd=7050014,$d=7050015,Vd=7050016,Hd=7050017,qd=7050018,Gd=7050019,jd=7050020,Yd=7050021,Xd=7050022,Jd=7050023,Zd=7050024,Qd=7050025,el=7050026,tl=7050027,nl=7050028,rl=7050029,sl=7050030,ol=7050031,il=7050032,al=7050033,cl=7050034,ul=7050035,dl=7050036,Gr=8078e3,jr=8078001,vo=8078002,Lo=8078003,Yr=8078004,Xr=8078005,Jr=8078006,ll=8078007,hl=8078008,fl=8078009,pl=8078010,Zr=8078011,gl=8078012,Po=8078013,xo=8078014,_l=8078015,yl=8078016,ml=8078017,Al=8078018,Rl=8078019,Bo=8078020,Uo=8078021,El=8078022,wl=81e5,Sl=8100001,bl=8100002,Il=8100003,Nl=819e4,Cl=8190001,Ol=8190002,Tl=8190003,kl=8190004,vl=99e5,Ll=9900001,Pl=9900002,xl=9900003,Bl=9900004;function Do(s){return Array.isArray(s)?"%5B"+s.map(Do).join("%2C%20")+"%5D":typeof s=="bigint"?`${s}n`:encodeURIComponent(String(s!=null&&Object.getPrototypeOf(s)===null?{...s}:s))}function Ul([s,e]){return`${s}=${Do(e)}`}function Dl(s){let e=Object.entries(s).map(Ul).join("&");return btoa(e)}var hg={[Cc]:"Account not found at address: $address",[vc]:"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",[kc]:"Expected decoded account at address: $address",[Tc]:"Failed to decode account data at address: $address",[Oc]:"Accounts not found at addresses: $addresses",[Ic]:"Unable to find a viable program address bump seed.",[mc]:"$putativeAddress is not a base58-encoded address.",[_c]:"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",[Ac]:"The `CryptoKey` must be an `Ed25519` public key.",[bc]:"Invalid seeds; point must fall off the Ed25519 curve.",[Rc]:"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",[wc]:"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",[Sc]:"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",[Ec]:"Expected program derived address bump to be in the range [0, 255], got: $bump.",[Nc]:"Program address cannot end with PDA marker.",[yc]:"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",[Ka]:"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",[za]:"The network has progressed past the last block for which this transaction could have been committed.",[Gr]:"Codec [$codecDescription] cannot decode empty byte arrays.",[El]:"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",[Bo]:"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",[Xr]:"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",[Jr]:"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",[Yr]:"Encoder and decoder must either both be fixed-size or variable-size.",[hl]:"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",[vo]:"Expected a fixed-size codec, got a variable-size one.",[Po]:"Codec [$codecDescription] expected a positive byte length, got $bytesLength.",[Lo]:"Expected a variable-size codec, got a fixed-size one.",[Rl]:"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",[jr]:"Codec [$codecDescription] expected $expected bytes, got $bytesLength.",[Al]:"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",[fl]:"Invalid discriminated union variant. Expected one of [$variants], got $value.",[pl]:"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",[_l]:"Invalid literal union variant. Expected one of [$variants], got $value.",[ll]:"Expected [$codecDescription] to have $expected items, got $actual.",[gl]:"Invalid value $value for base $base with alphabet $alphabet.",[yl]:"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",[Zr]:"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",[xo]:"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",[Uo]:"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",[ml]:"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",[Fc]:"No random values implementation could be found.",[su]:"instruction requires an uninitialized account",[mu]:"instruction tries to borrow reference for an account which is already borrowed",[Au]:"instruction left account with an outstanding borrowed reference",[_u]:"program other than the account's owner changed the size of the account data",[eu]:"account data too small for instruction",[yu]:"instruction expected an executable account",[Wu]:"An account does not have enough lamports to be rent-exempt",[$u]:"Program arithmetic overflowed",[Fu]:"Failed to serialize or deserialize account data: $encodedData",[Yu]:"Builtin programs must consume compute units",[Cu]:"Cross-program invocation call depth too deep",[Pu]:"Computational budget exceeded",[Eu]:"custom program error: #$code",[hu]:"instruction contains duplicate accounts",[Ru]:"instruction modifications of multiply-passed account differ",[Iu]:"executable accounts must be rent exempt",[Su]:"instruction changed executable accounts data",[bu]:"instruction changed the balance of an executable account",[fu]:"instruction changed executable bit of an account",[uu]:"instruction modified data of an account it does not own",[cu]:"instruction spent from the balance of an account it does not own",[Xc]:"generic instruction error",[Hu]:"Provided owner is not allowed",[Mu]:"Account is immutable",[zu]:"Incorrect authority provided",[nu]:"incorrect program id for instruction",[tu]:"insufficient funds for instruction",[Qc]:"invalid account data for instruction",[Ku]:"Invalid account owner",[Jc]:"invalid program argument",[wu]:"program returned invalid error code",[Zc]:"invalid instruction data",[Lu]:"Failed to reallocate account data",[vu]:"Provided seeds do not result in a valid address",[qu]:"Accounts data allocations exceeded the maximum allowed per transaction",[Gu]:"Max accounts exceeded",[ju]:"Max instruction trace length exceeded",[ku]:"Length of the seed is too long for address generation",[Ou]:"An account required by the instruction is missing",[ru]:"missing required signature for instruction",[au]:"instruction illegally modified the program id of an account",[gu]:"insufficient account keys for instruction",[xu]:"Cross-program invocation with unauthorized signer or writable account",[Bu]:"Failed to create program execution environment",[Du]:"Program failed to compile",[Uu]:"Program failed to complete",[lu]:"instruction modified data of a read-only account",[du]:"instruction changed the balance of a read-only account",[Tu]:"Cross-program invocation reentrancy not allowed for this instruction",[pu]:"instruction modified rent epoch of an account",[iu]:"sum of account balances before and after instruction do not match",[ou]:"instruction requires an initialized account",[Yc]:"",[Nu]:"Unsupported program id",[Vu]:"Unsupported sysvar",[qc]:"The instruction does not have any accounts.",[Gc]:"The instruction does not have any data.",[jc]:"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",[$a]:"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",[Fa]:"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",[Pl]:"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Bl]:"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",[Ll]:"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[vl]:"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[xl]:"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Xa]:"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",[Ja]:"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",[Qa]:"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",[Za]:"JSON-RPC error: The method does not exist / is not available ($__serverMessage)",[Ya]:"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",[sc]:"$__serverMessage",[gc]:"$__serverMessage",[hc]:"$__serverMessage",[nc]:"$__serverMessage",[ic]:"$__serverMessage",[ac]:"$__serverMessage",[ec]:"Minimum context slot has not been reached",[lc]:"Node is unhealthy; behind by $numSlotsBehind slots",[cc]:"No snapshot",[pc]:"Transaction simulation failed",[uc]:"$__serverMessage",[oc]:"Transaction history is not available from this node",[dc]:"$__serverMessage",[rc]:"Transaction signature length mismatch",[fc]:"Transaction signature verification failure",[tc]:"$__serverMessage",[Wc]:"Key pair bytes must be of length 64, got $byteLength.",[Kc]:"Expected private key bytes with length 32. Actual length: $actualLength.",[$c]:"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",[Hc]:"The provided private key does not match the provided public key.",[Vc]:"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",[Va]:"Lamports value must be in the range [0, 2e64-1]",[Ha]:"`$value` cannot be parsed as a `BigInt`",[ja]:"$message",[qa]:"`$value` cannot be parsed as a `Number`",[Wa]:"No nonce account could be found at address `$nonceAccountAddress`",[Nl]:"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",[Ol]:"WebSocket was closed before payload could be added to the send buffer",[Tl]:"WebSocket connection closed",[kl]:"WebSocket failed to connect",[Cl]:"Failed to obtain a subscription id from the server",[Il]:"Could not find an API plan for RPC method: `$method`",[wl]:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",[bl]:"HTTP error ($statusCode): $message",[Sl]:"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",[Xu]:"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",[Ju]:"The provided value does not implement the `KeyPairSigner` interface",[Qu]:"The provided value does not implement the `MessageModifyingSigner` interface",[ed]:"The provided value does not implement the `MessagePartialSigner` interface",[Zu]:"The provided value does not implement any of the `MessageSigner` interfaces",[nd]:"The provided value does not implement the `TransactionModifyingSigner` interface",[rd]:"The provided value does not implement the `TransactionPartialSigner` interface",[sd]:"The provided value does not implement the `TransactionSendingSigner` interface",[td]:"The provided value does not implement any of the `TransactionSigner` interfaces",[od]:"More than one `TransactionSendingSigner` was identified.",[id]:"No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",[ad]:"Wallet account signers do not support signing multiple messages/transactions in a single operation",[zc]:"Cannot export a non-extractable key.",[Pc]:"No digest implementation could be found.",[Lc]:"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",[xc]:`This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,[Bc]:"No signature verification implementation could be found.",[Uc]:"No key generation implementation could be found.",[Dc]:"No signing implementation could be found.",[Mc]:"No key export implementation could be found.",[Ga]:"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",[Vd]:"Transaction processing left an account with an outstanding borrowed reference",[Td]:"Account in use",[kd]:"Account loaded twice",[vd]:"Attempt to debit an account but found no record of a prior credit.",[Jd]:"Transaction loads an address table account that doesn't exist",[Bd]:"This transaction has already been processed",[Ud]:"Blockhash not found",[Dd]:"Loader call chain is too deep",[$d]:"Transactions are currently disabled due to cluster maintenance",[sl]:"Transaction contains a duplicate instruction ($index) that is not allowed",[Pd]:"Insufficient funds for fee",[ol]:"Transaction results in an account ($accountIndex) with insufficient funds for rent",[xd]:"This account may not be used to pay transaction fees",[zd]:"Transaction contains an invalid account reference",[Qd]:"Transaction loads an address table account with invalid data",[el]:"Transaction address table lookup uses an invalid index",[Zd]:"Transaction loads an address table account with an invalid owner",[al]:"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",[Wd]:"This program may not be used for executing instructions",[tl]:"Transaction leaves an account with a lower balance than rent-exempt minimum",[Gd]:"Transaction loads a writable account that cannot be written",[il]:"Transaction exceeded max loaded accounts data size cap",[Md]:"Transaction requires a fee but has no signature present",[Ld]:"Attempt to load a program that does not exist",[ul]:"Execution of the program referenced by account at index $accountIndex is temporarily restricted.",[cl]:"ResanitizationNeeded",[Kd]:"Transaction failed to sanitize accounts offsets correctly",[Fd]:"Transaction did not pass signature verification",[Xd]:"Transaction locked too many accounts",[dl]:"Sum of account balances before and after transaction do not match",[Od]:"The transaction failed with the error `$errorName`",[qd]:"Transaction version is unsupported",[Yd]:"Transaction would exceed account data limit within the block",[rl]:"Transaction would exceed total account data limit",[jd]:"Transaction would exceed max account limit within the block",[Hd]:"Transaction would exceed max Block Cost Limit",[nl]:"Transaction would exceed max Vote Cost Limit",[Sd]:"Attempted to sign a transaction with an address that is not a signer for it",[md]:"Transaction is missing an address at index: $index.",[bd]:"Transaction has no expected signers therefore it cannot be encoded",[dd]:"Transaction does not have a blockhash lifetime",[ld]:"Transaction is not a durable nonce transaction",[fd]:"Contents of these address lookup tables unknown: $lookupTableAddresses",[pd]:"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",[_d]:"No fee payer set in CompiledTransaction",[gd]:"Could not find program address at index $index",[Nd]:"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",[Cd]:"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",[Ad]:"Transaction is missing a fee payer.",[Rd]:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",[wd]:"Transaction first instruction is not advance nonce account instruction.",[Ed]:"Transaction with no instructions cannot be durable nonce transaction.",[cd]:"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",[ud]:"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",[Id]:"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",[yd]:"Transaction is missing signatures for addresses: $addresses.",[hd]:"Transaction version must be in the range [0, 127]. `$actualVersion` given"};function Ml(s,e={}){{let t=`Solana error #${s}; Decode this error by running \`npx @solana/errors decode -- ${s}`;return Object.keys(e).length&&(t+=` '${Dl(e)}'`),`${t}\``}}var st=class extends Error{cause=this.cause;context;constructor(...[s,e]){let t,n;if(e){let{cause:o,...i}=e;o&&(n={cause:o}),Object.keys(i).length>0&&(t=i)}let r=Ml(s,t);super(r,n),this.context={__code:s,...t},this.name="SolanaError"}};p();_();g();function zl(s,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(s)}function Mo(s){return Object.freeze({...s,encode:e=>{let t=new Uint8Array(zl(e,s));return s.write(e,t,0),t}})}function zo(s){return Object.freeze({...s,decode:(e,t=0)=>s.read(e,t)[0]})}function vt(s){return"fixedSize"in s&&typeof s.fixedSize=="number"}function Fo(s,e){if(vt(s)!==vt(e))throw new st(Yr);if(vt(s)&&vt(e)&&s.fixedSize!==e.fixedSize)throw new st(Xr,{decoderFixedSize:e.fixedSize,encoderFixedSize:s.fixedSize});if(!vt(s)&&!vt(e)&&s.maxSize!==e.maxSize)throw new st(Jr,{decoderMaxSize:e.maxSize,encoderMaxSize:s.maxSize});return{...e,...s,decode:e.decode,encode:s.encode,read:e.read,write:s.write}}function Wo(s,e,t=0){if(e.length-t<=0)throw new st(Gr,{codecDescription:s})}function Ko(s,e,t,n=0){let r=t.length-n;if(r<e)throw new st(jr,{bytesLength:r,codecDescription:s,expected:e})}function Fl(s,e,t,n){if(n<e||n>t)throw new st(Zr,{codecDescription:s,max:t,min:e,value:n})}function $o(s){return s?.endian!==1}function Wl(s){return Mo({fixedSize:s.size,write(e,t,n){s.range&&Fl(s.name,s.range[0],s.range[1],e);let r=new ArrayBuffer(s.size);return s.set(new DataView(r),e,$o(s.config)),t.set(new Uint8Array(r),n),n+s.size}})}function Kl(s){return zo({fixedSize:s.size,read(e,t=0){Wo(s.name,e,t),Ko(s.name,s.size,e,t);let n=new DataView($l(e,t,s.size));return[s.get(n,$o(s.config)),t+s.size]}})}function $l(s,e,t){let n=s.byteOffset+(e??0),r=t??s.byteLength;return s.buffer.slice(n,n+r)}var Qr=(s={})=>Wl({config:s,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),Vl=(s={})=>Kl({config:s,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),Vo=(s={})=>Fo(Qr(s),Vl(s));p();_();g();var es=class extends TypeError{constructor(e,t){let n,{message:r,explanation:o,...i}=e,{path:a}=e,c=a.length===0?r:`At path: ${a.join(".")} -- ${r}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}};function Hl(s){return Yt(s)&&typeof s[Symbol.iterator]=="function"}function Yt(s){return typeof s=="object"&&s!=null}function Yn(s){return Yt(s)&&!Array.isArray(s)}function Be(s){return typeof s=="symbol"?s.toString():typeof s=="string"?JSON.stringify(s):`${s}`}function ql(s){let{done:e,value:t}=s.next();return e?void 0:t}function Gl(s,e,t,n){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});let{path:r,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${Be(n)}\``}=s;return{value:n,type:i,refinement:a,key:r[r.length-1],path:r,branch:o,...s,message:c}}function*Ho(s,e,t,n){Hl(s)||(s=[s]);for(let r of s){let o=Gl(r,e,t,n);o&&(yield o)}}function*ts(s,e,t={}){let{path:n=[],branch:r=[s],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:r,mask:i};o&&(s=e.coercer(s,a));let c="valid";for(let h of e.validator(s,a))h.explanation=t.message,c="not_valid",yield[h,void 0];for(let[h,d,w]of e.entries(s,a)){let v=ts(d,w,{path:h===void 0?n:[...n,h],branch:h===void 0?r:[...r,d],coerce:o,mask:i,message:t.message});for(let m of v)m[0]?(c=m[0].refinement!=null?"not_refined":"not_valid",yield[m[0],void 0]):o&&(d=m[1],h===void 0?s=d:s instanceof Map?s.set(h,d):s instanceof Set?s.add(d):Yt(s)&&(d!==void 0||h in s)&&(s[h]=d))}if(c!=="not_valid")for(let h of e.refiner(s,a))h.explanation=t.message,c="not_refined",yield[h,void 0];c==="valid"&&(yield[void 0,s])}var ve=class{constructor(e){let{type:t,schema:n,validator:r,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,r?this.validator=(c,h)=>{let d=r(c,h);return Ho(d,h,this,c)}:this.validator=()=>[],o?this.refiner=(c,h)=>{let d=o(c,h);return Ho(d,h,this,c)}:this.refiner=()=>[]}assert(e,t){return qo(e,this,t)}create(e,t){return N(e,this,t)}is(e){return Go(e,this)}mask(e,t){return jl(e,this,t)}validate(e,t={}){return Xt(e,this,t)}};function qo(s,e,t){let n=Xt(s,e,{message:t});if(n[0])throw n[0]}function N(s,e,t){let n=Xt(s,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function jl(s,e,t){let n=Xt(s,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Go(s,e){return!Xt(s,e)[0]}function Xt(s,e,t={}){let n=ts(s,e,t),r=ql(n);return r[0]?[new es(r[0],function*(){for(let i of n)i[0]&&(yield i[0])}),void 0]:[void 0,r[1]]}function _t(s,e){return new ve({type:s,schema:null,validator:e})}function jo(){return _t("any",()=>!0)}function C(s){return new ve({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(let[t,n]of e.entries())yield[t,n,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${Be(e)}`}})}function Ue(){return _t("boolean",s=>typeof s=="boolean")}function Xn(s){return _t("instance",e=>e instanceof s||`Expected a \`${s.name}\` instance, but received: ${Be(e)}`)}function re(s){let e=Be(s),t=typeof s;return new ve({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?s:null,validator(n){return n===s||`Expected the literal \`${e}\`, but received: ${Be(n)}`}})}function Yl(){return _t("never",()=>!1)}function O(s){return new ve({...s,validator:(e,t)=>e===null||s.validator(e,t),refiner:(e,t)=>e===null||s.refiner(e,t)})}function l(){return _t("number",s=>typeof s=="number"&&!isNaN(s)||`Expected a number, but received: ${Be(s)}`)}function D(s){return new ve({...s,validator:(e,t)=>e===void 0||s.validator(e,t),refiner:(e,t)=>e===void 0||s.refiner(e,t)})}function ns(s,e){return new ve({type:"record",schema:null,*entries(t){if(Yt(t))for(let n in t){let r=t[n];yield[n,n,s],yield[n,r,e]}},validator(t){return Yn(t)||`Expected an object, but received: ${Be(t)}`},coercer(t){return Yn(t)?{...t}:t}})}function b(){return _t("string",s=>typeof s=="string"||`Expected a string, but received: ${Be(s)}`)}function Jn(s){let e=Yl();return new ve({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){let n=Math.max(s.length,t.length);for(let r=0;r<n;r++)yield[r,t[r],s[r]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Be(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function R(s){let e=Object.keys(s);return new ve({type:"type",schema:s,*entries(t){if(Yt(t))for(let n of e)yield[n,t[n],s[n]]},validator(t){return Yn(t)||`Expected an object, but received: ${Be(t)}`},coercer(t){return Yn(t)?{...t}:t}})}function Ae(s){let e=s.map(t=>t.type).join(" | ");return new ve({type:"union",schema:null,coercer(t,n){for(let r of s){let[o,i]=r.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){let r=[];for(let o of s){let[...i]=ts(t,o,n),[a]=i;if(a[0])for(let[c]of i)c&&r.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${Be(t)}`,...r]}})}function yt(){return _t("unknown",()=>!0)}function Lt(s,e,t){return new ve({...s,coercer:(n,r)=>Go(n,e)?s.coercer(t(n,r),r):s.coercer(n,r)})}var Ri=tt(Zo());p();_();g();Cr();var eh=class extends Ur.default{socket;constructor(s,e,t){super(),this.socket=new window.WebSocket(s,t),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=n=>this.emit("message",n.data),this.socket.onerror=n=>this.emit("error",n),this.socket.onclose=n=>{this.emit("close",n.code,n.reason)}}send(s,e,t){let n=t||e;try{this.socket.send(s),n()}catch(r){n(r)}}close(s,e){this.socket.close(s,e)}addEventListener(s,e,t){this.socket.addEventListener(s,e,t)}};function Qo(s,e){return new eh(s,e)}var th=class{encode(s){return JSON.stringify(s)}decode(s){return JSON.parse(s)}},ei=class extends Ur.default{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(s,e="ws://localhost:8080",{autoconnect:t=!0,reconnect:n=!0,reconnect_interval:r=1e3,max_reconnects:o=5,...i}={},a,c){super(),this.webSocketFactory=s,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=t,this.ready=!1,this.reconnect=n,this.reconnect_timer_id=void 0,this.reconnect_interval=r,this.max_reconnects=o,this.rest_options=i,this.current_reconnects=0,this.generate_request_id=a||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),c?this.dataPack=c:this.dataPack=new th,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(s,e,t,n){return!n&&typeof t=="object"&&(n=t,t=null),new Promise((r,o)=>{if(!this.ready)return o(new Error("socket not ready"));let i=this.generate_request_id(s,e),a={jsonrpc:"2.0",method:s,params:e||void 0,id:i};this.socket.send(this.dataPack.encode(a),n,c=>{if(c)return o(c);this.queue[i]={promise:[r,o]},t&&(this.queue[i].timeout=setTimeout(()=>{delete this.queue[i],o(new Error("reply timeout"))},t))})})}async login(s){let e=await this.call("rpc.login",s);if(!e)throw new Error("authentication failed");return e}async listMethods(){return await this.call("__listMethods")}notify(s,e){return new Promise((t,n)=>{if(!this.ready)return n(new Error("socket not ready"));let r={jsonrpc:"2.0",method:s,params:e};this.socket.send(this.dataPack.encode(r),o=>{if(o)return n(o);t()})})}async subscribe(s){typeof s=="string"&&(s=[s]);let e=await this.call("rpc.on",s);if(typeof s=="string"&&e[s]!=="ok")throw new Error("Failed subscribing to an event '"+s+"' with: "+e[s]);return e}async unsubscribe(s){typeof s=="string"&&(s=[s]);let e=await this.call("rpc.off",s);if(typeof s=="string"&&e[s]!=="ok")throw new Error("Failed unsubscribing from an event with: "+e);return e}close(s,e){this.socket.close(s||1e3,e)}setAutoReconnect(s){this.reconnect=s}setReconnectInterval(s){this.reconnect_interval=s}setMaxReconnects(s){this.max_reconnects=s}_connect(s,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(s,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:t})=>{t instanceof ArrayBuffer&&(t=y.from(t).toString());try{t=this.dataPack.decode(t)}catch{return}if(t.notification&&this.listeners(t.notification).length){if(!Object.keys(t.params).length)return this.emit(t.notification);let n=[t.notification];if(t.params.constructor===Object)n.push(t.params);else for(let r=0;r<t.params.length;r++)n.push(t.params[r]);return Promise.resolve().then(()=>{this.emit.apply(this,n)})}if(!this.queue[t.id])return t.method?Promise.resolve().then(()=>{this.emit(t.method,t?.params)}):void 0;"error"in t=="result"in t&&this.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[t.id].timeout&&clearTimeout(this.queue[t.id].timeout),t.error?this.queue[t.id].promise[1](t.error):this.queue[t.id].promise[0](t.result),delete this.queue[t.id]}),this.socket.addEventListener("error",t=>this.emit("error",t)),this.socket.addEventListener("close",({code:t,reason:n})=>{this.ready&&setTimeout(()=>this.emit("close",t,n),0),this.ready=!1,this.socket=void 0,t!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(s,e),this.reconnect_interval)))})}};var s_=ft.utils.randomPrivateKey,ti=()=>{let s=ft.utils.randomPrivateKey(),e=hs(s),t=new Uint8Array(64);return t.set(s),t.set(e,32),{publicKey:e,secretKey:t}},hs=ft.getPublicKey;function ni(s){try{return ft.ExtendedPoint.fromHex(s),!0}catch{return!1}}var Is=(s,e)=>ft.sign(s,e.slice(0,32)),nh=ft.verify,H=s=>y.isBuffer(s)?s:s instanceof Uint8Array?y.from(s.buffer,s.byteOffset,s.byteLength):y.from(s),fs=class{constructor(e){Object.assign(this,e)}encode(){return y.from((0,Dt.serialize)(er,this))}static decode(e){return(0,Dt.deserialize)(er,this,e)}static decodeUnchecked(e){return(0,Dt.deserializeUnchecked)(er,this,e)}};var er=new Map,Ei,rh=32,at=32;function sh(s){return s._bn!==void 0}var ri=1,L=class s extends fs{constructor(e){if(super({}),this._bn=void 0,sh(e))this._bn=e._bn;else{if(typeof e=="string"){let t=he.default.decode(e);if(t.length!=at)throw new Error("Invalid public key input");this._bn=new ls.default(t)}else this._bn=new ls.default(e);if(this._bn.byteLength()>at)throw new Error("Invalid public key input")}}static unique(){let e=new s(ri);return ri+=1,new s(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return he.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){let e=this._bn.toArrayLike(y);if(e.length===at)return e;let t=y.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){let r=y.concat([e.toBuffer(),y.from(t),n.toBuffer()]),o=Pr(r);return new s(o)}static createProgramAddressSync(e,t){let n=y.alloc(0);e.forEach(function(o){if(o.length>rh)throw new TypeError("Max seed length exceeded");n=y.concat([n,H(o)])}),n=y.concat([n,t.toBuffer(),y.from("ProgramDerivedAddress")]);let r=Pr(n);if(ni(r))throw new Error("Invalid seeds, address must fall off the curve");return new s(r)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,r;for(;n!=0;){try{let o=e.concat(y.from([n]));r=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){let t=new s(e);return ni(t.toBytes())}};Ei=L;L.default=new Ei("11111111111111111111111111111111");er.set(L,{kind:"struct",fields:[["_bn","u256"]]});var o_=new L("BPFLoader1111111111111111111111111111111111"),Rt=1232,Ns=127,tr=64,nr=class extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}};Object.defineProperty(nr.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});var rr=class extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}};Object.defineProperty(rr.prototype,"name",{value:"TransactionExpiredTimeoutError"});var At=class extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}};Object.defineProperty(At.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});var xt=class{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){let e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(let t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");let n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});let r=o=>{let i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:r(o.programId),accountKeyIndexes:o.keys.map(i=>r(i.pubkey)),data:o.data}))}},$=(s="publicKey")=>u.blob(32,s),oh=(s="signature")=>u.blob(64,s),Pt=(s="string")=>{let e=u.struct([u.u32("length"),u.u32("lengthPadding"),u.blob(u.offset(u.u32(),-8),"chars")],s),t=e.decode.bind(e),n=e.encode.bind(e),r=e;return r.decode=(o,i)=>t(o,i).chars.toString(),r.encode=(o,i,a)=>{let c={chars:y.from(o,"utf8")};return n(c,i,a)},r.alloc=o=>u.u32().span+u.u32().span+y.from(o,"utf8").length,r},ih=(s="authorized")=>u.struct([$("staker"),$("withdrawer")],s),ah=(s="lockup")=>u.struct([u.ns64("unixTimestamp"),u.ns64("epoch"),$("custodian")],s),ch=(s="voteInit")=>u.struct([$("nodePubkey"),$("authorizedVoter"),$("authorizedWithdrawer"),u.u8("commission")],s),uh=(s="voteAuthorizeWithSeedArgs")=>u.struct([u.u32("voteAuthorizationType"),$("currentAuthorityDerivedKeyOwnerPubkey"),Pt("currentAuthorityDerivedKeySeed"),$("newAuthorized")],s);function wi(s,e){let t=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){let o=e[r.property];if(Array.isArray(o))return o.length*t(r.elementLayout)}else if("fields"in r)return wi({layout:r},e[r.property]);return 0},n=0;return s.layout.fields.forEach(r=>{n+=t(r)}),n}function Ie(s){let e=0,t=0;for(;;){let n=s.shift();if(e|=(n&127)<<t*7,t+=1,(n&128)===0)break}return e}function Ne(s,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){s.push(n);break}else n|=128,s.push(n)}}function J(s,e){if(!s)throw new Error(e||"Assertion failed")}var sr=class s{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){let n=new Map,r=i=>{let a=i.toBase58(),c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=r(t);o.isSigner=!0,o.isWritable=!0;for(let i of e){r(i.programId).isInvoked=!0;for(let a of i.keys){let c=r(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new s(t,n)}getMessageComponents(){let e=[...this.keyMetaMap.entries()];J(e.length<=256,"Max static account keys length exceeded");let t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),r=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{J(t.length>0,"Expected at least one writable signer key");let[c]=t[0];J(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}let a=[...t.map(([c])=>new L(c)),...n.map(([c])=>new L(c)),...r.map(([c])=>new L(c)),...o.map(([c])=>new L(c))];return[i,a]}extractTableLookup(e){let[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[r,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){let n=new Array,r=new Array;for(let[o,i]of this.keyMetaMap.entries())if(t(i)){let a=new L(o),c=e.findIndex(h=>h.equals(a));c>=0&&(J(c<256,"Max lookup table index exceeded"),n.push(c),r.push(a),this.keyMetaMap.delete(o))}return[n,r]}},Si="Reached end of buffer unexpectedly";function Ze(s){if(s.length===0)throw new Error(Si);return s.shift()}function Ce(s,...e){let[t]=e;if(e.length===2?t+(e[1]??0)>s.length:t>=s.length)throw new Error(Si);return s.splice(...e)}var ct=class s{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new L(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:he.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new xt(this.staticAccountKeys)}static compile(e){let t=sr.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),i=new xt(r).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:he.default.encode(a.data)}));return new s({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){let n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{let n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){let e=this.accountKeys.length,t=[];Ne(t,e);let n=this.instructions.map(w=>{let{accounts:v,programIdIndex:m}=w,E=Array.from(he.default.decode(w.data)),A=[];Ne(A,v.length);let S=[];return Ne(S,E.length),{programIdIndex:m,keyIndicesCount:y.from(A),keyIndices:v,dataLength:y.from(S),data:E}}),r=[];Ne(r,n.length);let o=y.alloc(Rt);y.from(r).copy(o);let i=r.length;n.forEach(w=>{let m=u.struct([u.u8("programIdIndex"),u.blob(w.keyIndicesCount.length,"keyIndicesCount"),u.seq(u.u8("keyIndex"),w.keyIndices.length,"keyIndices"),u.blob(w.dataLength.length,"dataLength"),u.seq(u.u8("userdatum"),w.data.length,"data")]).encode(w,o,i);i+=m}),o=o.slice(0,i);let a=u.struct([u.blob(1,"numRequiredSignatures"),u.blob(1,"numReadonlySignedAccounts"),u.blob(1,"numReadonlyUnsignedAccounts"),u.blob(t.length,"keyCount"),u.seq($("key"),e,"keys"),$("recentBlockhash")]),c={numRequiredSignatures:y.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:y.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:y.from([this.header.numReadonlyUnsignedAccounts]),keyCount:y.from(t),keys:this.accountKeys.map(w=>H(w.toBytes())),recentBlockhash:he.default.decode(this.recentBlockhash)},h=y.alloc(2048),d=a.encode(c,h);return o.copy(h,d),h.slice(0,d+o.length)}static from(e){let t=[...e],n=Ze(t);if(n!==(n&Ns))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let r=Ze(t),o=Ze(t),i=Ie(t),a=[];for(let v=0;v<i;v++){let m=Ce(t,0,at);a.push(new L(y.from(m)))}let c=Ce(t,0,at),h=Ie(t),d=[];for(let v=0;v<h;v++){let m=Ze(t),E=Ie(t),A=Ce(t,0,E),S=Ie(t),P=Ce(t,0,S),F=he.default.encode(y.from(P));d.push({programIdIndex:m,accounts:A,data:F})}let w={header:{numRequiredSignatures:n,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:o},recentBlockhash:he.default.encode(y.from(c)),accountKeys:a,instructions:d};return new s(w)}},or=class s{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(let t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new xt(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){let r=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return r<o}else if(e>=this.header.numRequiredSignatures){let r=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return r<i}else{let r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){let t={writable:[],readonly:[]};for(let n of this.addressTableLookups){let r=e.find(o=>o.key.equals(n.accountKey));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(let o of n.writableIndexes)if(o<r.state.addresses.length)t.writable.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(let o of n.readonlyIndexes)if(o<r.state.addresses.length)t.readonly.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){let t=sr.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(let d of o){let w=t.extractTableLookup(d);if(w!==void 0){let[v,{writable:m,readonly:E}]=w;n.push(v),r.writable.push(...m),r.readonly.push(...E)}}let[i,a]=t.getMessageComponents(),h=new xt(a,r).compileInstructions(e.instructions);return new s({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:h,addressTableLookups:n})}serialize(){let e=Array();Ne(e,this.staticAccountKeys.length);let t=this.serializeInstructions(),n=Array();Ne(n,this.compiledInstructions.length);let r=this.serializeAddressTableLookups(),o=Array();Ne(o,this.addressTableLookups.length);let i=u.struct([u.u8("prefix"),u.struct([u.u8("numRequiredSignatures"),u.u8("numReadonlySignedAccounts"),u.u8("numReadonlyUnsignedAccounts")],"header"),u.blob(e.length,"staticAccountKeysLength"),u.seq($(),this.staticAccountKeys.length,"staticAccountKeys"),$("recentBlockhash"),u.blob(n.length,"instructionsLength"),u.blob(t.length,"serializedInstructions"),u.blob(o.length,"addressTableLookupsLength"),u.blob(r.length,"serializedAddressTableLookups")]),a=new Uint8Array(Rt),h=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:he.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:r},a);return a.slice(0,h)}serializeInstructions(){let e=0,t=new Uint8Array(Rt);for(let n of this.compiledInstructions){let r=Array();Ne(r,n.accountKeyIndexes.length);let o=Array();Ne(o,n.data.length);let i=u.struct([u.u8("programIdIndex"),u.blob(r.length,"encodedAccountKeyIndexesLength"),u.seq(u.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),u.blob(o.length,"encodedDataLength"),u.blob(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0,t=new Uint8Array(Rt);for(let n of this.addressTableLookups){let r=Array();Ne(r,n.writableIndexes.length);let o=Array();Ne(o,n.readonlyIndexes.length);let i=u.struct([$("accountKey"),u.blob(r.length,"encodedWritableIndexesLength"),u.seq(u.u8(),n.writableIndexes.length,"writableIndexes"),u.blob(o.length,"encodedReadonlyIndexesLength"),u.seq(u.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e],n=Ze(t),r=n&Ns;J(n!==r,"Expected versioned message but received legacy message");let o=r;J(o===0,`Expected versioned message with version 0 but found version ${o}`);let i={numRequiredSignatures:Ze(t),numReadonlySignedAccounts:Ze(t),numReadonlyUnsignedAccounts:Ze(t)},a=[],c=Ie(t);for(let E=0;E<c;E++)a.push(new L(Ce(t,0,at)));let h=he.default.encode(Ce(t,0,at)),d=Ie(t),w=[];for(let E=0;E<d;E++){let A=Ze(t),S=Ie(t),P=Ce(t,0,S),F=Ie(t),se=new Uint8Array(Ce(t,0,F));w.push({programIdIndex:A,accountKeyIndexes:P,data:se})}let v=Ie(t),m=[];for(let E=0;E<v;E++){let A=new L(Ce(t,0,at)),S=Ie(t),P=Ce(t,0,S),F=Ie(t),se=Ce(t,0,F);m.push({accountKey:A,writableIndexes:P,readonlyIndexes:se})}return new s({header:i,staticAccountKeys:a,recentBlockhash:h,compiledInstructions:w,addressTableLookups:m})}},bi={deserializeMessageVersion(s){let e=s[0],t=e&Ns;return t===e?"legacy":t},deserialize:s=>{let e=bi.deserializeMessageVersion(s);if(e==="legacy")return ct.from(s);if(e===0)return or.deserialize(s);throw new Error(`Transaction message version ${e} deserialization is not supported`)}},ot=function(s){return s[s.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",s[s.PROCESSED=1]="PROCESSED",s[s.TIMED_OUT=2]="TIMED_OUT",s[s.NONCE_INVALID=3]="NONCE_INVALID",s}({}),dh=y.alloc(tr).fill(0),Q=class{constructor(e){this.keys=void 0,this.programId=void 0,this.data=y.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}},K=class s{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){let{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){let{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{let{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Q(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let A=0;A<t.length;A++)if(t[A].programId===void 0)throw new Error(`Transaction instruction index ${A} has undefined program id`);let r=[],o=[];t.forEach(A=>{A.keys.forEach(P=>{o.push({...P})});let S=A.programId.toString();r.includes(S)||r.push(S)}),r.forEach(A=>{o.push({pubkey:new L(A),isSigner:!1,isWritable:!1})});let i=[];o.forEach(A=>{let S=A.pubkey.toString(),P=i.findIndex(F=>F.pubkey.toString()===S);P>-1?(i[P].isWritable=i[P].isWritable||A.isWritable,i[P].isSigner=i[P].isSigner||A.isSigner):i.push(A)}),i.sort(function(A,S){if(A.isSigner!==S.isSigner)return A.isSigner?-1:1;if(A.isWritable!==S.isWritable)return A.isWritable?-1:1;let P={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return A.pubkey.toBase58().localeCompare(S.pubkey.toBase58(),"en",P)});let a=i.findIndex(A=>A.pubkey.equals(n));if(a>-1){let[A]=i.splice(a,1);A.isSigner=!0,A.isWritable=!0,i.unshift(A)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(let A of this.signatures){let S=i.findIndex(P=>P.pubkey.equals(A.publicKey));if(S>-1)i[S].isSigner||(i[S].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${A.publicKey.toString()}`)}let c=0,h=0,d=0,w=[],v=[];i.forEach(({pubkey:A,isSigner:S,isWritable:P})=>{S?(w.push(A.toString()),c+=1,P||(h+=1)):(v.push(A.toString()),P||(d+=1))});let m=w.concat(v),E=t.map(A=>{let{data:S,programId:P}=A;return{programIdIndex:m.indexOf(P.toString()),accounts:A.keys.map(F=>m.indexOf(F.pubkey.toString())),data:he.default.encode(S)}});return E.forEach(A=>{J(A.programIdIndex>=0),A.accounts.forEach(S=>J(S>=0))}),new ct({header:{numRequiredSignatures:c,numReadonlySignedAccounts:h,numReadonlyUnsignedAccounts:d},accountKeys:m,recentBlockhash:e,instructions:E})}_compile(){let e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,o)=>t[o].equals(r.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");let t=new Set;this.signatures=e.filter(n=>{let r=n.toString();return t.has(r)?!1:(t.add(r),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));let r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}let r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){let n=e.serialize();t.forEach(r=>{let o=Is(n,r.secretKey);this._addSignature(r.publicKey,H(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){J(t.length===64);let n=this.signatures.findIndex(r=>e.equals(r.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=y.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){let n={};for(let{signature:r,publicKey:o}of this.signatures)r===null?t&&(n.missing||=[]).push(o):nh(r,e,o.toBytes())||(n.invalid||=[]).push(o);return n.invalid||n.missing?n:void 0}serialize(e){let{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n){let o=this._getMessageSignednessErrors(r,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(r)}_serialize(e){let{signatures:t}=this,n=[];Ne(n,t.length);let r=n.length+t.length*64+e.length,o=y.alloc(r);return J(t.length<256),y.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(J(i.length===64,"signature has invalid length"),y.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),J(o.length<=Rt,`Transaction too large: ${o.length} > ${Rt}`),o}get keys(){return J(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return J(this.instructions.length===1),this.instructions[0].programId}get data(){return J(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e],n=Ie(t),r=[];for(let o=0;o<n;o++){let i=Ce(t,0,tr);r.push(he.default.encode(y.from(i)))}return s.populate(ct.from(t),r)}static populate(e,t=[]){let n=new s;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((r,o)=>{let i={signature:r==he.default.encode(dh)?null:he.default.decode(r),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(r=>{let o=r.accounts.map(i=>{let a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new Q({keys:o,programId:e.accountKeys[r.programIdIndex],data:he.default.decode(r.data)}))}),n._message=e,n._json=n.toJSON(),n}};var De=class s{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)J(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{let n=[];for(let r=0;r<e.header.numRequiredSignatures;r++)n.push(new Uint8Array(tr));this.signatures=n}this.message=e}serialize(){let e=this.message.serialize(),t=Array();Ne(t,this.signatures.length);let n=u.struct([u.blob(t.length,"encodedSignaturesLength"),u.seq(oh(),this.signatures.length,"signatures"),u.blob(e.length,"serializedMessage")]),r=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,o)}static deserialize(e){let t=[...e],n=[],r=Ie(t);for(let i=0;i<r;i++)n.push(new Uint8Array(Ce(t,0,tr)));let o=bi.deserialize(new Uint8Array(t));return new s(o,n)}sign(e){let t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(let r of e){let o=n.findIndex(i=>i.equals(r.publicKey));J(o>=0,`Cannot sign with non signer key ${r.publicKey.toBase58()}`),this.signatures[o]=Is(t,r.secretKey)}}addSignature(e,t){J(t.byteLength===64,"Signature must be 64 bytes long");let r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));J(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}},lh=160,hh=64,fh=lh/hh,Ii=1e3/fh,Je=new L("SysvarC1ock11111111111111111111111111111111"),i_=new L("SysvarEpochSchedu1e111111111111111111111111"),a_=new L("Sysvar1nstructions1111111111111111111111111"),rs=new L("SysvarRecentB1ockHashes11111111111111111111"),tn=new L("SysvarRent111111111111111111111111111111111"),c_=new L("SysvarRewards111111111111111111111111111111"),u_=new L("SysvarS1otHashes111111111111111111111111111"),d_=new L("SysvarS1otHistory11111111111111111111111111"),ss=new L("SysvarStakeHistory1111111111111111111111111"),nn=class extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:r}){let o=r?`Logs: 
${JSON.stringify(r.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=r||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(r=>{if(r&&r.meta&&r.meta.logMessages){let o=r.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}};var B=class extends Error{constructor({code:e,message:t,data:n},r){super(r!=null?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}};async function si(s,e,t,n){let r=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await s.sendTransaction(e,t,r),i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await s.confirmTransaction({abortSignal:n?.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){let{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await s.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else n?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await s.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new nn({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function mt(s){return new Promise(e=>setTimeout(e,s))}function q(s,e){let t=s.layout.span>=0?s.layout.span:wi(s,e),n=y.alloc(t),r=Object.assign({instruction:s.index},e);return s.layout.encode(r,n),n}var ph=u.nu64("lamportsPerSignature"),Ni=u.struct([u.u32("version"),u.u32("state"),$("authorizedPubkey"),$("nonce"),u.struct([ph],"feeCalculator")]),oi=Ni.span,ps=class s{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){let t=Ni.decode(H(e),0);return new s({authorizedPubkey:new L(t.authorizedPubkey),nonce:new L(t.nonce).toString(),feeCalculator:t.feeCalculator})}};function Bt(s){let e=(0,Ai.blob)(8,s),t=e.decode.bind(e),n=e.encode.bind(e),r=e,o=Vo();return r.decode=(i,a)=>{let c=t(i,a);return o.decode(c)},r.encode=(i,a,c)=>{let h=o.encode(i);return n(h,a,c)},r}var Le=Object.freeze({Create:{index:0,layout:u.struct([u.u32("instruction"),u.ns64("lamports"),u.ns64("space"),$("programId")])},Assign:{index:1,layout:u.struct([u.u32("instruction"),$("programId")])},Transfer:{index:2,layout:u.struct([u.u32("instruction"),Bt("lamports")])},CreateWithSeed:{index:3,layout:u.struct([u.u32("instruction"),$("base"),Pt("seed"),u.ns64("lamports"),u.ns64("space"),$("programId")])},AdvanceNonceAccount:{index:4,layout:u.struct([u.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:u.struct([u.u32("instruction"),$("authorized")])},AuthorizeNonceAccount:{index:7,layout:u.struct([u.u32("instruction"),$("authorized")])},Allocate:{index:8,layout:u.struct([u.u32("instruction"),u.ns64("space")])},AllocateWithSeed:{index:9,layout:u.struct([u.u32("instruction"),$("base"),Pt("seed"),u.ns64("space"),$("programId")])},AssignWithSeed:{index:10,layout:u.struct([u.u32("instruction"),$("base"),Pt("seed"),$("programId")])},TransferWithSeed:{index:11,layout:u.struct([u.u32("instruction"),Bt("lamports"),Pt("seed"),$("programId")])},UpgradeNonceAccount:{index:12,layout:u.struct([u.u32("instruction")])}}),ge=class s{constructor(){}static createAccount(e){let t=Le.Create,n=q(t,{lamports:e.lamports,space:e.space,programId:H(e.programId.toBuffer())});return new Q({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){let r=Le.TransferWithSeed;t=q(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:H(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{let r=Le.Transfer;t=q(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new Q({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){let r=Le.AssignWithSeed;t=q(r,{base:H(e.basePubkey.toBuffer()),seed:e.seed,programId:H(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let r=Le.Assign;t=q(r,{programId:H(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Q({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){let t=Le.CreateWithSeed,n=q(t,{base:H(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:H(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new Q({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){let t=new K;"basePubkey"in e&&"seed"in e?t.add(s.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:oi,programId:this.programId})):t.add(s.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:oi,programId:this.programId}));let n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){let t=Le.InitializeNonceAccount,n=q(t,{authorized:H(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:rs,isSigner:!1,isWritable:!1},{pubkey:tn,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new Q(r)}static nonceAdvance(e){let t=Le.AdvanceNonceAccount,n=q(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:rs,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new Q(r)}static nonceWithdraw(e){let t=Le.WithdrawNonceAccount,n=q(t,{lamports:e.lamports});return new Q({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:rs,isSigner:!1,isWritable:!1},{pubkey:tn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){let t=Le.AuthorizeNonceAccount,n=q(t,{authorized:H(e.newAuthorizedPubkey.toBuffer())});return new Q({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){let r=Le.AllocateWithSeed;t=q(r,{base:H(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:H(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let r=Le.Allocate;t=q(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Q({keys:n,programId:this.programId,data:t})}};ge.programId=new L("11111111111111111111111111111111");var gh=Rt-300,gs=class s{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/s.chunkSize)+1+1)}static async load(e,t,n,r,o){{let w=await e.getMinimumBalanceForRentExemption(o.length),v=await e.getAccountInfo(n.publicKey,"confirmed"),m=null;if(v!==null){if(v.executable)return console.error("Program load failed, account is already executable"),!1;v.data.length!==o.length&&(m=m||new K,m.add(ge.allocate({accountPubkey:n.publicKey,space:o.length}))),v.owner.equals(r)||(m=m||new K,m.add(ge.assign({accountPubkey:n.publicKey,programId:r}))),v.lamports<w&&(m=m||new K,m.add(ge.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:w-v.lamports})))}else m=new K().add(ge.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:w>0?w:1,space:o.length,programId:r}));m!==null&&await si(e,m,[t,n],{commitment:"confirmed"})}let i=u.struct([u.u32("instruction"),u.u32("offset"),u.u32("bytesLength"),u.u32("bytesLengthPadding"),u.seq(u.u8("byte"),u.offset(u.u32(),-8),"bytes")]),a=s.chunkSize,c=0,h=o,d=[];for(;h.length>0;){let w=h.slice(0,a),v=y.alloc(a+16);i.encode({instruction:0,offset:c,bytes:w,bytesLength:0,bytesLengthPadding:0},v);let m=new K().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:r,data:v});d.push(si(e,m,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await mt(1e3/4),c+=a,h=h.slice(a)}await Promise.all(d);{let w=u.struct([u.u32("instruction")]),v=y.alloc(w.span);w.encode({instruction:1},v);let m=new K().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:tn,isSigner:!1,isWritable:!1}],programId:r,data:v}),E="processed",A=await e.sendTransaction(m,[t,n],{preflightCommitment:E}),{context:S,value:P}=await e.confirmTransaction({signature:A,lastValidBlockHeight:m.lastValidBlockHeight,blockhash:m.recentBlockhash},E);if(P.err)throw new Error(`Transaction ${A} failed (${JSON.stringify(P)})`);for(;;){try{if(await e.getSlot({commitment:E})>S.slot)break}catch{}await new Promise(F=>setTimeout(F,Math.round(Ii/2)))}}return!0}};gs.chunkSize=gh;var l_=new L("BPFLoader2111111111111111111111111111111111");function _h(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var os,ii;function yh(){if(ii)return os;ii=1;var s=Object.prototype.toString,e=Object.keys||function(n){var r=[];for(var o in n)r.push(o);return r};function t(n,r){var o,i,a,c,h,d,w;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),r);if(w=s.call(n),w==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(w==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)h=c[o],d=t(n[h],!1),d!==void 0&&(a&&(a+=","),a+=JSON.stringify(h)+":"+d),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return r?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return os=function(n){var r=t(n,!1);if(r!==void 0)return""+r},os}var mh=yh(),ai=_h(mh),Zt=32;function is(s){let e=0;for(;s>1;)s/=2,e++;return e}function Ah(s){return s===0?1:(s--,s|=s>>1,s|=s>>2,s|=s>>4,s|=s>>8,s|=s>>16,s|=s>>32,s+1)}var _s=class{constructor(e,t,n,r,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){let t=is(Ah(e+Zt+1))-is(Zt)-1,n=this.getSlotsInEpoch(t),r=e-(n-Zt);return[t,r]}else{let t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[r,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Zt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+is(Zt)):this.slotsPerEpoch}},Rh=globalThis.fetch,ys=class extends ei{constructor(e,t,n){let r=o=>{let i=Qo(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){let t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){let t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}};function Eh(s,e){let t;try{t=s.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==s.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${s.index}`);return t}var ci=56,ir=class{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){let e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){let t=Eh(wh,e),n=e.length-ci;J(n>=0,"lookup table is invalid"),J(n%32===0,"lookup table is invalid");let r=n/32,{addresses:o}=u.struct([u.seq($(),r,"addresses")]).decode(e.slice(ci));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new L(t.authority[0]):void 0,addresses:o.map(i=>new L(i))}}},wh={index:1,layout:u.struct([u.u32("typeIndex"),Bt("deactivationSlot"),u.nu64("lastExtendedSlot"),u.u8("lastExtendedStartIndex"),u.u8(),u.seq($(),u.offset(u.u8(),-1),"authority")])},Sh=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function bh(s){let e=s.match(Sh);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${s}\``);let[t,n,r,o]=e,i=s.startsWith("https:")?"wss:":"ws:",a=r==null?null:parseInt(r.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}var ie=Lt(Xn(L),b(),s=>new L(s)),Ci=Jn([b(),re("base64")]),Cs=Lt(Xn(y),Ci,s=>y.from(s[0],"base64")),Ih=30*1e3;function Nh(s){if(/^https?:/.test(s)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return s}function te(s){let e,t;if(typeof s=="string")e=s;else if(s){let{commitment:n,...r}=s;e=n,t=r}return{commitment:e,config:t}}function ui(s){return s.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function Oi(s){return Ae([R({jsonrpc:re("2.0"),id:b(),result:s}),R({jsonrpc:re("2.0"),id:b(),error:R({code:yt(),message:b(),data:D(jo())})})])}var Ch=Oi(yt());function W(s){return Lt(Oi(s),Ch,e=>"error"in e?e:{...e,result:N(e.result,s)})}function ue(s){return W(R({context:R({slot:l()}),value:s}))}function dr(s){return R({context:R({slot:l()}),value:s})}function as(s,e){return s===0?new or({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new L(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:he.default.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new ct(e)}var Oh=R({foundation:l(),foundationTerm:l(),initial:l(),taper:l(),terminal:l()}),Th=W(C(O(R({epoch:l(),effectiveSlot:l(),amount:l(),postBalance:l(),commission:D(O(l()))})))),kh=C(R({slot:l(),prioritizationFee:l()})),vh=R({total:l(),validator:l(),foundation:l(),epoch:l()}),Lh=R({epoch:l(),slotIndex:l(),slotsInEpoch:l(),absoluteSlot:l(),blockHeight:D(l()),transactionCount:D(l())}),Ph=R({slotsPerEpoch:l(),leaderScheduleSlotOffset:l(),warmup:Ue(),firstNormalEpoch:l(),firstNormalSlot:l()}),xh=ns(b(),C(l())),Et=O(Ae([R({}),b()])),Bh=R({err:Et}),Uh=re("receivedSignature"),Dh=R({"solana-core":b(),"feature-set":D(l())}),Mh=R({program:b(),programId:ie,parsed:yt()}),zh=R({programId:ie,accounts:C(ie),data:b()}),di=ue(R({err:O(Ae([R({}),b()])),logs:O(C(b())),accounts:D(O(C(O(R({executable:Ue(),owner:b(),lamports:l(),data:C(b()),rentEpoch:D(l())}))))),unitsConsumed:D(l()),returnData:D(O(R({programId:b(),data:Jn([b(),re("base64")])}))),innerInstructions:D(O(C(R({index:l(),instructions:C(Ae([Mh,zh]))}))))})),Fh=ue(R({byIdentity:ns(b(),C(l())),range:R({firstSlot:l(),lastSlot:l()})}));function Wh(s,e,t,n,r,o){let i=t||Rh,a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(d,w)=>{let v=await new Promise((m,E)=>{try{n(d,w,(A,S)=>m([A,S]))}catch(A){E(A)}});return await i(...v)}),new Ri.default(async(d,w)=>{let v={method:"POST",body:d,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Kf)};try{let m=5,E,A=500;for(;c?E=await c(s,v):E=await i(s,v),!(E.status!==429||r===!0||(m-=1,m===0));)console.error(`Server responded with ${E.status} ${E.statusText}.  Retrying after ${A}ms delay...`),await mt(A),A*=2;let S=await E.text();E.ok?w(null,S):w(new Error(`${E.status} ${E.statusText}: ${S}`))}catch(m){m instanceof Error&&w(m)}},{})}function Kh(s){return(e,t)=>new Promise((n,r)=>{s.request(e,t,(o,i)=>{if(o){r(o);return}n(i)})})}function $h(s){return e=>new Promise((t,n)=>{e.length===0&&t([]);let r=e.map(o=>s.request(o.methodName,o.args));s.request(r,(o,i)=>{if(o){n(o);return}t(i)})})}var Vh=W(Oh),Hh=W(vh),qh=W(kh),Gh=W(Lh),jh=W(Ph),Yh=W(xh),Xh=W(l()),Jh=ue(R({total:l(),circulating:l(),nonCirculating:l(),nonCirculatingAccounts:C(ie)})),ms=R({amount:b(),uiAmount:O(l()),decimals:l(),uiAmountString:D(b())}),Zh=ue(C(R({address:ie,amount:b(),uiAmount:O(l()),decimals:l(),uiAmountString:D(b())}))),Qh=ue(C(R({pubkey:ie,account:R({executable:Ue(),owner:ie,lamports:l(),data:Cs,rentEpoch:l()})}))),As=R({program:b(),parsed:yt(),space:l()}),ef=ue(C(R({pubkey:ie,account:R({executable:Ue(),owner:ie,lamports:l(),data:As,rentEpoch:l()})}))),tf=ue(C(R({lamports:l(),address:ie}))),rn=R({executable:Ue(),owner:ie,lamports:l(),data:Cs,rentEpoch:l()}),nf=R({pubkey:ie,account:rn}),rf=Lt(Ae([Xn(y),As]),Ae([Ci,As]),s=>Array.isArray(s)?N(s,Cs):s),Rs=R({executable:Ue(),owner:ie,lamports:l(),data:rf,rentEpoch:l()}),sf=R({pubkey:ie,account:Rs}),of=R({state:Ae([re("active"),re("inactive"),re("activating"),re("deactivating")]),active:l(),inactive:l()}),af=W(C(R({signature:b(),slot:l(),err:Et,memo:O(b()),blockTime:D(O(l()))}))),cf=W(C(R({signature:b(),slot:l(),err:Et,memo:O(b()),blockTime:D(O(l()))}))),uf=R({subscription:l(),result:dr(rn)}),df=R({pubkey:ie,account:rn}),lf=R({subscription:l(),result:dr(df)}),hf=R({parent:l(),slot:l(),root:l()}),ff=R({subscription:l(),result:hf}),pf=Ae([R({type:Ae([re("firstShredReceived"),re("completed"),re("optimisticConfirmation"),re("root")]),slot:l(),timestamp:l()}),R({type:re("createdBank"),parent:l(),slot:l(),timestamp:l()}),R({type:re("frozen"),slot:l(),timestamp:l(),stats:R({numTransactionEntries:l(),numSuccessfulTransactions:l(),numFailedTransactions:l(),maxTransactionsPerEntry:l()})}),R({type:re("dead"),slot:l(),timestamp:l(),err:b()})]),gf=R({subscription:l(),result:pf}),_f=R({subscription:l(),result:dr(Ae([Bh,Uh]))}),yf=R({subscription:l(),result:l()}),mf=R({pubkey:b(),gossip:O(b()),tpu:O(b()),rpc:O(b()),version:O(b())}),li=R({votePubkey:b(),nodePubkey:b(),activatedStake:l(),epochVoteAccount:Ue(),epochCredits:C(Jn([l(),l(),l()])),commission:l(),lastVote:l(),rootSlot:O(l())}),Af=W(R({current:C(li),delinquent:C(li)})),Rf=Ae([re("processed"),re("confirmed"),re("finalized")]),Ef=R({slot:l(),confirmations:O(l()),err:Et,confirmationStatus:D(Rf)}),wf=ue(C(O(Ef))),Sf=W(l()),Ti=R({accountKey:ie,writableIndexes:C(l()),readonlyIndexes:C(l())}),Os=R({signatures:C(b()),message:R({accountKeys:C(b()),header:R({numRequiredSignatures:l(),numReadonlySignedAccounts:l(),numReadonlyUnsignedAccounts:l()}),instructions:C(R({accounts:C(l()),data:b(),programIdIndex:l()})),recentBlockhash:b(),addressTableLookups:D(C(Ti))})}),ki=R({pubkey:ie,signer:Ue(),writable:Ue(),source:D(Ae([re("transaction"),re("lookupTable")]))}),vi=R({accountKeys:C(ki),signatures:C(b())}),Li=R({parsed:yt(),program:b(),programId:ie}),Pi=R({accounts:C(ie),data:b(),programId:ie}),bf=Ae([Pi,Li]),If=Ae([R({parsed:yt(),program:b(),programId:b()}),R({accounts:C(b()),data:b(),programId:b()})]),xi=Lt(bf,If,s=>"accounts"in s?N(s,Pi):N(s,Li)),Bi=R({signatures:C(b()),message:R({accountKeys:C(ki),instructions:C(xi),recentBlockhash:b(),addressTableLookups:D(O(C(Ti)))})}),ar=R({accountIndex:l(),mint:b(),owner:D(b()),programId:D(b()),uiTokenAmount:ms}),Ui=R({writable:C(ie),readonly:C(ie)}),lr=R({err:Et,fee:l(),innerInstructions:D(O(C(R({index:l(),instructions:C(R({accounts:C(l()),data:b(),programIdIndex:l()}))})))),preBalances:C(l()),postBalances:C(l()),logMessages:D(O(C(b()))),preTokenBalances:D(O(C(ar))),postTokenBalances:D(O(C(ar))),loadedAddresses:D(Ui),computeUnitsConsumed:D(l())}),Ts=R({err:Et,fee:l(),innerInstructions:D(O(C(R({index:l(),instructions:C(xi)})))),preBalances:C(l()),postBalances:C(l()),logMessages:D(O(C(b()))),preTokenBalances:D(O(C(ar))),postTokenBalances:D(O(C(ar))),loadedAddresses:D(Ui),computeUnitsConsumed:D(l())}),Mt=Ae([re(0),re("legacy")]),wt=R({pubkey:b(),lamports:l(),postBalance:O(l()),rewardType:O(b()),commission:D(O(l()))}),Nf=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),transactions:C(R({transaction:Os,meta:O(lr),version:D(Mt)})),rewards:D(C(wt)),blockTime:O(l()),blockHeight:O(l())}))),Cf=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),rewards:D(C(wt)),blockTime:O(l()),blockHeight:O(l())}))),Of=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),transactions:C(R({transaction:vi,meta:O(lr),version:D(Mt)})),rewards:D(C(wt)),blockTime:O(l()),blockHeight:O(l())}))),Tf=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),transactions:C(R({transaction:Bi,meta:O(Ts),version:D(Mt)})),rewards:D(C(wt)),blockTime:O(l()),blockHeight:O(l())}))),kf=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),transactions:C(R({transaction:vi,meta:O(Ts),version:D(Mt)})),rewards:D(C(wt)),blockTime:O(l()),blockHeight:O(l())}))),vf=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),rewards:D(C(wt)),blockTime:O(l()),blockHeight:O(l())}))),Lf=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),transactions:C(R({transaction:Os,meta:O(lr)})),rewards:D(C(wt)),blockTime:O(l())}))),hi=W(O(R({blockhash:b(),previousBlockhash:b(),parentSlot:l(),signatures:C(b()),blockTime:O(l())}))),cs=W(O(R({slot:l(),meta:O(lr),blockTime:D(O(l())),transaction:Os,version:D(Mt)}))),Zn=W(O(R({slot:l(),transaction:Bi,meta:O(Ts),blockTime:D(O(l())),version:D(Mt)}))),Pf=ue(R({blockhash:b(),lastValidBlockHeight:l()})),xf=ue(Ue()),Bf=R({slot:l(),numTransactions:l(),numSlots:l(),samplePeriodSecs:l()}),Uf=W(C(Bf)),Df=ue(O(R({feeCalculator:R({lamportsPerSignature:l()})}))),Mf=W(b()),zf=W(b()),Ff=R({err:Et,logs:C(b()),signature:b()}),Wf=R({result:dr(Ff),subscription:l()}),Kf={"solana-client":"js/1.0.0-maintenance"},ut=class{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{let h={};return async d=>{let{commitment:w,config:v}=te(d),m=this._buildArgs([],w,void 0,v),E=ai(m);return h[E]=h[E]??(async()=>{try{let A=await this._rpcRequest("getBlockHeight",m),S=N(A,W(l()));if("error"in S)throw new B(S.error,"failed to get block height information");return S.result}finally{delete h[E]}})(),await h[E]}})();let n,r,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Nh(e),this._rpcWsEndpoint=n||bh(e),this._rpcClient=Wh(e,r,o,i,a,c),this._rpcRequest=Kh(this._rpcClient),this._rpcBatchRequest=$h(this._rpcClient),this._rpcWebSocket=new ys(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgs([e.toBase58()],n,void 0,r),i=await this._rpcRequest("getBalance",o),a=N(i,ue(l()));if("error"in a)throw new B(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){let t=await this._rpcRequest("getBlockTime",[e]),n=N(t,W(O(l())));if("error"in n)throw new B(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){let e=await this._rpcRequest("minimumLedgerSlot",[]),t=N(e,W(l()));if("error"in t)throw new B(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){let e=await this._rpcRequest("getFirstAvailableBlock",[]),t=N(e,Xh);if("error"in t)throw new B(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};let n=await this._rpcRequest("getSupply",[t]),r=N(n,Jh);if("error"in r)throw new B(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){let n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenSupply",n),o=N(r,ue(ms));if("error"in o)throw new B(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){let n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenAccountBalance",n),o=N(r,ue(ms));if("error"in o)throw new B(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){let{commitment:r,config:o}=te(n),i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});let a=this._buildArgs(i,r,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),h=N(c,Qh);if("error"in h)throw new B(h.error,`failed to get token accounts owned by account ${e.toBase58()}`);return h.result}async getParsedTokenAccountsByOwner(e,t,n){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});let o=this._buildArgs(r,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=N(i,ef);if("error"in a)throw new B(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){let t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],r=await this._rpcRequest("getLargestAccounts",n),o=N(r,tf);if("error"in o)throw new B(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){let n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenLargestAccounts",n),o=N(r,Zh);if("error"in o)throw new B(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgs([e.toBase58()],n,"base64",r),i=await this._rpcRequest("getAccountInfo",o),a=N(i,ue(O(rn)));if("error"in a)throw new B(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getAccountInfo",o),a=N(i,ue(O(Rs)));if("error"in a)throw new B(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){let{commitment:n,config:r}=te(t),o=e.map(h=>h.toBase58()),i=this._buildArgs([o],n,"jsonParsed",r),a=await this._rpcRequest("getMultipleAccounts",i),c=N(a,ue(C(O(Rs))));if("error"in c)throw new B(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){let{commitment:n,config:r}=te(t),o=e.map(h=>h.toBase58()),i=this._buildArgs([o],n,"base64",r),a=await this._rpcRequest("getMultipleAccounts",i),c=N(a,ue(C(O(rn))));if("error"in c)throw new B(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){let{commitment:r,config:o}=te(t),i=this._buildArgs([e.toBase58()],r,void 0,{...o,epoch:n??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=N(a,W(of));if("error"in c)throw new B(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){let{commitment:n,config:r}=te(t),{encoding:o,...i}=r||{},a=this._buildArgs([e.toBase58()],n,o||"base64",{...i,...i.filters?{filters:ui(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),h=C(nf),d=i.withContext===!0?N(c,ue(h)):N(c,W(h));if("error"in d)throw new B(d.error,`failed to get accounts owned by program ${e.toBase58()}`);return d.result}async getParsedProgramAccounts(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getProgramAccounts",o),a=N(i,W(C(sf)));if("error"in a)throw new B(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let n;if(typeof e=="string")n=e;else{let o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let r;try{r=he.default.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return J(r.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,o=!1,i=new Promise((c,h)=>{try{n=this.onSignature(t,(w,v)=>{n=void 0;let m={context:v,value:w};c({__type:ot.PROCESSED,response:m})},e);let d=new Promise(w=>{n==null?w():r=this._onSubscriptionStateChange(n,v=>{v==="subscribed"&&w()})});(async()=>{if(await d,o)return;let w=await this.getSignatureStatus(t);if(o||w==null)return;let{context:v,value:m}=w;if(m!=null)if(m?.err)h(m.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(m.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(m.confirmationStatus==="processed"||m.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:ot.PROCESSED,response:{context:v,value:m}})}})()}catch(d){h(d)}});return{abortConfirmation:()=>{r&&(r(),r=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let o=!1,i=new Promise(w=>{let v=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let m=await v();if(!o){for(;m<=n;)if(await mt(1e3),o||(m=await v(),o))return;w({__type:ot.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),h=this.getCancellationPromise(t),d;try{let w=await Promise.race([h,c,i]);if(w.__type===ot.PROCESSED)d=w.response;else throw new nr(r)}finally{o=!0,a()}return d}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:o,signature:i}}){let a=!1,c=new Promise(m=>{let E=o,A=null,S=async()=>{try{let{context:P,value:F}=await this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return A=P.slot,F?.nonce}catch{return E}};(async()=>{if(E=await S(),!a)for(;;){if(o!==E){m({__type:ot.NONCE_INVALID,slotInWhichNonceDidAdvance:A});return}if(await mt(2e3),a||(E=await S(),a))return}})()}),{abortConfirmation:h,confirmationPromise:d}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),w=this.getCancellationPromise(t),v;try{let m=await Promise.race([w,d,c]);if(m.__type===ot.PROCESSED)v=m.response;else{let E;for(;;){let A=await this.getSignatureStatus(i);if(A==null)break;if(A.context.slot<(m.slotInWhichNonceDidAdvance??n)){await mt(400);continue}E=A;break}if(E?.value){let A=e||"finalized",{confirmationStatus:S}=E.value;switch(A){case"processed":case"recent":if(S!=="processed"&&S!=="confirmed"&&S!=="finalized")throw new At(i);break;case"confirmed":case"single":case"singleGossip":if(S!=="confirmed"&&S!=="finalized")throw new At(i);break;case"finalized":case"max":case"root":if(S!=="finalized")throw new At(i);break;default:}v={context:E.context,value:{err:E.value.err}}}else throw new At(i)}}finally{a=!0,h()}return v}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n,r=new Promise(c=>{let h=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{h=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:ot.TIMED_OUT,timeoutMs:h}),h)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t}),a;try{let c=await Promise.race([i,r]);if(c.__type===ot.PROCESSED)a=c.response;else throw new rr(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){let e=await this._rpcRequest("getClusterNodes",[]),t=N(e,W(C(mf)));if("error"in t)throw new B(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){let t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),r=N(n,Af);if("error"in r)throw new B(r.error,"failed to get vote accounts");return r.result}async getSlot(e){let{commitment:t,config:n}=te(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",r),i=N(o,W(l()));if("error"in i)throw new B(i.error,"failed to get slot");return i.result}async getSlotLeader(e){let{commitment:t,config:n}=te(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",r),i=N(o,W(b()));if("error"in i)throw new B(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){let n=[e,t],r=await this._rpcRequest("getSlotLeaders",n),o=N(r,W(C(ie)));if("error"in o)throw new B(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){let{context:n,value:r}=await this.getSignatureStatuses([e],t);J(r.length===1);let o=r[0];return{context:n,value:o}}async getSignatureStatuses(e,t){let n=[e];t&&n.push(t);let r=await this._rpcRequest("getSignatureStatuses",n),o=N(r,wf);if("error"in o)throw new B(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){let{commitment:t,config:n}=te(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",r),i=N(o,W(l()));if("error"in i)throw new B(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){let t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),r=N(n,Vh);if("error"in r)throw new B(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,n){let{commitment:r,config:o}=te(n),i=this._buildArgs([e.map(h=>h.toBase58())],r,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=N(a,Th);if("error"in c)throw new B(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){let e=await this._rpcRequest("getInflationRate",[]),t=N(e,Hh);if("error"in t)throw new B(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){let{commitment:t,config:n}=te(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",r),i=N(o,Gh);if("error"in i)throw new B(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){let e=await this._rpcRequest("getEpochSchedule",[]),t=N(e,jh);if("error"in t)throw new B(t.error,"failed to get epoch schedule");let n=t.result;return new _s(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){let e=await this._rpcRequest("getLeaderSchedule",[]),t=N(e,Yh);if("error"in t)throw new B(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){let n=this._buildArgs([e],t),r=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=N(r,Sf);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){let{context:t,value:{blockhash:n}}=await this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:n,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(e){let t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=N(t,Uf);if("error"in n)throw new B(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){let n=this._buildArgs([e],t),r=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=N(r,Df);if("error"in o)throw new B(o.error,"failed to get fee calculator");let{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){let n=H(e.serialize()).toString("base64"),r=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",r),i=N(o,ue(O(l())));if("error"in i)throw new B(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){let t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=t?.length?[t]:[],r=await this._rpcRequest("getRecentPrioritizationFees",n),o=N(r,qh);if("error"in o)throw new B(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){let{commitment:t,config:n}=te(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",r),i=N(o,Pf);if("error"in i)throw new B(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgs([e],n,void 0,r),i=await this._rpcRequest("isBlockhashValid",o),a=N(i,xf);if("error"in a)throw new B(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){let e=await this._rpcRequest("getVersion",[]),t=N(e,W(Dh));if("error"in t)throw new B(t.error,"failed to get version");return t.result}async getGenesisHash(){let e=await this._rpcRequest("getGenesisHash",[]),t=N(e,W(b()));if("error"in t)throw new B(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getBlock",o);try{switch(r?.transactionDetails){case"accounts":{let a=N(i,Of);if("error"in a)throw a.error;return a.result}case"none":{let a=N(i,Cf);if("error"in a)throw a.error;return a.result}default:{let a=N(i,Nf);if("error"in a)throw a.error;let{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:h,meta:d,version:w})=>({meta:d,transaction:{...h,message:as(w,h.message)},version:w}))}:null}}}catch(a){throw new B(a,"failed to get confirmed block")}}async getParsedBlock(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getBlock",o);try{switch(r?.transactionDetails){case"accounts":{let a=N(i,kf);if("error"in a)throw a.error;return a.result}case"none":{let a=N(i,vf);if("error"in a)throw a.error;return a.result}default:{let a=N(i,Tf);if("error"in a)throw a.error;return a.result}}}catch(a){throw new B(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){let{commitment:a,...c}=e;n=a,t=c}let r=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",r),i=N(o,Fh);if("error"in i)throw new B(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getTransaction",o),a=N(i,cs);if("error"in a)throw new B(a.error,"failed to get transaction");let c=a.result;return c&&{...c,transaction:{...c.transaction,message:as(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){let{commitment:n,config:r}=te(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getTransaction",o),a=N(i,Zn);if("error"in a)throw new B(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){let{commitment:n,config:r}=te(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",r)}));return(await this._rpcBatchRequest(o)).map(c=>{let h=N(c,Zn);if("error"in h)throw new B(h.error,"failed to get transactions");return h.result})}async getTransactions(e,t){let{commitment:n,config:r}=te(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,r)}));return(await this._rpcBatchRequest(o)).map(c=>{let h=N(c,cs);if("error"in h)throw new B(h.error,"failed to get transactions");let d=h.result;return d&&{...d,transaction:{...d.transaction,message:as(d.version,d.transaction.message)}}})}async getConfirmedBlock(e,t){let n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getBlock",n),o=N(r,Lf);if("error"in o)throw new B(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");let a={...i,transactions:i.transactions.map(({transaction:c,meta:h})=>{let d=new ct(c.message);return{meta:h,transaction:{...c,message:d}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:h})=>({meta:h,transaction:K.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){let r=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",r),i=N(o,W(C(l())));if("error"in i)throw new B(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),o=N(r,hi);if("error"in o)throw new B(o.error,"failed to get block");let i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),o=N(r,hi);if("error"in o)throw new B(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){let n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getTransaction",n),o=N(r,cs);if("error"in o)throw new B(o.error,"failed to get transaction");let i=o.result;if(!i)return i;let a=new ct(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:K.populate(a,c)}}async getParsedConfirmedTransaction(e,t){let n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=await this._rpcRequest("getTransaction",n),o=N(r,Zn);if("error"in o)throw new B(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){let n=e.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{let a=N(i,Zn);if("error"in a)throw new B(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let r={},o=await this.getFirstAvailableBlock();for(;!("until"in r)&&(t--,!(t<=0||t<o));)try{let c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(r.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in r)&&(n++,!(n>i));)try{let c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(r.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,r)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){let r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",r),i=N(o,af);if("error"in i)throw new B(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){let r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",r),i=N(o,cf);if("error"in i)throw new B(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){let{context:n,value:r}=await this.getAccountInfoAndContext(e,t),o=null;return r!==null&&(o=new ir({key:e,state:ir.deserialize(r.data)})),{context:n,value:o}}async getNonceAndContext(e,t){let{context:n,value:r}=await this.getAccountInfoAndContext(e,t),o=null;return r!==null&&(o=ps.fromAccountData(r.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){let n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=N(n,Mf);if("error"in r)throw new B(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await mt(100);let n=Date.now()-this._blockhashInfo.lastFetch>=Ih;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{let e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){let o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await mt(Ii/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){let{commitment:t,config:n}=te(e),r=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",r),i=N(o,ue(l()));if("error"in i)throw new B(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){let A=e.serialize(),S=y.from(A).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");let P=t||{};P.encoding="base64","commitment"in P||(P.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(P.innerInstructions=t.innerInstructions);let F=[S,P],se=await this._rpcRequest("simulateTransaction",F),x=N(se,di);if("error"in x)throw new Error("failed to simulate transaction: "+x.error.message);return x.result}let r;if(e instanceof K){let E=e;r=new K,r.feePayer=E.feePayer,r.instructions=e.instructions,r.nonceInfo=E.nonceInfo,r.signatures=E.signatures}else r=K.populate(e),r._message=r._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");let o=t;if(r.nonceInfo&&o)r.sign(...o);else{let E=this._disableBlockhashCaching;for(;;){let A=await this._blockhashWithExpiryBlockHeight(E);if(r.lastValidBlockHeight=A.lastValidBlockHeight,r.recentBlockhash=A.blockhash,!o)break;if(r.sign(...o),!r.signature)throw new Error("!signature");let S=r.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(S)&&!this._blockhashInfo.transactionSignatures.includes(S)){this._blockhashInfo.simulatedSignatures.push(S);break}else E=!0}}let i=r._compile(),a=i.serialize(),h=r._serialize(a).toString("base64"),d={encoding:"base64",commitment:this.commitment};if(n){let E=(Array.isArray(n)?n:i.nonProgramIds()).map(A=>A.toBase58());d.accounts={encoding:"base64",addresses:E}}o&&(d.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(d.innerInstructions=t.innerInstructions);let w=[h,d],v=await this._rpcRequest("simulateTransaction",w),m=N(v,di);if("error"in m){let E;if("data"in m.error&&(E=m.error.data.logs,E&&Array.isArray(E))){let A=`
    `,S=A+E.join(A);console.error(m.error.message,S)}throw new nn({action:"simulate",signature:"",transactionMessage:m.error.message,logs:E})}return m.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");let i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");let r=t;if(e.nonceInfo)e.sign(...r);else{let i=this._disableBlockhashCaching;for(;;){let a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");let c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}let o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){let n=H(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){let n={encoding:"base64"},r=t&&t.skipPreflight,o=r===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),o&&(n.preflightCommitment=o);let i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=N(a,zf);if("error"in c){let h;throw"data"in c.error&&(h=c.error.data.logs),new nn({action:r?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:h})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){let n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){let r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){let n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};let r=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return r.add(t),()=>{r.delete(t),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}let e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{let r=this._subscriptionsByHash[n];if(r!==void 0)switch(r.state){case"pending":case"unsubscribed":if(r.callbacks.size===0){delete this._subscriptionsByHash[n],r.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{let{args:o,method:i}=r;try{this._setSubscription(n,{...r,state:"subscribing"});let a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...r,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=r.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":r.callbacks.size===0&&await(async()=>{let{serverSubscriptionId:o,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...r,state:"unsubscribing"}),this._setSubscription(n,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...r,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){let n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(r=>{try{r(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){let{result:t,subscription:n}=N(e,uf);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){let n=this._nextClientSubscriptionId++,r=ai([e.method,t]),o=this._subscriptionsByHash[r];return o===void 0?this._subscriptionsByHash[r]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];let i=this._subscriptionsByHash[r];J(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){let{commitment:r,config:o}=te(n),i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){let{result:t,subscription:n}=N(e,lf);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){let{commitment:o,config:i}=te(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(r?{filters:ui(r)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){let r=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){let{result:t,subscription:n}=N(e,Wf);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){let{result:t,subscription:n}=N(e,ff);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){let{result:t,subscription:n}=N(e,gf);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){let n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,r){let o=t||this._commitment;if(o||n||r){let i={};n&&(i.encoding=n),o&&(i.commitment=o),r&&(i=Object.assign(i,r)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){let o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){let{result:t,subscription:n}=N(e,_f);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){let r=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return o}onSignatureWithOptions(e,t,n){let{commitment:r,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],r,void 0,o),a=this._makeSubscription({callback:(c,h)=>{t(c,h);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){let{result:t,subscription:n}=N(e,yf);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}},Es=class s{constructor(e){this._keypair=void 0,this._keypair=e??ti()}static generate(){return new s(ti())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");let n=e.slice(32,64);if(!t||!t.skipValidation){let r=e.slice(0,32),o=hs(r);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new s({publicKey:n,secretKey:e})}static fromSeed(e){let t=hs(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new s({publicKey:t,secretKey:n})}get publicKey(){return new L(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}},Qt=Object.freeze({CreateLookupTable:{index:0,layout:u.struct([u.u32("instruction"),Bt("recentSlot"),u.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:u.struct([u.u32("instruction")])},ExtendLookupTable:{index:2,layout:u.struct([u.u32("instruction"),Bt(),u.seq($(),u.offset(u.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:u.struct([u.u32("instruction")])},CloseLookupTable:{index:4,layout:u.struct([u.u32("instruction")])}});var ws=class{constructor(){}static createLookupTable(e){let[t,n]=L.findProgramAddressSync([e.authority.toBuffer(),Qr().encode(e.recentSlot)],this.programId),r=Qt.CreateLookupTable,o=q(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:ge.programId,isSigner:!1,isWritable:!1}];return[new Q({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){let t=Qt.FreezeLookupTable,n=q(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Q({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){let t=Qt.ExtendLookupTable,n=q(t,{addresses:e.addresses.map(o=>o.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:ge.programId,isSigner:!1,isWritable:!1}),new Q({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){let t=Qt.DeactivateLookupTable,n=q(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Q({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){let t=Qt.CloseLookupTable,n=q(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new Q({programId:this.programId,keys:r,data:n})}};ws.programId=new L("AddressLookupTab1e1111111111111111111111111");var Qn=Object.freeze({RequestUnits:{index:0,layout:u.struct([u.u8("instruction"),u.u32("units"),u.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:u.struct([u.u8("instruction"),u.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:u.struct([u.u8("instruction"),u.u32("units")])},SetComputeUnitPrice:{index:3,layout:u.struct([u.u8("instruction"),Bt("microLamports")])}}),Ut=class{constructor(){}static requestUnits(e){let t=Qn.RequestUnits,n=q(t,e);return new Q({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){let t=Qn.RequestHeapFrame,n=q(t,e);return new Q({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){let t=Qn.SetComputeUnitLimit,n=q(t,e);return new Q({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){let t=Qn.SetComputeUnitPrice,n=q(t,{microLamports:BigInt(e.microLamports)});return new Q({keys:[],programId:this.programId,data:n})}};Ut.programId=new L("ComputeBudget111111111111111111111111111111");var fi=64,pi=32,gi=64,_i=u.struct([u.u8("numSignatures"),u.u8("padding"),u.u16("signatureOffset"),u.u16("signatureInstructionIndex"),u.u16("publicKeyOffset"),u.u16("publicKeyInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u16("messageInstructionIndex")]),Ss=class s{constructor(){}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:r,instructionIndex:o}=e;J(t.length===pi,`Public Key must be ${pi} bytes but received ${t.length} bytes`),J(r.length===gi,`Signature must be ${gi} bytes but received ${r.length} bytes`);let i=_i.span,a=i+t.length,c=a+r.length,h=1,d=y.alloc(c+n.length),w=o??65535;return _i.encode({numSignatures:h,padding:0,signatureOffset:a,signatureInstructionIndex:w,publicKeyOffset:i,publicKeyInstructionIndex:w,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:w},d),d.fill(t,i),d.fill(r,a),d.fill(n,c),new Q({keys:[],programId:s.programId,data:d})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:r}=e;J(t.length===fi,`Private key must be ${fi} bytes but received ${t.length} bytes`);try{let o=Es.fromSecretKey(t),i=o.publicKey.toBytes(),a=Is(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};Ss.programId=new L("Ed25519SigVerify111111111111111111111111111");var $f=(s,e)=>{let t=Rn.sign(s,e);return[t.toCompactRawBytes(),t.recovery]};Rn.utils.isValidPrivateKey;var Vf=Rn.getPublicKey,yi=32,us=20,mi=64,Hf=11,ds=u.struct([u.u8("numSignatures"),u.u16("signatureOffset"),u.u8("signatureInstructionIndex"),u.u16("ethAddressOffset"),u.u8("ethAddressInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u8("messageInstructionIndex"),u.blob(20,"ethAddress"),u.blob(64,"signature"),u.u8("recoveryId")]),bs=class s{constructor(){}static publicKeyToEthAddress(e){J(e.length===mi,`Public key must be ${mi} bytes but received ${e.length} bytes`);try{return y.from(Or(H(e))).slice(-us)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:r,recoveryId:o,instructionIndex:i}=e;return s.createInstructionWithEthAddress({ethAddress:s.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){let{ethAddress:t,message:n,signature:r,recoveryId:o,instructionIndex:i=0}=e,a;typeof t=="string"?t.startsWith("0x")?a=y.from(t.substr(2),"hex"):a=y.from(t,"hex"):a=t,J(a.length===us,`Address must be ${us} bytes but received ${a.length} bytes`);let c=1+Hf,h=c,d=c+a.length,w=d+r.length+1,v=1,m=y.alloc(ds.span+n.length);return ds.encode({numSignatures:v,signatureOffset:d,signatureInstructionIndex:i,ethAddressOffset:h,ethAddressInstructionIndex:i,messageDataOffset:w,messageDataSize:n.length,messageInstructionIndex:i,signature:H(r),ethAddress:H(a),recoveryId:o},m),m.fill(H(n),ds.span),new Q({keys:[],programId:s.programId,data:m})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:r}=e;J(t.length===yi,`Private key must be ${yi} bytes but received ${t.length} bytes`);try{let o=H(t),i=Vf(o,!1).slice(1),a=y.from(Or(H(n))),[c,h]=$f(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:h,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};bs.programId=new L("KeccakSecp256k11111111111111111111111111111");var Di,qf=new L("StakeConfig11111111111111111111111111111111");var sn=class{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}};Di=sn;sn.default=new Di(0,0,L.default);var it=Object.freeze({Initialize:{index:0,layout:u.struct([u.u32("instruction"),ih(),ah()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),$("newAuthorized"),u.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:u.struct([u.u32("instruction")])},Split:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Withdraw:{index:4,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Deactivate:{index:5,layout:u.struct([u.u32("instruction")])},Merge:{index:7,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:u.struct([u.u32("instruction"),$("newAuthorized"),u.u32("stakeAuthorizationType"),Pt("authoritySeed"),$("authorityOwner")])}}),h_=Object.freeze({Staker:{index:0},Withdrawer:{index:1}}),cr=class{constructor(){}static initialize(e){let{stakePubkey:t,authorized:n,lockup:r}=e,o=r||sn.default,i=it.Initialize,a=q(i,{authorized:{staker:H(n.staker.toBuffer()),withdrawer:H(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:H(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:tn,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new Q(c)}static createAccountWithSeed(e){let t=new K;t.add(ge.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static createAccount(e){let t=new K;t.add(ge.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static delegate(e){let{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,o=it.Delegate,i=q(o);return new K().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:ss,isSigner:!1,isWritable:!1},{pubkey:qf,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){let{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:o,custodianPubkey:i}=e,a=it.Authorize,c=q(a,{newAuthorized:H(r.toBuffer()),stakeAuthorizationType:o.index}),h=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&h.push({pubkey:i,isSigner:!0,isWritable:!1}),new K().add({keys:h,programId:this.programId,data:c})}static authorizeWithSeed(e){let{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,h=it.AuthorizeWithSeed,d=q(h,{newAuthorized:H(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:r,authorityOwner:H(o.toBuffer())}),w=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1}];return c&&w.push({pubkey:c,isSigner:!0,isWritable:!1}),new K().add({keys:w,programId:this.programId,data:d})}static splitInstruction(e){let{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:o}=e,i=it.Split,a=q(i,{lamports:o});return new Q({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){let n=new K;return n.add(ge.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){let{stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,h=new K;return h.add(ge.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&h.add(ge.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),h.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,lamports:c}))}static merge(e){let{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,o=it.Merge,i=q(o);return new K().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:ss,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){let{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:o,custodianPubkey:i}=e,a=it.Withdraw,c=q(a,{lamports:o}),h=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:ss,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&h.push({pubkey:i,isSigner:!0,isWritable:!1}),new K().add({keys:h,programId:this.programId,data:c})}static deactivate(e){let{stakePubkey:t,authorizedPubkey:n}=e,r=it.Deactivate,o=q(r);return new K().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}};cr.programId=new L("Stake11111111111111111111111111111111111111");cr.space=200;var en=Object.freeze({InitializeAccount:{index:0,layout:u.struct([u.u32("instruction"),ch()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),$("newAuthorized"),u.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:u.struct([u.u32("instruction"),uh()])}}),f_=Object.freeze({Voter:{index:0},Withdrawer:{index:1}}),ur=class s{constructor(){}static initializeAccount(e){let{votePubkey:t,nodePubkey:n,voteInit:r}=e,o=en.InitializeAccount,i=q(o,{voteInit:{nodePubkey:H(r.nodePubkey.toBuffer()),authorizedVoter:H(r.authorizedVoter.toBuffer()),authorizedWithdrawer:H(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:tn,isSigner:!1,isWritable:!1},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new Q(a)}static createAccount(e){let t=new K;return t.add(ge.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){let{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:o}=e,i=en.Authorize,a=q(i,{newAuthorized:H(r.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new K().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){let{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=en.AuthorizeWithSeed,h=q(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:H(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:H(o.toBuffer()),voteAuthorizationType:i.index}}),d=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:Je,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new K().add({keys:d,programId:this.programId,data:h})}static withdraw(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:o}=e,i=en.Withdraw,a=q(i,{lamports:r}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new K().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return s.withdraw(e)}static updateValidatorIdentity(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:r}=e,o=en.UpdateValidatorIdentity,i=q(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new K().add({keys:a,programId:this.programId,data:i})}};ur.programId=new L("Vote111111111111111111111111111111111111111");ur.space=3762;var p_=new L("Va1idator1nfo111111111111111111111111111111"),g_=R({name:b(),website:D(b()),details:D(b()),iconUrl:D(b()),keybaseUsername:D(b())});var __=new L("Vote111111111111111111111111111111111111111"),y_=u.struct([$("nodePubkey"),$("authorizedWithdrawer"),u.u8("commission"),u.nu64(),u.seq(u.struct([u.nu64("slot"),u.u32("confirmationCount")]),u.offset(u.u32(),-8),"votes"),u.u8("rootSlotValid"),u.nu64("rootSlot"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),$("authorizedVoter")]),u.offset(u.u32(),-8),"authorizedVoters"),u.struct([u.seq(u.struct([$("authorizedPubkey"),u.nu64("epochOfLastAuthorizedSwitch"),u.nu64("targetEpoch")]),32,"buf"),u.nu64("idx"),u.u8("isEmpty")],"priorVoters"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),u.nu64("credits"),u.nu64("prevCredits")]),u.offset(u.u32(),-8),"epochCredits"),u.struct([u.nu64("slot"),u.nu64("timestamp")],"lastTimestamp")]);var Mi=1e9;var Oe={UNIVERSAL_PROVIDER_RELAY_URL:"wss://relay.walletconnect.org",HASH_PREFIX:"SPL Name Service",ROOT_DOMAIN_ACCOUNT:new L("58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx"),NAME_PROGRAM_ID:new L("namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"),REVERSE_LOOKUP_CLASS:new L("33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z"),DEFAULT_CHAIN:{id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",chainNamespace:ee.CHAIN.SOLANA,nativeCurrency:{name:"Solana",decimals:9,symbol:"SOL"},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},rpcUrls:{default:{http:[`${ee.BLOCKCHAIN_API_RPC_URL}/v1`]}}},CHAIN_IDS:{Mainnet:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",Devnet:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",Testnet:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",Deprecated_Mainnet:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",Deprecated_Devnet:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"},LAMPORTS_PER_SOL:1e9};p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();function Qe(s){return{formatters:void 0,fees:void 0,serializers:void 0,...s}}var St=Qe({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"});p();_();g();var on=Qe({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"});p();_();g();var zi=Qe({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"});p();_();g();var _y=Qe({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}}),yy=Qe({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0});var Gf={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},an={getMethodsByChainNamespace(s){return Gf[s]||[]},createDefaultNamespace(s){return{methods:this.getMethodsByChainNamespace(s),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(s,e){if(!e)return{...s};let t={...s},n=new Set;if(e.methods&&Object.keys(e.methods).forEach(r=>n.add(r)),e.chains&&Object.keys(e.chains).forEach(r=>n.add(r)),e.events&&Object.keys(e.events).forEach(r=>n.add(r)),e.rpcMap&&Object.keys(e.rpcMap).forEach(r=>{let[o]=r.split(":");o&&n.add(o)}),n.forEach(r=>{t[r]||(t[r]=this.createDefaultNamespace(r))}),e.methods&&Object.entries(e.methods).forEach(([r,o])=>{t[r]&&(t[r].methods=o)}),e.chains&&Object.entries(e.chains).forEach(([r,o])=>{t[r]&&(t[r].chains=o)}),e.events&&Object.entries(e.events).forEach(([r,o])=>{t[r]&&(t[r].events=o)}),e.rpcMap){let r=new Set;Object.entries(e.rpcMap).forEach(([o,i])=>{let[a,c]=o.split(":");!a||!c||!t[a]||(t[a].rpcMap||(t[a].rpcMap={}),r.has(a)||(t[a].rpcMap={},r.add(a)),t[a].rpcMap[c]=i)})}return t},createNamespaces(s,e){let t=s.reduce((n,r)=>{let{id:o,chainNamespace:i,rpcUrls:a}=r,c=a.default.http[0];n[i]||(n[i]=this.createDefaultNamespace(i));let h=`${i}:${o}`,d=n[i];switch(d.chains.push(h),h){case St.caipNetworkId:d.chains.push(St.deprecatedCaipNetworkId);break;case on.caipNetworkId:d.chains.push(on.deprecatedCaipNetworkId);break;default:}return d?.rpcMap&&c&&(d.rpcMap[o]=c),n},{});return this.applyNamespaceOverrides(t,e)},resolveReownName:async s=>{let e=await co.resolveName(s);return(Object.values(e?.addresses)||[])[0]?.address||!1},getChainsFromNamespaces(s={}){return Object.values(s).flatMap(e=>{let t=e.chains||[],n=e.accounts.map(r=>{let[o,i]=r.split(":");return`${o}:${i}`});return Array.from(new Set([...t,...n]))})},isSessionEventData(s){return typeof s=="object"&&s!==null&&"id"in s&&"topic"in s&&"params"in s&&typeof s.params=="object"&&s.params!==null&&"chainId"in s.params&&"event"in s.params&&typeof s.params.event=="object"&&s.params.event!==null},isOriginAllowed(s,e,t){for(let n of[...e,...t])if(n.includes("*")){let o=`^${n.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&").replace(/\\\*/gu,".*")}$`;if(new RegExp(o,"u").test(s))return!0}else try{if(new URL(n).origin===s)return!0}catch{if(n===s)return!0}return!1}};p();_();g();var bt=class{constructor({provider:e,namespace:t}){this.id=ee.CONNECTOR_ID.WALLET_CONNECT,this.name=ke.ConnectorNamesMap[ee.CONNECTOR_ID.WALLET_CONNECT],this.type="WALLET_CONNECT",this.imageId=ke.ConnectorImageIds[ee.CONNECTOR_ID.WALLET_CONNECT],this.getCaipNetworks=je.getCaipNetworks.bind(je),this.caipNetworks=this.getCaipNetworks(),this.provider=e,this.chain=t}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){let t=this.getCaipNetworks(),n=io.state.universalProviderConfigOverride,r=an.createNamespaces(t,n);await this.provider.connect({optionalNamespaces:r})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){let e=this.chains.map(t=>t.caipNetworkId);return uo.universalProviderAuthenticate({universalProvider:this.provider,chains:e,methods:jf})}},jf=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"];var zt=class{constructor(e){this.availableConnectors=[],this.eventListeners=new Map,this.getCaipNetworks=t=>je.getCaipNetworks(t),e&&this.construct(e)}construct(e){this.projectId=e.projectId,this.namespace=e.namespace,this.adapterType=e.adapterType}get connectors(){return this.availableConnectors}get networks(){return this.getCaipNetworks(this.namespace)}setAuthProvider(e){this.addConnector({id:ee.CONNECTOR_ID.AUTH,type:"AUTH",name:ee.CONNECTOR_NAMES.AUTH,provider:e,imageId:ke.ConnectorImageIds[ee.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}addConnector(...e){let t=new Set;this.availableConnectors=[...e,...this.availableConnectors].filter(n=>t.has(n.id)?!1:(t.add(n.id),!0)),this.emit("connectors",this.availableConnectors)}setStatus(e,t){Kt.setStatus(e,t)}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e)?.add(t)}off(e,t){let n=this.eventListeners.get(e);n&&n.delete(t)}removeAllEventListeners(){this.eventListeners.forEach(e=>{e.clear()})}emit(e,t){let n=this.eventListeners.get(e);n&&n.forEach(r=>r(t))}async connectWalletConnect(e){return{clientId:(await this.getWalletConnectConnector().connectWalletConnect()).clientId}}async switchNetwork(e){let{caipNetwork:t,providerType:n}=e;if(!e.provider)return;let r="provider"in e.provider?e.provider.provider:e.provider;if(n==="WALLET_CONNECT"){r.setDefaultChain(t.caipNetworkId);return}if(r&&n==="AUTH"){let o=r,i=Kt.state.preferredAccountTypes?.[t.chainNamespace];await o.switchNetwork(t.caipNetworkId);let a=await o.getUser({chainId:t.caipNetworkId,preferredAccountType:i});this.emit("switchNetwork",a)}}getWalletConnectConnector(){let e=this.connectors.find(t=>t instanceof bt);if(!e)throw new Error("WalletConnectConnector not found");return e}};p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();p();_();g();var Ft=class extends Error{constructor(e,t){super(e),this.error=t}};var hr=class extends Ft{constructor(){super(...arguments),this.name="WalletAccountError"}};var fr=class extends Ft{constructor(){super(...arguments),this.name="WalletSendTransactionError"}},cn=class extends Ft{constructor(){super(...arguments),this.name="WalletSignTransactionError"}},pr=class extends Ft{constructor(){super(...arguments),this.name="WalletSignMessageError"}};p();_();g();function He(s){return"version"in s}p();_();g();p();_();g();var gr="solana:signAndSendTransaction";p();_();g();var Fi="solana:signMessage";p();_();g();var un="solana:signTransaction";p();_();g();var _r="standard:connect";p();_();g();var Wi="standard:disconnect";p();_();g();var yr="standard:events";function Ki(s){return _r in s.features&&yr in s.features&&(gr in s.features||un in s.features)}p();_();g();function $i(s){if(typeof s=="string")return`solana:${s}`}p();_();g();var qe=class{constructor(){this.listeners={accountsChanged:[],chainChanged:[],connect:[],disconnect:[],pendingTransaction:[],auth_rpcRequest:[],auth_rpcSuccess:[],auth_rpcError:[]}}on(e,t){this.listeners[e].push(t)}removeListener(e,t){this.listeners[e]=this.listeners[e].filter(n=>n!==t)}emit(e,t){this.listeners[e].forEach(n=>n(t))}};var mr=class extends qe{constructor(e){super(),this.id=ee.CONNECTOR_ID.AUTH,this.name=ee.CONNECTOR_NAMES.AUTH,this.type="AUTH",this.chain=ee.CHAIN.SOLANA,this.provider=e.w3mFrameProvider,this.requestedChains=e.chains,this.getActiveChain=e.getActiveChain}get publicKey(){let e=this.provider.user?.address;return e?new L(e):void 0}get chains(){let e=this.provider.getAvailableChainIds();return this.requestedChains.filter(t=>e.includes(t.caipNetworkId))}async connect(e={}){let t=e.chainId||this.getActiveChain()?.id,n=Kt.state.preferredAccountTypes?.solana;if(await this.provider.connect({chainId:$i(t),socialUri:e.socialUri,preferredAccountType:n}),!this.publicKey)throw new Error("Failed to connect to the wallet");return this.emit("connect",this.publicKey),this.publicKey.toBase58()}async disconnect(){await this.provider.disconnect(),this.emit("disconnect",void 0)}async signMessage(e){if(!this.publicKey)throw new Error("Wallet not connected");let t=await this.provider.request({method:"solana_signMessage",params:{message:fe.encode(e),pubkey:this.publicKey.toBase58()}});return fe.decode(t.signature)}async signTransaction(e){let t=await this.provider.request({method:"solana_signTransaction",params:{transaction:this.serializeTransaction(e)}}),n=fe.decode(t.transaction);return He(e)?De.deserialize(n):K.from(n)}async signAndSendTransaction(e,t){let n=this.serializeTransaction(e);return(await this.provider.request({method:"solana_signAndSendTransaction",params:{transaction:n,options:t}})).signature}async sendTransaction(e,t,n){let r=await this.signTransaction(e);return await t.sendRawTransaction(r.serialize(),n)}async signAllTransactions(e){return(await this.provider.request({method:"solana_signAllTransactions",params:{transactions:e.map(n=>this.serializeTransaction(n))}})).transactions.map((n,r)=>{let o=e[r];if(!o)throw new Error("Invalid solana_signAllTransactions response");let i=fe.decode(n);return He(o)?De.deserialize(i):K.from(i)})}async request(e){return this.provider.request({method:e.method,params:e.params})}async getAccounts(){return this.publicKey?Promise.resolve([{namespace:this.chain,address:this.publicKey.toBase58(),type:"eoa"}]):Promise.resolve([])}serializeTransaction(e){return fe.encode(new Uint8Array(e.serialize({verifySignatures:!1})))}};p();_();g();p();_();g();var Ar=class extends qe{constructor(e){super(),this.name="Coinbase Wallet",this.id=ke.ConnectorExplorerIds[ee.CONNECTOR_ID.COINBASE_SDK]||this.name,this.explorerId=ke.ConnectorExplorerIds[ee.CONNECTOR_ID.COINBASE_SDK],this.type="ANNOUNCED",this.imageUrl="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",this.chain=ee.CHAIN.SOLANA,this.provider=this,this.coinbase=e.provider,this.requestedChains=e.chains}get chains(){return this.requestedChains.filter(e=>e.id===St.id)}get publicKey(){return this.coinbase.publicKey}get imageId(){return ke.ConnectorImageIds[ee.CONNECTOR_ID.COINBASE]}async connect(){try{await this.coinbase.connect();let e=this.getAccount(!0);return this.coinbase.emit("connect",this.coinbase.publicKey),this.emit("connect",e),e.toBase58()}catch(e){throw this.coinbase.emit("error",e),e}}async disconnect(){await this.coinbase.disconnect(),this.coinbase.emit("disconnect",void 0),this.emit("disconnect",void 0)}async signMessage(e){return(await this.coinbase.signMessage(e)).signature}async signTransaction(e){return this.coinbase.signTransaction(e)}async signAndSendTransaction(e,t){return(await this.coinbase.signAndSendTransaction(e,t)).signature}async sendTransaction(e,t,n){let r=await this.signTransaction(e);return await t.sendRawTransaction(r.serialize(),n)}async signAllTransactions(e){return await this.coinbase.signAllTransactions(e)}async request(e){return Promise.reject(new Error('The "request" method is not supported on Coinbase Wallet'))}async getAccounts(){let e=this.getAccount();return e?Promise.resolve([{namespace:this.chain,address:e.toBase58(),type:"eoa"}]):Promise.resolve([])}getAccount(e){let t=this.coinbase.publicKey;if(e&&!t)throw new Error("Not connected");return t}};p();_();g();p();_();g();p();_();g();p();_();g();var dn=class extends Error{constructor(e){super(`The wallet does not support the "${e}" feature`)}},ln=class extends Error{constructor(e){super(`The method "${e}" is not supported by the wallet`)}};var hn=class extends bt{constructor({provider:e,chains:t,getActiveChain:n}){super({caipNetworks:t,namespace:"solana",provider:e}),this.eventEmitter=new qe,this.emit=this.eventEmitter.emit.bind(this.eventEmitter),this.on=this.eventEmitter.on.bind(this.eventEmitter),this.removeListener=this.eventEmitter.removeListener.bind(this.eventEmitter),this.getActiveChain=n}get session(){return this.provider.session}get chains(){return this.sessionChains.map(e=>{let t=e;return t===Oe.CHAIN_IDS.Deprecated_Mainnet?t=Oe.CHAIN_IDS.Mainnet:t===Oe.CHAIN_IDS.Deprecated_Devnet&&(t=Oe.CHAIN_IDS.Devnet),this.caipNetworks.find(n=>n.caipNetworkId===t)}).filter(Boolean)}get publicKey(){let e=this.getAccount(!1);if(e)return new L(e.publicKey)}async connect(){await super.connectWalletConnect();let e=this.getAccount(!0);return this.emit("connect",new L(e.publicKey)),e.address}async disconnect(){await super.disconnect(),this.emit("disconnect",void 0)}async signMessage(e){this.checkIfMethodIsSupported("solana_signMessage");let t=await this.internalRequest("solana_signMessage",{message:fe.encode(e),pubkey:this.getAccount(!0).address});return fe.decode(t.signature)}async signTransaction(e){this.checkIfMethodIsSupported("solana_signTransaction");let t=this.serializeTransaction(e),n=await this.internalRequest("solana_signTransaction",{transaction:t,pubkey:this.getAccount(!0).address,...this.getRawRPCParams(e)});if("signature"in n){let o=fe.decode(n.signature);return e.addSignature(new L(this.getAccount(!0).publicKey),y.from(o)),e}let r=y.from(n.transaction,"base64");return He(e)?De.deserialize(new Uint8Array(r)):K.from(r)}async signAndSendTransaction(e,t){this.checkIfMethodIsSupported("solana_signAndSendTransaction");let n=this.serializeTransaction(e),r=await this.internalRequest("solana_signAndSendTransaction",{transaction:n,pubkey:this.getAccount(!0).address,sendOptions:t});return this.emit("pendingTransaction",void 0),r.signature}async sendTransaction(e,t,n){let r=await this.signTransaction(e),o=await t.sendRawTransaction(r.serialize(),n);return this.emit("pendingTransaction",void 0),o}async signAllTransactions(e){try{return this.checkIfMethodIsSupported("solana_signAllTransactions"),(await this.internalRequest("solana_signAllTransactions",{transactions:e.map(n=>this.serializeTransaction(n))})).transactions.map((n,r)=>{let o=e[r];if(!o)throw new Error("Invalid transactions response");let i=y.from(n,"base64");return He(o)?De.deserialize(new Uint8Array(i)):(this.emit("pendingTransaction",void 0),K.from(i))})}catch(t){if(t instanceof ln){let n=[];for(let r of e)n.push(await this.signTransaction(r));return n}throw t}}request(e){return this.internalRequest(e.method,e.params)}async getAccounts(){let e=this.session?.namespaces.solana?.accounts||[];return Promise.resolve(e.map(t=>({namespace:this.chain,address:so.parseCaipAddress(t).address,type:"eoa"})))}internalRequest(e,t){let r=this.chains.find(o=>this.getActiveChain()?.id===o.id)?.caipNetworkId;switch(r){case Oe.CHAIN_IDS.Mainnet:this.sessionChains.includes(Oe.CHAIN_IDS.Mainnet)||(r=Oe.CHAIN_IDS.Deprecated_Mainnet);break;case Oe.CHAIN_IDS.Devnet:this.sessionChains.includes(Oe.CHAIN_IDS.Devnet)||(r=Oe.CHAIN_IDS.Deprecated_Devnet);break;default:break}return this.provider?.request({method:e,params:t},r)}get sessionChains(){return an.getChainsFromNamespaces(this.session?.namespaces)}serializeTransaction(e){return y.from(new Uint8Array(e.serialize({verifySignatures:!1}))).toString("base64")}getAccount(e){let t=this.session?.namespaces.solana?.accounts[0];if(!t){if(e)throw new Error("Account not found");return}let n=t.split(":")[2];if(!n){if(e)throw new Error("Address not found");return}return{address:n,publicKey:fe.decode(n)}}getRawRPCParams(e){return He(e)?{}:{feePayer:e.feePayer?.toBase58()??"",instructions:e.instructions.map(t=>({data:fe.encode(new Uint8Array(t.data)),keys:t.keys.map(n=>({isWritable:n.isWritable,isSigner:n.isSigner,pubkey:n.pubkey.toBase58()})),programId:t.programId.toBase58()})),recentBlockhash:e.recentBlockhash??""}}checkIfMethodIsSupported(e){if(!this.session?.namespaces.solana?.methods.includes(e))throw new ln(e)}};p();_();g();var Vi={UNIT_PRICE_MICRO_LAMPORTS:2e7,UNIT_LIMIT:500};async function ks({provider:s,to:e,value:t,connection:n}){if(!s.publicKey)throw Error("No public key found");let r=new L(e),o=Math.floor(t*Mi),{blockhash:i,lastValidBlockHeight:a}=await n.getLatestBlockhash(),c=[Ut.setComputeUnitPrice({microLamports:Vi.UNIT_PRICE_MICRO_LAMPORTS}),Ut.setComputeUnitLimit({units:Vi.UNIT_LIMIT}),ge.transfer({fromPubkey:s.publicKey,toPubkey:r,lamports:o})];return new K({feePayer:s.publicKey,blockhash:i,lastValidBlockHeight:a}).add(...c)}p();_();g();p();_();g();var Xf=function(s,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?s!==e||!n:!e.has(s))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(s):n?n.value:e.get(s)},Jf=function(s,e,t,n,r){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!r)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?s!==e||!r:!e.has(s))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?r.call(s,t):r?r.value=t:e.set(s,t),t},Rr,fn,Er=new Set;function Zf(s){pn=void 0,Er.add(s)}function Qf(s){pn=void 0,Er.delete(s)}var Wt={};function Gi(){if(fn||(fn=Object.freeze({register:Hi,get:ep,on:tp}),typeof window>"u"))return fn;let s=Object.freeze({register:Hi});try{window.addEventListener("wallet-standard:register-wallet",({detail:e})=>e(s))}catch(e){console.error(`wallet-standard:register-wallet event listener could not be added
`,e)}try{window.dispatchEvent(new vs(s))}catch(e){console.error(`wallet-standard:app-ready event could not be dispatched
`,e)}return fn}function Hi(...s){return s=s.filter(e=>!Er.has(e)),s.length?(s.forEach(e=>Zf(e)),Wt.register?.forEach(e=>qi(()=>e(...s))),function(){s.forEach(t=>Qf(t)),Wt.unregister?.forEach(t=>qi(()=>t(...s)))}):()=>{}}var pn;function ep(){return pn||(pn=[...Er]),pn}function tp(s,e){return Wt[s]?.push(e)||(Wt[s]=[e]),function(){Wt[s]=Wt[s]?.filter(n=>e!==n)}}function qi(s){try{s()}catch(e){console.error(e)}}var vs=class extends Event{get detail(){return Xf(this,Rr,"f")}get type(){return"wallet-standard:app-ready"}constructor(e){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),Rr.set(this,void 0),Jf(this,Rr,e,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}};Rr=new WeakMap;p();_();g();p();_();g();function ji(s){switch(s){case"processed":case"confirmed":case"finalized":case void 0:return s;case"recent":return"processed";case"single":case"singleGossip":return"confirmed";case"max":case"root":return"finalized";default:return}}p();_();g();var Ls={"solana:mainnet":St,"solana:testnet":zi,"solana:devnet":on};var wr=class extends qe{constructor({wallet:e,getActiveChain:t,requestedChains:n}){super(),this.chain=ee.CHAIN.SOLANA,this.provider=this,this.wallet=e,this.getActiveChain=t,this.requestedChains=n,this.bindEvents()}get id(){let e=this.name;return ke.ConnectorExplorerIds[e]||e}get name(){return this.wallet.name==="Trust"?"Trust Wallet":this.wallet.name}get type(){return"ANNOUNCED"}get explorerId(){return ke.ConnectorExplorerIds[this.name]}get publicKey(){let e=this.getAccount(!1);if(e)return new L(e.publicKey)}get imageUrl(){return this.wallet.icon}get chains(){return this.wallet.chains.map(e=>this.requestedChains.find(t=>t.id===e||t.id===Ls[e]?.id)).filter(Boolean)}async connect(){await this.getWalletFeature(_r).connect();let t=this.getAccount(!0),n=new L(t.publicKey);return this.emit("connect",n),t.address}async disconnect(){await this.getWalletFeature(Wi).disconnect(),this.emit("disconnect",void 0)}async signMessage(e){let t=this.getWalletFeature(Fi),n=this.getAccount(!0),[r]=await t.signMessage({message:e,account:n});if(!r)throw new pr("Empty result");return r.signature}async signTransaction(e){let t=this.getWalletFeature(un),n=this.getAccount(!0),r=this.serializeTransaction(e),[o]=await t.signTransaction({account:n,transaction:new Uint8Array(r),chain:this.getActiveChainName()});if(!o)throw new cn("Empty result");return this.emit("pendingTransaction",void 0),He(e)?De.deserialize(o.signedTransaction):K.from(o.signedTransaction)}async signAndSendTransaction(e,t){let n=this.getWalletFeature(gr),r=this.getAccount(!0),[o]=await n.signAndSendTransaction({account:r,transaction:new Uint8Array(this.serializeTransaction(e)),options:{...t,preflightCommitment:ji(t?.preflightCommitment)},chain:this.getActiveChainName()});if(!o)throw new fr("Empty result");return this.emit("pendingTransaction",void 0),fe.encode(o.signature)}async sendTransaction(e,t,n){let r=await this.signTransaction(e);return await t.sendRawTransaction(r.serialize(),n)}async signAllTransactions(e){let t=this.getWalletFeature(un),n=this.getAccount(!0),r=this.getActiveChainName();return(await t.signTransaction(...e.map(i=>({transaction:new Uint8Array(this.serializeTransaction(i)),account:n,chain:r})))).map(({signedTransaction:i},a)=>{let c=e[a];if(!c)throw new cn("Invalid transaction signature response");return this.emit("pendingTransaction",void 0),He(c)?De.deserialize(i):K.from(i)})}async request(e){return Promise.reject(new dn("request"))}async getAccounts(){return Promise.resolve(this.wallet.accounts.map(e=>({namespace:this.chain,address:e.address,type:"eoa"})))}serializeTransaction(e){return e.serialize({verifySignatures:!1})}getAccount(e){let t=this.wallet.accounts[0];if(e&&!t)throw new hr;return t}getWalletFeature(e){if(!(e in this.wallet.features))throw new dn(e);return this.wallet.features[e]}getActiveChainName(){let e=Object.entries(Ls).find(([,t])=>t.id===this.getActiveChain()?.id);if(!e)throw new Error("Invalid chain id");return e[0]}bindEvents(){this.getWalletFeature(yr).on("change",t=>{if(t.accounts){let n=t.accounts[0];n&&this.emit("accountsChanged",new L(n.publicKey))}})}};var{get:np,on:Yi}=Gi(),dt=[];function Ji(s,e,t){let n=[Yi("register",(...r)=>{dt=[...dt,...Xi(r,s,e)],t(...dt)}),Yi("unregister",(...r)=>{dt=dt.filter(o=>r.some(i=>i.name===o.wallet.name)),t(...dt)})];return dt=Xi(np(),s,e),t(...dt),()=>n.forEach(r=>r())}function Xi(s,e,t){return s.filter(Ki).map(n=>new wr({wallet:n,requestedChains:e,getActiveChain:t}))}var gn=class extends zt{constructor(e={}){super({adapterType:ee.ADAPTER_TYPES.SOLANA,namespace:ee.CHAIN.SOLANA}),this.balancePromises={},this.providerHandlers=null,this.connectionSettings=e.connectionSettings||"confirmed",this.wallets=e.wallets}construct(e){super.construct(e);let t=En.getActiveCaipNetworkId(),r=(e.networks?.find(o=>o.caipNetworkId===t)||e.networks?.[0])?.rpcUrls.default.http[0];r&&ht.setConnection(new ut(r,this.connectionSettings))}setAuthProvider(e){this.addConnector(new mr({w3mFrameProvider:e,getActiveChain:()=>je.getCaipNetworkByNamespace(this.namespace),chains:this.getCaipNetworks()}))}syncConnectors(e,t){e.projectId||ao.open(lo.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,"error");let n=()=>t.getCaipNetwork(this.namespace);oo.isClient()&&"coinbaseSolana"in window&&this.addConnector(new Ar({provider:window.coinbaseSolana,chains:this.getCaipNetworks(),getActiveChain:n})),Ji(this.getCaipNetworks(),n,this.addConnector.bind(this))}async writeContract(){return Promise.resolve({hash:""})}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async walletGetAssets(e){return Promise.resolve({})}async getAccounts(e){let t=this.connectors.find(n=>n.id===e.id);return t?{accounts:await t.getAccounts()}:{accounts:[]}}async signMessage(e){let t=e.provider;if(!t)throw new Error("connectionControllerClient:signMessage - provider is undefined");let n=await t.signMessage(new TextEncoder().encode(e.message));return{signature:fe.encode(n)}}async estimateGas(e){let t=ht.state.connection;if(!t||!e.provider)throw new Error("Connection is not set");let r=await(await ks({provider:e.provider,connection:t,to:"11111111111111111111111111111111",value:1})).getEstimatedFee(t);return{gas:BigInt(r||0)}}async sendTransaction(e){let t=ht.state.connection;if(!t||!e.provider)throw new Error("Connection is not set");let n=e.provider,r=await ks({provider:n,connection:t,to:e.to,value:Number.isNaN(Number(e.value))?0:Number(e.value)}),o=await n.sendTransaction(r,t);return await new Promise(i=>{let a=setInterval(async()=>{(await t.getSignatureStatus(o))?.value&&(clearInterval(a),i())},1e3)}),{hash:o}}parseUnits(){return 0n}formatUnits(){return""}async connect(e){let t=this.connectors.find(o=>o.id===e.id);if(!t)throw new Error("Provider not found");let n=e.rpcUrl||this.getCaipNetworks()?.find(o=>o.id===e.chainId)?.rpcUrls.default.http[0];if(!n)throw new Error(`RPC URL not found for chainId: ${e.chainId}`);let r=await t.connect({chainId:e.chainId,socialUri:e.socialUri});return this.listenProviderEvents(t),ht.setConnection(new ut(n,this.connectionSettings)),this.emit("accountChanged",{address:r,chainId:e.chainId}),{id:t.id,address:r,chainId:e.chainId,provider:t,type:t.type}}async getBalance(e){let t=e.address,n=this.getCaipNetworks()?.find(c=>c.id===e.chainId);if(!t)return Promise.resolve({balance:"0.00",symbol:"SOL"});let r=new ut(n?.rpcUrls?.default?.http?.[0],this.connectionSettings),o=`${n?.caipNetworkId}:${e.address}`,i=this.balancePromises[o];if(i)return i;let a=En.getNativeBalanceCacheForCaipAddress(o);return a?{balance:a.balance,symbol:a.symbol}:(this.balancePromises[o]=new Promise(async c=>{try{let d=(await r.getBalance(new L(t))/Oe.LAMPORTS_PER_SOL).toString();if(En.updateNativeBalanceCache({caipAddress:o,balance:d,symbol:e.caipNetwork?.nativeCurrency.symbol||"SOL",timestamp:Date.now()}),!e.caipNetwork)throw new Error("caipNetwork is required");c({balance:d,symbol:e.caipNetwork?.nativeCurrency.symbol})}catch{c({balance:"0.00",symbol:"SOL"})}}).finally(()=>{delete this.balancePromises[o]}),this.balancePromises[o]||{balance:"0.00",symbol:"SOL"})}async switchNetwork(e){await super.switchNetwork(e);let{caipNetwork:t}=e;t?.rpcUrls?.default?.http?.[0]&&ht.setConnection(new ut(t.rpcUrls.default.http[0],this.connectionSettings))}listenProviderEvents(e){let t=()=>{this.removeProviderListeners(e),this.emit("disconnect")},n=r=>{let o=r.toBase58();o&&this.emit("accountChanged",{address:o})};e.on("disconnect",t),e.on("accountsChanged",n),e.on("connect",n),e.on("pendingTransaction",()=>{this.emit("pendingTransactions")}),this.providerHandlers={disconnect:t,accountsChanged:n}}removeProviderListeners(e){this.providerHandlers&&(e.removeListener("disconnect",this.providerHandlers.disconnect),e.removeListener("accountsChanged",this.providerHandlers.accountsChanged),e.removeListener("connect",this.providerHandlers.accountsChanged),this.providerHandlers=null)}setUniversalProvider(e){this.addConnector(new hn({provider:e,chains:this.getCaipNetworks(),getActiveChain:()=>je.getCaipNetworkByNamespace(this.namespace)}))}async connectWalletConnect(e){let t=await super.connectWalletConnect(e),n=this.getCaipNetworks()?.find(o=>o.id===e)?.rpcUrls.default.http[0],r=new ut(n,this.connectionSettings);return ht.setConnection(r),t}async disconnect(e){if(!e.provider||!e.providerType)throw new Error("Provider or providerType not provided");await e.provider.disconnect()}async syncConnection(e){return this.connect({...e,type:""})}getWalletConnectProvider(e){return new hn({provider:e.provider,chains:e.caipNetworks,getActiveChain:()=>je.getCaipNetworkByNamespace(this.namespace)})}};var Sr=tt(Us(),1);var rp=new Zs,sp=new gn,op="939345e3a30974b284f27b6a7918736f",ip={name:"Intear Wallet",description:"Intear Wallet",url:"https://wallet.intear.tech",icons:["/favicon.svg"]};Js({adapters:[sp],networks:[Ys],projectId:op,metadata:ip,features:{analytics:!1,socials:!1,onramp:!1,swaps:!1,receive:!1,send:!1,email:!1},themeMode:"dark"});function ap({children:s}){return Me.default.createElement(Qs,{client:rp},s)}function cp({messageToSign:s,onSignature:e}){let t=xr({namespace:"solana"}),{open:n,close:r}=Br(),{walletProvider:o}=Xs("solana"),[i,a]=(0,Me.useState)(!1);return(0,Sr.useEffect)(()=>{let c=async()=>{if(t.isConnected&&s&&o)try{let h=new TextEncoder().encode(s),d=await o.signMessage(h);e(d,s,t.address||null),o.disconnect(),r(),a(!1)}catch(h){console.error("Signing error:",h),e(null,s,null),o.disconnect(),r(),a(!1)}};if(t.isConnected&&s&&!i&&(a(!0),c()),!t.isConnected&&s){n({view:"Connect"});let h=!1,d=setInterval(()=>{let w=document.getElementsByTagName("w3m-modal")[0];w&&w.className==="open"?h=!0:h&&(clearInterval(d),e(null,s,null),o.disconnect(),r())},50);return()=>clearInterval(d)}},[t.isConnected,s,o,e,n,i]),Me.default.createElement(Me.default.Fragment,null)}function up({onConnection:s}){let e=xr({namespace:"solana"}),{open:t,close:n}=Br();return(0,Sr.useEffect)(()=>{if(e.isConnected&&e.address){let r=e.address;s(r),n()}},[e.isConnected,e.address,s,n]),(0,Sr.useEffect)(()=>{if(!e.isConnected){t({view:"Connect"});let r=!1,o=setInterval(()=>{let i=document.getElementsByTagName("w3m-modal")[0];i&&i.className==="open"?r=!0:r&&(clearInterval(o),s(null))},50);return()=>clearInterval(o)}},[e.isConnected,s,t]),Me.default.createElement(Me.default.Fragment,null)}function dp({messageToSign:s,onSignature:e,needsSignIn:t,onConnection:n}){return Me.default.createElement(ap,null,s&&Me.default.createElement(cp,{messageToSign:s,onSignature:e}),t&&Me.default.createElement(up,{onConnection:n}))}export{dp as default};
/*! Bundled license information:

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
