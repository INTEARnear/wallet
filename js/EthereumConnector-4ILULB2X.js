import{a as te,b as ne,c as re,e as oe,f as ve,g as ie,i as se,j as Ie,k as Ke,l as Fe,m as B}from"./chunk-R4QSWZFH.js";import{a as Ee,b as Ne,c as ae,d as D,e as Ae,f as ce,g as be,h as C,i as Te,j as de,k as Pe,l as q,m as ue,n as pe,o as ke,p as Oe,q as Re,r as Se,s as We,t as Qe,u as Ue,w as _e,x as Me}from"./chunk-T5DO3SBA.js";import"./chunk-Z65QX34R.js";import"./chunk-RRN7SHYG.js";import"./chunk-XEUUDCWO.js";import"./chunk-2T2LG5CT.js";import"./chunk-KG5GTMNR.js";import"./chunk-ANQ7QFBQ.js";import"./chunk-ZMTN5ZA6.js";import{b as W,d as v,f as Q}from"./chunk-C76LFVKJ.js";import{G as I,I as ee,b as g,c as R,k as P,l as X,m as we,p as E}from"./chunk-AXPE5NAX.js";import{d as he,h as Ce}from"./chunk-YDPF4UGR.js";import"./chunk-LQBGFF7Y.js";import"./chunk-F3BT2OCD.js";import"./chunk-OIFNSKKM.js";import{F as xe}from"./chunk-YY5EM6U5.js";import"./chunk-LHWHJQRC.js";import{a as T}from"./chunk-AMYL42KT.js";import"./chunk-V7H3HPRQ.js";import"./chunk-EAWY7VYO.js";import"./chunk-JJVWQEYF.js";import{C as F,Q as ye,qa as L,s as Z,va as S}from"./chunk-JGRP444H.js";import"./chunk-URLXKBQX.js";import"./chunk-FFQJ55XB.js";import"./chunk-6K56CBXQ.js";import"./chunk-WGWCH7J2.js";import{f as b}from"./chunk-57YRCRKT.js";var x=b(T(),1);var U=b(T(),1);var H=b(T(),1);function Le(s){let{children:e,config:n,initialState:t,reconnectOnMount:r=!0}=s,{onMount:o}=Me(n,{initialState:t,reconnectOnMount:r});n._internal.ssr||o();let d=(0,H.useRef)(!0);return(0,H.useEffect)(()=>{if(d.current&&n._internal.ssr)return o(),()=>{d.current=!1}},[]),e}var _=(0,U.createContext)(void 0);function G(s){let{children:e,config:n}=s,t={value:n};return(0,U.createElement)(Le,s,(0,U.createElement)(_.Provider,t,e))}var De="2.15.4";var qe=()=>`wagmi@${De}`;var j=class extends Ee{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/react"}get version(){return qe()}};var V=class extends j{constructor(){super("`useConfig` must be used within `WagmiProvider`.",{docsPath:"/api/WagmiProvider"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiProviderNotFoundError"})}};var Be=b(T(),1);function k(s={}){let e=s.config??(0,Be.useContext)(_);if(!e)throw new V;return e}function me(s){return{mutationFn(e){return D(s,e)},mutationKey:["disconnect"]}}function le(s){return{mutationFn(e){return q(s,e)},mutationKey:["signMessage"]}}var He=b(T(),1);function Ge(s={}){let e=k(s);return(0,He.useSyncExternalStore)(n=>Oe(e,{onChange:n}),()=>C(e),()=>C(e))}function $(s={}){let{mutation:e}=s,n=k(s),t=me(n),{mutate:r,mutateAsync:o,...d}=B({...e,...t});return{...d,connectors:Ge({config:n}).map(u=>u.connector),disconnect:r,disconnectAsync:o}}function fe(s={}){let{mutation:e}=s,n=k(s),t=le(n),{mutate:r,mutateAsync:o,...d}=B({...e,...t});return{...d,signMessage:r,signMessageAsync:o}}function je(s){let e=[],n,t;function r(u){return R.parseEvmChainId(u)||1}function o(){return n||(n=ne.getInstance({projectId:s.options.projectId,chainId:I.getActiveCaipNetwork()?.caipNetworkId,enableLogger:s.options.enableAuthLogger,onTimeout:u=>{u==="iframe_load_failed"?E.open(v.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):u==="iframe_request_timeout"?E.open(v.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):u==="unverified_domain"&&E.open(v.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")},abortController:v.EmbeddedWalletAbortController})),n}async function d(u={}){let i=o(),p=u.chainId;if(u.isReconnecting){let h=R.parseEvmChainId(i.getLastUsedChainId()||""),w=s.chains?.[0].id;if(p=h||w,!p)throw new Error("ChainId not found in provider")}let f=ee.state.preferredAccountTypes?.eip155,{address:a,chainId:c,accounts:m}=await i.connect({chainId:p,preferredAccountType:f,socialUri:u.socialUri});e=m?.map(h=>h.address)||[a];let l=r(c);return{accounts:e,account:a,chainId:l,chain:{id:l,unsuported:!1}}}return u=>({id:g.CONNECTOR_ID.AUTH,name:g.CONNECTOR_NAMES.AUTH,type:"AUTH",chain:g.CHAIN.EVM,async connect(i={}){if(t)return t;t||(t=new Promise(f=>{f(d(i))}));let p=await t;return t=void 0,p},async disconnect(){await(await this.getProvider()).disconnect()},getAccounts(){return e?.length?(u.emitter.emit("change",{accounts:e}),Promise.resolve(e)):Promise.resolve([])},async getProvider(){return this.provider||(this.provider=ne.getInstance({projectId:s.options.projectId,chainId:I.getActiveCaipNetwork()?.caipNetworkId,enableLogger:s.options.enableAuthLogger,abortController:v.EmbeddedWalletAbortController,onTimeout:i=>{i==="iframe_load_failed"?E.open(v.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):i==="iframe_request_timeout"?E.open(v.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):i==="unverified_domain"&&E.open(v.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")}})),Promise.resolve(this.provider)},async getChainId(){let i=await this.getProvider(),{chainId:p}=await i.getChainId();return r(p)},async isAuthorized(){let i=await this.getProvider();return Promise.resolve(i.getLoginEmailUsed())},async switchChain({chainId:i}){try{let p=u.chains.find(m=>m.id===i);if(!p)throw new S(new Error("chain not found on connector."));let f=await this.getProvider(),a=ee.state.preferredAccountTypes?.eip155,c=await f.connect({chainId:i,preferredAccountType:a});return e=c?.accounts?.map(m=>m.address)||[c.address],u.emitter.emit("change",{chainId:Number(i),accounts:e}),p}catch(p){throw p instanceof Error?new S(p):p}},onAccountsChanged(i){i.length===0?this.onDisconnect():u.emitter.emit("change",{accounts:i.map(F)})},onChainChanged(i){let p=Number(i);u.emitter.emit("change",{chainId:p})},async onDisconnect(i){await(await this.getProvider()).disconnect()}})}z.type="walletConnect";function z(s,e){let n=s.isNewChainsStale??!0,t,r,o,d,u,i,p;return f=>({id:"walletConnect",name:"WalletConnect",type:z.type,async setup(){let a=await this.getProvider().catch(()=>null);a&&(d||(d=this.onConnect.bind(this),a.on("connect",d)),i||(i=this.onSessionDelete.bind(this),a.on("session_delete",i)))},async connect({...a}={}){try{let c=I.getCaipNetworks(),m=await this.getProvider();if(!m)throw new ue;u||(u=this.onDisplayUri,m.on("display_uri",u));let l=await this.isChainsStale();m.session&&l&&await m.disconnect();let h=we.state.universalProviderConfigOverride;if(!m.session||l){let Y=oe.createNamespaces(c,h);await m.connect({optionalNamespaces:Y,..."pairingTopic"in a?{pairingTopic:a.pairingTopic}:{}}),this.setRequestedChainsIds(c.map(Ye=>Number(Ye.id)))}let w=await this.getAccounts(),y=await this.getChainId(),O=m.session?.namespaces?.eip155?.chains,J=O?.some(Y=>Number(Y.split(":")[1])===y),A=1;J?A=y:O?.[0]&&(A=Number(O[0].split(":")[1])),u&&(m.removeListener("display_uri",u),u=void 0),d&&(m.removeListener("connect",d),d=void 0),r||(r=this.onAccountsChanged.bind(this),m.on("accountsChanged",r)),o||(o=this.onChainChanged.bind(this),m.on("chainChanged",o)),p||(p=this.onDisconnect.bind(this),m.on("disconnect",p)),i||(i=this.onSessionDelete.bind(this),m.on("session_delete",i));let Je=h?.defaultChain;return m.setDefaultChain(Je??`eip155:${A}`),{accounts:w,chainId:A}}catch(c){throw/(user rejected|connection request reset)/i.test(c?.message)?new L(c):c}},async disconnect(){let a=await this.getProvider();try{await a?.disconnect()}catch(c){if(!/No matching key/i.test(c.message))throw c}finally{o&&(a?.removeListener("chainChanged",o),o=void 0),p&&(a?.removeListener("disconnect",p),p=void 0),d||(d=this.onConnect.bind(this),a?.on("connect",d)),r&&(a?.removeListener("accountsChanged",r),r=void 0),i&&(a?.removeListener("session_delete",i),i=void 0),this.setRequestedChainsIds([])}},async getAccounts(){let a=await this.getProvider();return a?.session?.namespaces?a?.session?.namespaces[g.CHAIN.EVM]?.accounts?.map(l=>l.split(":")[2])??[]:[]},async getProvider({chainId:a}={}){t||(t=await e.getUniversalProvider(),t?.events.setMaxListeners(Number.POSITIVE_INFINITY));let c=P.getActiveNamespace(),m=e.getCaipNetwork()?.id;if(a&&m!==a&&c){let l=P.getStoredActiveCaipNetworkId(),w=e.getCaipNetworks(c)?.find(y=>y.id===l);w&&w.chainNamespace===g.CHAIN.EVM&&await this.switchChain?.({chainId:Number(w.id)})}return t},async getChainId(){let a=e.getCaipNetwork(g.CHAIN.EVM)?.id;if(a)return a;let m=(await this.getProvider()).session?.namespaces[g.CHAIN.EVM]?.chains?.[0];return I.getCaipNetworks().find(h=>h.id===m)?.id},async isAuthorized(){try{let[a,c]=await Promise.all([this.getAccounts(),this.getProvider()]);return a.length?await this.isChainsStale()&&c.session?(await c.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:a,chainId:c}){let m=await this.getProvider();if(!m)throw new ue;let l=I.getCaipNetworks().find(h=>h.id===c);if(!l)throw new S(new Ne);try{await m.request({method:"wallet_switchEthereumChain",params:[{chainId:Z(c)}]}),l?.caipNetworkId&&m.setDefaultChain(l?.caipNetworkId),f.emitter.emit("change",{chainId:Number(c)});let h=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...h,c]),{...l,id:l.id}}catch(h){let w=h;if(/(?:user rejected)/iu.test(w.message))throw new L(w);try{let y;a?.blockExplorerUrls?y=a.blockExplorerUrls:y=l.blockExplorers?.default.url?[l.blockExplorers?.default.url]:[];let O=l.rpcUrls?.chainDefault?.http||[],J={blockExplorerUrls:y,chainId:Z(c),chainName:l.name,iconUrls:a?.iconUrls,nativeCurrency:l.nativeCurrency,rpcUrls:O};await m.request({method:"wallet_addEthereumChain",params:[J]});let A=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...A,c]),{...l,id:l.id}}catch(y){throw new L(y)}}},onAccountsChanged(a){a.length===0?this.onDisconnect():f.emitter.emit("change",{accounts:a.map(c=>F(c))})},onChainChanged(a){let c=Number(a);f.emitter.emit("change",{chainId:c})},onConnect(a){this.setRequestedChainsIds(I.getCaipNetworks().map(c=>Number(c.id)))},async onDisconnect(a){this.setRequestedChainsIds([]),f.emitter.emit("disconnect");let c=await this.getProvider();r&&(c.removeListener("accountsChanged",r),r=void 0),o&&(c.removeListener("chainChanged",o),o=void 0),p&&(c.removeListener("disconnect",p),p=void 0),i&&(c.removeListener("session_delete",i),i=void 0),d||(d=this.onConnect.bind(this),c.on("connect",d))},onDisplayUri(a){f.emitter.emit("message",{type:"display_uri",data:a})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){return t?.session?.namespaces?t?.session?.namespaces[g.CHAIN.EVM]?.accounts?.map(m=>Number.parseInt(m.split(":")[1]??""))??[]:[]},async getRequestedChainsIds(){let a=await f.storage?.getItem(this.requestedChainsStorageKey)??[];return[...new Set(a)]},async isChainsStale(){if(!n)return!1;let a=f.chains.map(l=>l.id),c=this.getNamespaceChainsIds();if(c.length&&!c.some(l=>a.includes(l)))return!1;let m=await this.getRequestedChainsIds();return!a.every(l=>m.includes(Number(l)))},async setRequestedChainsIds(a){await f.storage?.setItem(this.requestedChainsStorageKey,a)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}var M=he({pendingTransactions:0}),ge={state:M,subscribeKey(s,e){return Ce(M,s,e)},increase(s){M[s]+=1},decrease(s){M[s]-=1},reset(s){M[s]=0}};function Ve(s){try{return JSON.parse(s)}catch{throw new Error("Error parsing wallet capabilities")}}var Xe={enable:!1,pollingInterval:3e4},K=class extends ie{constructor(e){let n=Q.extendCaipNetworks(e.networks,{projectId:e.projectId,customNetworkImageUrls:{},customRpcUrls:e.customRpcUrls});super(),this.balancePromises={},this.namespace=g.CHAIN.EVM,this.adapterType=g.ADAPTER_TYPES.WAGMI,this.projectId=e.projectId,this.pendingTransactionsFilter={...Xe,...e.pendingTransactionsFilter??{}},this.createConfig({...e,networks:n})}construct(e){this.setupWatchers()}async getAccounts(e){let n=this.getWagmiConnector(e.id);if(!n)return{accounts:[]};if(n.id===g.CONNECTOR_ID.AUTH){let o=await n.getProvider();if(!o?.user)return{accounts:[]};let{address:d,accounts:u}=o.user;return Promise.resolve({accounts:(u||[{address:d,type:"eoa"}]).map(i=>X.createAccount("eip155",i.address,i.type))})}let{addresses:t,address:r}=ce(this.wagmiConfig);return Promise.resolve({accounts:[...new Set(t||[r])].map(o=>X.createAccount("eip155",o||"","eoa"))})}getWagmiConnector(e){return this.wagmiConfig.connectors.find(n=>n.id===e)}createConfig(e){this.wagmiChains=e.networks.filter(r=>r.chainNamespace===g.CHAIN.EVM);let n={},t=[...e.connectors??[]];this.wagmiChains.forEach(r=>{let o=e.transports?.[r.id],d=Q.getCaipNetworkId(r);o?n[r.id]=Q.extendWagmiTransports(r,e.projectId,o):n[r.id]=Q.getViemTransport(r,e.projectId,e.customRpcUrls?.[d])}),this.wagmiConfig=_e({...e,chains:this.wagmiChains,connectors:t,transports:n})}setupWatchPendingTransactions(){if(!this.pendingTransactionsFilter.enable||this.unwatchPendingTransactions)return;this.unwatchPendingTransactions=Se(this.wagmiConfig,{pollingInterval:this.pendingTransactionsFilter.pollingInterval,onError:()=>{},onTransactions:()=>{this.emit("pendingTransactions"),ge.increase("pendingTransactions")}});let e=ge.subscribeKey("pendingTransactions",n=>{n>=g.LIMITS.PENDING_TRANSACTIONS&&(this.unwatchPendingTransactions?.(),e())})}setupWatchers(){ke(this.wagmiConfig,{onChange:(e,n)=>{e.status==="disconnected"&&n.address&&this.emit("disconnect"),e.status==="connected"&&((e.address!==n?.address||n.status!=="connected")&&(this.setupWatchPendingTransactions(),this.emit("accountChanged",{address:e.address,chainId:e.chainId})),e.chainId!==n?.chainId&&this.emit("switchNetwork",{address:e.address,chainId:e.chainId}))}})}async addThirdPartyConnectors(e){let n=[];if(e.enableCoinbase!==!1)try{let{coinbaseWallet:t}=await import("./exports-724XYNT5.js");t&&n.push(t({version:"4",appName:e.metadata?.name??"Unknown",appLogoUrl:e.metadata?.icons[0]??"Unknown",preference:e.coinbasePreference??"all"}))}catch(t){console.error("Failed to import Coinbase Wallet SDK:",t)}n.forEach(t=>{let r=this.wagmiConfig._internal.connectors.setup(t);this.wagmiConfig._internal.connectors.setState(o=>[...o,r])})}addWagmiConnectors(e,n){let t=[];e.enableWalletConnect!==!1&&t.push(z(e,n)),e.enableInjected!==!1&&t.push(Ue({shimDisconnect:!0}));let r=n?.remoteFeatures?.email??!0,o=Array.isArray(n?.remoteFeatures?.socials)&&n?.remoteFeatures?.socials?.length>0;(r||o)&&t.push(je({chains:this.wagmiChains,options:{projectId:e.projectId,enableAuthLogger:e.enableAuthLogger}})),t.forEach(d=>{let u=this.wagmiConfig._internal.connectors.setup(d);this.wagmiConfig._internal.connectors.setState(i=>[...i,u])})}async signMessage(e){try{return{signature:await q(this.wagmiConfig,{message:e.message,account:e.address})}}catch{throw new Error("WagmiAdapter:signMessage - Sign message failed")}}async sendTransaction(e){let{chainId:n,address:t}=ce(this.wagmiConfig),r={account:t,to:e.to,value:Number.isNaN(Number(e.value))?BigInt(0):BigInt(e.value),gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,data:e.data,chainId:n,type:"legacy",parameters:["nonce"]};await Te(this.wagmiConfig,r);let o=await Pe(this.wagmiConfig,r);return await We(this.wagmiConfig,{hash:o,timeout:25e3}),{hash:o}}async writeContract(e){let{caipNetwork:n,...t}=e,r=Number(R.caipNetworkIdToNumber(n.caipNetworkId));return{hash:await Qe(this.wagmiConfig,{chain:this.wagmiChains?.[r],chainId:r,address:t.tokenAddress,account:t.fromAddress,abi:t.abi,functionName:t.method,args:t.args,__mode:"prepared"})}}async estimateGas(e){try{return{gas:await Ae(this.wagmiConfig,{account:e.address,to:e.to,data:e.data,type:"legacy"})}}catch{throw new Error("WagmiAdapter:estimateGas - error estimating gas")}}parseUnits(e){return xe(e.value,e.decimals)}formatUnits(e){return ye(e.value,e.decimals)}async addWagmiConnector(e,n){if(e.id===g.CONNECTOR_ID.AUTH||e.id===g.CONNECTOR_ID.WALLET_CONNECT)return;let t=await e.getProvider().catch(()=>{});this.addConnector({id:e.id,explorerId:W.ConnectorExplorerIds[e.id],imageUrl:n?.connectorImages?.[e.id]??e.icon,name:W.ConnectorNamesMap[e.id]??e.name,imageId:W.ConnectorImageIds[e.id],type:W.ConnectorTypesMap[e.type]??"EXTERNAL",info:e.id===g.CONNECTOR_ID.INJECTED?void 0:{rdns:e.id},provider:t,chain:this.namespace,chains:[]})}async syncConnectors(e,n){Re(this.wagmiConfig,{onChange:t=>{t.forEach(r=>this.addWagmiConnector(r,e))}}),await Promise.all(this.wagmiConfig.connectors.map(t=>this.addWagmiConnector(t,e))),this.addWagmiConnectors(e,n),await this.addThirdPartyConnectors(e)}async syncConnection(e){let{id:n}=e,r=C(this.wagmiConfig).find(u=>u.connector.id===n),d=await this.getWagmiConnector(n)?.getProvider();return{chainId:Number(r?.chainId),address:r?.accounts[0],provider:d,type:r?.connector.type?.toUpperCase(),id:r?.connector.id}}async connectWalletConnect(e){let n=this.getWalletConnectConnector();await n.authenticate();let t=this.getWagmiConnector("walletConnect");if(!t)throw new Error("UniversalAdapter:connectWalletConnect - connector not found");let r=await ae(this.wagmiConfig,{connector:t,chainId:e?Number(e):void 0});return r.chainId!==Number(e)&&await pe(this.wagmiConfig,{chainId:r.chainId}),{clientId:await n.provider.client.core.crypto.getClientId()}}async connect(e){let{id:n,provider:t,type:r,info:o,chainId:d,socialUri:u}=e,i=this.getWagmiConnector(n);if(!i)throw new Error("connectionControllerClient:connectExternal - connector is undefined");if(t&&o&&i.id===g.CONNECTOR_ID.EIP6963&&i.setEip6963Wallet?.({provider:t,info:o}),i.uid===this.wagmiConfig?.state?.current){let f=this.wagmiConfig.state?.connections?.get(i.uid);if(f)return{address:f?.accounts[0],chainId:f?.chainId,provider:t,type:r,id:n}}let p=await ae(this.wagmiConfig,{connector:i,chainId:d?Number(d):void 0,socialUri:u});return{address:p.accounts[0],chainId:p.chainId,provider:t,type:r,id:n}}async reconnect(e){let{id:n}=e,t=this.getWagmiConnector(n);if(!t)throw new Error("connectionControllerClient:connectExternal - connector is undefined");await de(this.wagmiConfig,{connectors:[t]})}async getBalance(e){let n=e.address,t=this.getCaipNetworks().find(r=>r.id===e.chainId);if(!n)return Promise.resolve({balance:"0.00",symbol:"ETH"});if(t&&this.wagmiConfig){let r=`${t.caipNetworkId}:${e.address}`,o=this.balancePromises[r];if(o)return o;let d=P.getNativeBalanceCacheForCaipAddress(r);return d?{balance:d.balance,symbol:d.symbol}:(this.balancePromises[r]=new Promise(async u=>{try{let i=Number(e.chainId),p=await be(this.wagmiConfig,{address:e.address,chainId:i,token:e.tokens?.[t.caipNetworkId]?.address});P.updateNativeBalanceCache({caipAddress:r,balance:p.formatted,symbol:p.symbol,timestamp:Date.now()}),u({balance:p.formatted,symbol:p.symbol})}catch(i){console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance",i),u({balance:"0.00",symbol:"ETH"})}}).finally(()=>{delete this.balancePromises[r]}),this.balancePromises[r]||{balance:"0.00",symbol:"ETH"})}return{balance:"",symbol:""}}getWalletConnectProvider(){return this.getWagmiConnector("walletConnect")?.provider}async disconnect(){let e=C(this.wagmiConfig);await Promise.allSettled(e.map(async n=>{let t=this.getWagmiConnector(n.connector.id);t&&await D(this.wagmiConfig,{connector:t})})),this.wagmiConfig.state.connections.clear()}async switchNetwork(e){await pe(this.wagmiConfig,{chainId:e.caipNetwork.id}),await super.switchNetwork(e)}async getCapabilities(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");let t=C(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:getCapabilities - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:getCapabilities - provider is undefined");let d=o.session?.sessionProperties?.capabilities;if(d){let i=Ve(d)[e];if(i)return i}return await o.request({method:"wallet_getCapabilities",params:[e]})}async grantPermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");let t=C(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:grantPermissions - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:grantPermissions - provider is undefined");return o.request({method:"wallet_grantPermissions",params:e})}async revokePermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");let t=C(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:revokePermissions - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:revokePermissions - provider is undefined");return o.request({method:"wallet_revokePermissions",params:e})}async walletGetAssets(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");let t=C(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");return o.request({method:"wallet_getAssets",params:[e]})}setUniversalProvider(e){e.on("connect",()=>{let n=C(this.wagmiConfig),t=this.getWagmiConnector("walletConnect");t&&!n.find(r=>r.connector.id===t.id)&&de(this.wagmiConfig,{connectors:[t]})}),this.addConnector(new ve({provider:e,caipNetworks:this.getCaipNetworks(),namespace:"eip155"}))}};var N=b(T(),1);var Ze=new Ke,$e="939345e3a30974b284f27b6a7918736f",et={name:"Intear Wallet",description:"Intear Wallet",url:"https://wallet.intear.tech",icons:["/favicon.svg"]},ze=new K({networks:[re],projectId:$e,ssr:!1});Ie({adapters:[ze],networks:[re],projectId:$e,metadata:et,features:{analytics:!1,socials:!1,onramp:!1,swaps:!1,receive:!1,send:!1,email:!1},themeMode:"dark"});function tt({children:s}){return x.default.createElement(G,{config:ze.wagmiConfig},x.default.createElement(Fe,{client:Ze},s))}function nt({messageToSign:s,onSignature:e}){let n=te({namespace:"eip155"}),{open:t,close:r}=se(),{disconnect:o}=$(),{signMessage:d,data:u,error:i}=fe();return(0,N.useEffect)(()=>{u&&(e(u,s),o(),r())},[u,e]),(0,N.useEffect)(()=>{i&&(console.error("Signing error:",i),e(null,s),o(),r())},[i,e,o]),(0,N.useEffect)(()=>{if(n.isConnected&&s&&d({message:s}),!n.isConnected&&s){t({view:"Connect",namespace:"eip155"});let p=!1,f=setInterval(()=>{let a=document.getElementsByTagName("w3m-modal")[0];a&&a.className==="open"?p=!0:p&&(clearInterval(f),e(null,s),o(),r())},50);return()=>clearInterval(f)}},[n.isConnected,s]),x.default.createElement(x.default.Fragment,null)}function rt({onConnection:s}){let e=te({namespace:"eip155"}),{open:n,close:t}=se(),{disconnect:r}=$();return(0,N.useEffect)(()=>{r()},[]),(0,N.useEffect)(()=>{if(e.isConnected&&e.address){let o=e.address;s(o),t()}},[e.isConnected,e.address,s]),(0,N.useEffect)(()=>{if(!e.isConnected){n({view:"Connect",namespace:"eip155"});let o=!1,d=setInterval(()=>{let u=document.getElementsByTagName("w3m-modal")[0];u&&u.className==="open"?o=!0:o&&(clearInterval(d),s(null))},50);return()=>clearInterval(d)}},[e.isConnected,s]),x.default.createElement(x.default.Fragment,null)}function ot({messageToSign:s,onSignature:e,needsSignIn:n,onConnection:t}){return x.default.createElement(tt,null,s&&x.default.createElement(nt,{messageToSign:s,onSignature:e}),n&&x.default.createElement(rt,{onConnection:t}))}export{ot as default};
