import{a as Ot}from"./chunk-FILZKAK2.js";import{a as Dt,b as wt,c as gt,d as At,e as Zt,f as Wt,g as G,h as Gt,i as tt,j as Xt,k as z,l as X,m as Ht,n as bt,o as et,p as Be,q as lt,r as Se,s as nt,t as Qt}from"./chunk-6OI5GZ4U.js";import{D as Ee,E as xe,F as ve,H as Lt,s as ge,t as be,u as ye,v as Yt,y as pe}from"./chunk-YRGGSJIG.js";import{h as Y,j as D,n as W}from"./chunk-KGCAX4NX.js";Y();W();D();Y();W();D();Y();W();D();var kt=class extends ve{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,ye(n);let r=Ee(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),pe(s)}update(n){return Yt(this),this.iHash.update(n),this}digestInto(n){Yt(this),be(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:r,finished:i,destroyed:s,blockLen:c,outputLen:a}=this;return n=n,n.finished=i,n.destroyed=s,n.blockLen=c,n.outputLen=a,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Jt=(t,n,e)=>new kt(t,n).update(e).digest();Jt.create=(t,n)=>new kt(t,n);Y();W();D();Y();W();D();Y();W();D();var j=BigInt(0),M=BigInt(1),dt=BigInt(2),$e=BigInt(3),Ae=BigInt(4),Ie=BigInt(5),qe=BigInt(8);function U(t,n){let e=t%n;return e>=j?e:n+e}function Q(t,n,e){let r=t;for(;n-- >j;)r*=r,r%=e;return r}function Ct(t,n){if(t===j)throw new Error("invert: expected non-zero number");if(n<=j)throw new Error("invert: expected positive modulus, got "+n);let e=U(t,n),r=n,i=j,s=M,c=M,a=j;for(;e!==j;){let l=r/e,u=r%e,p=i-c*l,x=s-a*l;r=e,e=u,i=c,s=a,c=p,a=x}if(r!==M)throw new Error("invert: does not exist");return U(i,n)}function _e(t,n){let e=(t.ORDER+M)/Ae,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function Fe(t,n){let e=(t.ORDER-Ie)/qe,r=t.mul(n,dt),i=t.pow(r,e),s=t.mul(n,i),c=t.mul(t.mul(s,dt),i),a=t.mul(s,t.sub(c,t.ONE));if(!t.eql(t.sqr(a),n))throw new Error("Cannot find square root");return a}function tn(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-M,e=0;for(;n%dt===j;)n/=dt,e++;let r=dt,i=It(t);for(;Oe(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return _e;let s=i.pow(r,n),c=(n+M)/dt;return function(o,l){if(o.is0(l))return l;if(Oe(o,l)!==1)throw new Error("Cannot find square root");let u=e,p=o.mul(o.ONE,s),x=o.pow(l,n),v=o.pow(l,c);for(;!o.eql(x,o.ONE);){if(o.is0(x))return o.ZERO;let N=1,w=o.sqr(x);for(;!o.eql(w,o.ONE);)if(N++,w=o.sqr(w),N===u)throw new Error("Cannot find square root");let H=M<<BigInt(u-N-1),A=o.pow(p,H);u=N,p=o.sqr(A),x=o.mul(x,p),v=o.mul(v,A)}return v}}function en(t){return t%Ae===$e?_e:t%qe===Ie?Fe:tn(t)}var qn=(t,n)=>(U(t,n)&M)===M,nn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ut(t){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=nn.reduce((r,i)=>(r[i]="function",r),n);return nt(t,e)}function rn(t,n,e){if(e<j)throw new Error("invalid exponent, negatives unsupported");if(e===j)return t.ONE;if(e===M)return n;let r=t.ONE,i=n;for(;e>j;)e&M&&(r=t.mul(r,i)),i=t.sqr(i),e>>=M;return r}function xt(t,n,e=!1){let r=new Array(n.length).fill(e?t.ZERO:void 0),i=n.reduce((c,a,o)=>t.is0(a)?c:(r[o]=c,t.mul(c,a)),t.ONE),s=t.inv(i);return n.reduceRight((c,a,o)=>t.is0(a)?c:(r[o]=t.mul(c,r[o]),t.mul(c,a)),s),r}function Oe(t,n){let e=(t.ORDER-M)/dt,r=t.pow(n,e),i=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!i&&!s&&!c)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function $t(t,n){n!==void 0&&ge(n);let e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function It(t,n,e=!1,r={}){if(t<=j)throw new Error("invalid field: expected ORDER > 0, got "+t);let{nBitLength:i,nByteLength:s}=$t(t,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,a=Object.freeze({ORDER:t,isLE:e,BITS:i,BYTES:s,MASK:lt(i),ZERO:j,ONE:M,create:o=>U(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return j<=o&&o<t},is0:o=>o===j,isOdd:o=>(o&M)===M,neg:o=>U(-o,t),eql:(o,l)=>o===l,sqr:o=>U(o*o,t),add:(o,l)=>U(o+l,t),sub:(o,l)=>U(o-l,t),mul:(o,l)=>U(o*l,t),pow:(o,l)=>rn(a,o,l),div:(o,l)=>U(o*Ct(l,t),t),sqrN:o=>o*o,addN:(o,l)=>o+l,subN:(o,l)=>o-l,mulN:(o,l)=>o*l,inv:o=>Ct(o,t),sqrt:r.sqrt||(o=>(c||(c=en(t)),c(a,o))),toBytes:o=>e?Xt(o,s):tt(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return e?Gt(o):G(o)},invertBatch:o=>xt(a,o),cmov:(o,l,u)=>u?l:o});return Object.freeze(a)}function Ne(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let n=t.toString(2).length;return Math.ceil(n/8)}function Ft(t){let n=Ne(t);return n+Math.ceil(n/2)}function Re(t,n,e=!1){let r=t.length,i=Ne(n),s=Ft(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);let c=e?Gt(t):G(t),a=U(c,n-M)+M;return e?Xt(a,i):tt(a,i)}var Te=BigInt(0),oe=BigInt(1);function te(t,n){let e=n.negate();return t?e:n}function Ze(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function ee(t,n){Ze(t,n);let e=Math.ceil(n/t)+1,r=2**(t-1),i=2**t,s=lt(t),c=BigInt(t);return{windows:e,windowSize:r,mask:s,maxNumber:i,shiftBy:c}}function Le(t,n,e){let{windowSize:r,mask:i,maxNumber:s,shiftBy:c}=e,a=Number(t&i),o=t>>c;a>r&&(a-=s,o+=oe);let l=n*r,u=l+Math.abs(a)-1,p=a===0,x=a<0,v=n%2!==0;return{nextN:o,offset:u,isZero:p,isNeg:x,isNegF:v,offsetF:l}}function on(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function sn(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}var ne=new WeakMap,He=new WeakMap;function re(t){return He.get(t)||1}function ke(t,n){return{constTimeNegate:te,hasPrecomputes(e){return re(e)!==1},unsafeLadder(e,r,i=t.ZERO){let s=e;for(;r>Te;)r&oe&&(i=i.add(s)),s=s.double(),r>>=oe;return i},precomputeWindow(e,r){let{windows:i,windowSize:s}=ee(r,n),c=[],a=e,o=a;for(let l=0;l<i;l++){o=a,c.push(o);for(let u=1;u<s;u++)o=o.add(a),c.push(o);a=o.double()}return c},wNAF(e,r,i){let s=t.ZERO,c=t.BASE,a=ee(e,n);for(let o=0;o<a.windows;o++){let{nextN:l,offset:u,isZero:p,isNeg:x,isNegF:v,offsetF:N}=Le(i,o,a);i=l,p?c=c.add(te(v,r[N])):s=s.add(te(x,r[u]))}return{p:s,f:c}},wNAFUnsafe(e,r,i,s=t.ZERO){let c=ee(e,n);for(let a=0;a<c.windows&&i!==Te;a++){let{nextN:o,offset:l,isZero:u,isNeg:p}=Le(i,a,c);if(i=o,!u){let x=r[l];s=s.add(p?x.negate():x)}}return s},getPrecomputes(e,r,i){let s=ne.get(r);return s||(s=this.precomputeWindow(r,e),e!==1&&ne.set(r,i(s))),s},wNAFCached(e,r,i){let s=re(e);return this.wNAF(s,this.getPrecomputes(s,e,i),r)},wNAFCachedUnsafe(e,r,i,s){let c=re(e);return c===1?this.unsafeLadder(e,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,e,i),r,s)},setWindowSize(e,r){Ze(r,n),He.set(e,r),ne.delete(e)}}}function Ce(t,n,e,r){on(e,t),sn(r,n);let i=e.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");let c=t.ZERO,a=Be(BigInt(i)),o=1;a>12?o=a-3:a>4?o=a-2:a>0&&(o=2);let l=lt(o),u=new Array(Number(l)+1).fill(c),p=Math.floor((n.BITS-1)/o)*o,x=c;for(let v=p;v>=0;v-=o){u.fill(c);for(let w=0;w<s;w++){let H=r[w],A=Number(H>>BigInt(v)&l);u[A]=u[A].add(e[w])}let N=c;for(let w=u.length-1,H=c;w>0;w--)H=H.add(u[w]),N=N.add(H);if(x=x.add(N),v!==0)for(let w=0;w<o;w++)x=x.double()}return x}function se(t){return Ut(t.Fp),nt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...$t(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Ue(t){t.lowS!==void 0&&gt("lowS",t.lowS),t.prehash!==void 0&&gt("prehash",t.prehash)}function cn(t){let n=se(t);nt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});let{endo:e,Fp:r,a:i}=n;if(e){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}var ce=class extends Error{constructor(n=""){super(n)}},rt={Err:ce,_tlv:{encode:(t,n)=>{let{Err:e}=rt;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");let r=n.length/2,i=At(r);if(i.length/2&128)throw new e("tlv.encode: long form length too big");let s=r>127?At(i.length/2|128):"";return At(t)+s+i+n},decode(t,n){let{Err:e}=rt,r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");let i=n[r++],s=!!(i&128),c=0;if(!s)c=i;else{let o=i&127;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");let l=n.subarray(r,r+o);if(l.length!==o)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(let u of l)c=c<<8|u;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}let a=n.subarray(r,r+c);if(a.length!==c)throw new e("tlv.decode: wrong value length");return{v:a,l:n.subarray(r+c)}}},_int:{encode(t){let{Err:n}=rt;if(t<$)throw new n("integer: negative integers are not allowed");let e=At(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){let{Err:n}=rt;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return G(t)}},toSig(t){let{Err:n,_int:e,_tlv:r}=rt,i=z("signature",t),{v:s,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");let{v:a,l:o}=r.decode(2,s),{v:l,l:u}=r.decode(2,o);if(u.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(l)}},hexFromSig(t){let{_tlv:n,_int:e}=rt,r=n.encode(2,e.encode(t.r)),i=n.encode(2,e.encode(t.s)),s=r+i;return n.encode(48,s)}};function ie(t,n){return Zt(tt(t,n))}var $=BigInt(0),k=BigInt(1),st=BigInt(2),qt=BigInt(3),fe=BigInt(4);function fn(t){let n=cn(t),{Fp:e}=n,r=It(n.n,n.nBitLength),i=n.toBytes||((g,f,m)=>{let b=f.toAffine();return X(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),s=n.fromBytes||(g=>{let f=g.subarray(1),m=e.fromBytes(f.subarray(0,e.BYTES)),b=e.fromBytes(f.subarray(e.BYTES,2*e.BYTES));return{x:m,y:b}});function c(g){let{a:f,b:m}=n,b=e.sqr(g),E=e.mul(b,g);return e.add(e.add(E,e.mul(g,f)),m)}function a(g,f){let m=e.sqr(f),b=c(g);return e.eql(m,b)}if(!a(n.Gx,n.Gy))throw new Error("bad curve params: generator point");let o=e.mul(e.pow(n.a,qt),fe),l=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,l)))throw new Error("bad curve params: a or b");function u(g){return bt(g,k,n.n)}function p(g){let{allowedPrivateKeyLengths:f,nByteLength:m,wrapPrivateKey:b,n:E}=n;if(f&&typeof g!="bigint"){if(Dt(g)&&(g=Zt(g)),typeof g!="string"||!f.includes(g.length))throw new Error("invalid private key");g=g.padStart(m*2,"0")}let I;try{I=typeof g=="bigint"?g:G(z("private key",g,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof g)}return b&&(I=U(I,E)),et("private key",I,k,E),I}function x(g){if(!(g instanceof w))throw new Error("ProjectivePoint expected")}let v=Qt((g,f)=>{let{px:m,py:b,pz:E}=g;if(e.eql(E,e.ONE))return{x:m,y:b};let I=g.is0();f==null&&(f=I?e.ONE:e.inv(E));let L=e.mul(m,f),Z=e.mul(b,f),B=e.mul(E,f);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:L,y:Z}}),N=Qt(g=>{if(g.is0()){if(n.allowInfinityPoint&&!e.is0(g.py))return;throw new Error("bad point: ZERO")}let{x:f,y:m}=g.toAffine();if(!e.isValid(f)||!e.isValid(m))throw new Error("bad point: x or y not FE");if(!a(f,m))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(f,m,b){if(f==null||!e.isValid(f))throw new Error("x required");if(m==null||!e.isValid(m)||e.is0(m))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");this.px=f,this.py=m,this.pz=b,Object.freeze(this)}static fromAffine(f){let{x:m,y:b}=f||{};if(!f||!e.isValid(m)||!e.isValid(b))throw new Error("invalid affine point");if(f instanceof w)throw new Error("projective point not allowed");let E=I=>e.eql(I,e.ZERO);return E(m)&&E(b)?w.ZERO:new w(m,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){let m=xt(e,f.map(b=>b.pz));return f.map((b,E)=>b.toAffine(m[E])).map(w.fromAffine)}static fromHex(f){let m=w.fromAffine(s(z("pointHex",f)));return m.assertValidity(),m}static fromPrivateKey(f){return w.BASE.multiply(p(f))}static msm(f,m){return Ce(w,r,f,m)}_setWindowSize(f){T.setWindowSize(this,f)}assertValidity(){N(this)}hasEvenY(){let{y:f}=this.toAffine();if(e.isOdd)return!e.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){x(f);let{px:m,py:b,pz:E}=this,{px:I,py:L,pz:Z}=f,B=e.eql(e.mul(m,Z),e.mul(I,E)),R=e.eql(e.mul(b,Z),e.mul(L,E));return B&&R}negate(){return new w(this.px,e.neg(this.py),this.pz)}double(){let{a:f,b:m}=n,b=e.mul(m,qt),{px:E,py:I,pz:L}=this,Z=e.ZERO,B=e.ZERO,R=e.ZERO,S=e.mul(E,E),P=e.mul(I,I),h=e.mul(L,L),d=e.mul(E,I);return d=e.add(d,d),R=e.mul(E,L),R=e.add(R,R),Z=e.mul(f,R),B=e.mul(b,h),B=e.add(Z,B),Z=e.sub(P,B),B=e.add(P,B),B=e.mul(Z,B),Z=e.mul(d,Z),R=e.mul(b,R),h=e.mul(f,h),d=e.sub(S,h),d=e.mul(f,d),d=e.add(d,R),R=e.add(S,S),S=e.add(R,S),S=e.add(S,h),S=e.mul(S,d),B=e.add(B,S),h=e.mul(I,L),h=e.add(h,h),S=e.mul(h,d),Z=e.sub(Z,S),R=e.mul(h,P),R=e.add(R,R),R=e.add(R,R),new w(Z,B,R)}add(f){x(f);let{px:m,py:b,pz:E}=this,{px:I,py:L,pz:Z}=f,B=e.ZERO,R=e.ZERO,S=e.ZERO,P=n.a,h=e.mul(n.b,qt),d=e.mul(m,I),y=e.mul(b,L),_=e.mul(E,Z),O=e.add(m,b),q=e.add(I,L);O=e.mul(O,q),q=e.add(d,y),O=e.sub(O,q),q=e.add(m,E);let C=e.add(I,Z);return q=e.mul(q,C),C=e.add(d,_),q=e.sub(q,C),C=e.add(b,E),B=e.add(L,Z),C=e.mul(C,B),B=e.add(y,_),C=e.sub(C,B),S=e.mul(P,q),B=e.mul(h,_),S=e.add(B,S),B=e.sub(y,S),S=e.add(y,S),R=e.mul(B,S),y=e.add(d,d),y=e.add(y,d),_=e.mul(P,_),q=e.mul(h,q),y=e.add(y,_),_=e.sub(d,_),_=e.mul(P,_),q=e.add(q,_),d=e.mul(y,q),R=e.add(R,d),d=e.mul(C,q),B=e.mul(O,B),B=e.sub(B,d),d=e.mul(O,y),S=e.mul(C,S),S=e.add(S,d),new w(B,R,S)}subtract(f){return this.add(f.negate())}is0(){return this.equals(w.ZERO)}wNAF(f){return T.wNAFCached(this,f,w.normalizeZ)}multiplyUnsafe(f){let{endo:m,n:b}=n;et("scalar",f,$,b);let E=w.ZERO;if(f===$)return E;if(this.is0()||f===k)return this;if(!m||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,f,w.normalizeZ);let{k1neg:I,k1:L,k2neg:Z,k2:B}=m.splitScalar(f),R=E,S=E,P=this;for(;L>$||B>$;)L&k&&(R=R.add(P)),B&k&&(S=S.add(P)),P=P.double(),L>>=k,B>>=k;return I&&(R=R.negate()),Z&&(S=S.negate()),S=new w(e.mul(S.px,m.beta),S.py,S.pz),R.add(S)}multiply(f){let{endo:m,n:b}=n;et("scalar",f,k,b);let E,I;if(m){let{k1neg:L,k1:Z,k2neg:B,k2:R}=m.splitScalar(f),{p:S,f:P}=this.wNAF(Z),{p:h,f:d}=this.wNAF(R);S=T.constTimeNegate(L,S),h=T.constTimeNegate(B,h),h=new w(e.mul(h.px,m.beta),h.py,h.pz),E=S.add(h),I=P.add(d)}else{let{p:L,f:Z}=this.wNAF(f);E=L,I=Z}return w.normalizeZ([E,I])[0]}multiplyAndAddUnsafe(f,m,b){let E=w.BASE,I=(Z,B)=>B===$||B===k||!Z.equals(E)?Z.multiplyUnsafe(B):Z.multiply(B),L=I(this,m).add(I(f,b));return L.is0()?void 0:L}toAffine(f){return v(this,f)}isTorsionFree(){let{h:f,isTorsionFree:m}=n;if(f===k)return!0;if(m)return m(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:f,clearCofactor:m}=n;return f===k?this:m?m(w,this):this.multiplyUnsafe(n.h)}toRawBytes(f=!0){return gt("isCompressed",f),this.assertValidity(),i(w,this,f)}toHex(f=!0){return gt("isCompressed",f),Zt(this.toRawBytes(f))}}w.BASE=new w(n.Gx,n.Gy,e.ONE),w.ZERO=new w(e.ZERO,e.ONE,e.ZERO);let{endo:H,nBitLength:A}=n,T=ke(w,H?Math.ceil(A/2):A);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:p,weierstrassEquation:c,isWithinCurveOrder:u}}function an(t){let n=se(t);return nt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function ze(t){let n=an(t),{Fp:e,n:r,nByteLength:i,nBitLength:s}=n,c=e.BYTES+1,a=2*e.BYTES+1;function o(h){return U(h,r)}function l(h){return Ct(h,r)}let{ProjectivePoint:u,normPrivateKeyToScalar:p,weierstrassEquation:x,isWithinCurveOrder:v}=fn({...n,toBytes(h,d,y){let _=d.toAffine(),O=e.toBytes(_.x),q=X;return gt("isCompressed",y),y?q(Uint8Array.from([d.hasEvenY()?2:3]),O):q(Uint8Array.from([4]),O,e.toBytes(_.y))},fromBytes(h){let d=h.length,y=h[0],_=h.subarray(1);if(d===c&&(y===2||y===3)){let O=G(_);if(!bt(O,k,e.ORDER))throw new Error("Point is not on curve");let q=x(O),C;try{C=e.sqrt(q)}catch(J){let K=J instanceof Error?": "+J.message:"";throw new Error("Point is not on curve"+K)}let V=(C&k)===k;return(y&1)===1!==V&&(C=e.neg(C)),{x:O,y:C}}else if(d===a&&y===4){let O=e.fromBytes(_.subarray(0,e.BYTES)),q=e.fromBytes(_.subarray(e.BYTES,2*e.BYTES));return{x:O,y:q}}else{let O=c,q=a;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+q+", got "+d)}}});function N(h){let d=r>>k;return h>d}function w(h){return N(h)?o(-h):h}let H=(h,d,y)=>G(h.slice(d,y));class A{constructor(d,y,_){et("r",d,k,r),et("s",y,k,r),this.r=d,this.s=y,_!=null&&(this.recovery=_),Object.freeze(this)}static fromCompact(d){let y=i;return d=z("compactSignature",d,y*2),new A(H(d,0,y),H(d,y,2*y))}static fromDER(d){let{r:y,s:_}=rt.toSig(z("DER",d));return new A(y,_)}assertValidity(){}addRecoveryBit(d){return new A(this.r,this.s,d)}recoverPublicKey(d){let{r:y,s:_,recovery:O}=this,q=E(z("msgHash",d));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");let C=O===2||O===3?y+n.n:y;if(C>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let V=(O&1)===0?"02":"03",F=u.fromHex(V+ie(C,e.BYTES)),J=l(C),K=o(-q*J),ut=o(_*J),ot=u.BASE.multiplyAndAddUnsafe(F,K,ut);if(!ot)throw new Error("point at infinify");return ot.assertValidity(),ot}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new A(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Wt(this.toDERHex())}toDERHex(){return rt.hexFromSig(this)}toCompactRawBytes(){return Wt(this.toCompactHex())}toCompactHex(){let d=i;return ie(this.r,d)+ie(this.s,d)}}let T={isValidPrivateKey(h){try{return p(h),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{let h=Ft(n.n);return Re(n.randomBytes(h),n.n)},precompute(h=8,d=u.BASE){return d._setWindowSize(h),d.multiply(BigInt(3)),d}};function g(h,d=!0){return u.fromPrivateKey(h).toRawBytes(d)}function f(h){if(typeof h=="bigint")return!1;if(h instanceof u)return!0;let y=z("key",h).length,_=e.BYTES,O=_+1,q=2*_+1;if(!(n.allowedPrivateKeyLengths||i===O))return y===O||y===q}function m(h,d,y=!0){if(f(h)===!0)throw new Error("first arg must be private key");if(f(d)===!1)throw new Error("second arg must be public key");return u.fromHex(d).multiply(p(h)).toRawBytes(y)}let b=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");let d=G(h),y=h.length*8-s;return y>0?d>>BigInt(y):d},E=n.bits2int_modN||function(h){return o(b(h))},I=lt(s);function L(h){return et("num < 2^"+s,h,$,I),tt(h,i)}function Z(h,d,y=B){if(["recovered","canonical"].some(ft=>ft in y))throw new Error("sign() legacy options not supported");let{hash:_,randomBytes:O}=n,{lowS:q,prehash:C,extraEntropy:V}=y;q==null&&(q=!0),h=z("msgHash",h),Ue(y),C&&(h=z("prehashed msgHash",_(h)));let F=E(h),J=p(d),K=[L(J),L(F)];if(V!=null&&V!==!1){let ft=V===!0?O(e.BYTES):V;K.push(z("extraEntropy",ft))}let ut=X(...K),ot=F;function jt(ft){let ht=b(ft);if(!v(ht))return;let Kt=l(ht),Bt=u.BASE.multiply(ht).toAffine(),at=o(Bt.x);if(at===$)return;let St=o(Kt*o(ot+at*J));if(St===$)return;let mt=(Bt.x===at?0:2)|Number(Bt.y&k),we=St;return q&&N(St)&&(we=w(St),mt^=1),new A(at,we,mt)}return{seed:ut,k2sig:jt}}let B={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};function S(h,d,y=B){let{seed:_,k2sig:O}=Z(h,d,y),q=n;return Se(q.hash.outputLen,q.nByteLength,q.hmac)(_,O)}u.BASE._setWindowSize(8);function P(h,d,y,_=R){let O=h;d=z("msgHash",d),y=z("publicKey",y);let{lowS:q,prehash:C,format:V}=_;if(Ue(_),"strict"in _)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");let F=typeof O=="string"||Dt(O),J=!F&&!V&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!F&&!J)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,ut;try{if(J&&(K=new A(O.r,O.s)),F){try{V!=="compact"&&(K=A.fromDER(O))}catch(mt){if(!(mt instanceof rt.Err))throw mt}!K&&V!=="der"&&(K=A.fromCompact(O))}ut=u.fromHex(y)}catch{return!1}if(!K||q&&K.hasHighS())return!1;C&&(d=n.hash(d));let{r:ot,s:jt}=K,ft=E(d),ht=l(jt),Kt=o(ft*ht),Bt=o(ot*ht),at=u.BASE.multiplyAndAddUnsafe(ut,Kt,Bt)?.toAffine();return at?o(at.x)===ot:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:m,sign:S,verify:P,ProjectivePoint:u,Signature:A,utils:T}}function ln(t,n){let e=t.ORDER,r=$;for(let N=e-k;N%st===$;N/=st)r+=k;let i=r,s=st<<i-k-k,c=s*st,a=(e-k)/c,o=(a-k)/st,l=c-k,u=s,p=t.pow(n,a),x=t.pow(n,(a+k)/st),v=(N,w)=>{let H=p,A=t.pow(w,l),T=t.sqr(A);T=t.mul(T,w);let g=t.mul(N,T);g=t.pow(g,o),g=t.mul(g,A),A=t.mul(g,w),T=t.mul(g,N);let f=t.mul(T,A);g=t.pow(f,u);let m=t.eql(g,t.ONE);A=t.mul(T,x),g=t.mul(f,H),T=t.cmov(A,T,m),f=t.cmov(g,f,m);for(let b=i;b>k;b--){let E=b-st;E=st<<E-k;let I=t.pow(f,E),L=t.eql(I,t.ONE);A=t.mul(T,H),H=t.mul(H,H),I=t.mul(f,H),T=t.cmov(A,T,L),f=t.cmov(I,f,L)}return{isValid:m,value:T}};if(t.ORDER%fe===qt){let N=(t.ORDER-qt)/fe,w=t.sqrt(t.neg(n));v=(H,A)=>{let T=t.sqr(A),g=t.mul(H,A);T=t.mul(T,g);let f=t.pow(T,N);f=t.mul(f,g);let m=t.mul(f,w),b=t.mul(t.sqr(f),A),E=t.eql(b,H),I=t.cmov(m,f,E);return{isValid:E,value:I}}}return v}function Me(t,n){if(Ut(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let e=ln(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let i,s,c,a,o,l,u,p;i=t.sqr(r),i=t.mul(i,n.Z),s=t.sqr(i),s=t.add(s,i),c=t.add(s,t.ONE),c=t.mul(c,n.B),a=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),a=t.mul(a,n.A),s=t.sqr(c),l=t.sqr(a),o=t.mul(l,n.A),s=t.add(s,o),s=t.mul(s,c),l=t.mul(l,a),o=t.mul(l,n.B),s=t.add(s,o),u=t.mul(i,c);let{isValid:x,value:v}=e(s,l);p=t.mul(i,r),p=t.mul(p,v),u=t.cmov(u,c,x),p=t.cmov(p,v,x);let N=t.isOdd(r)===t.isOdd(p);p=t.cmov(t.neg(p),p,N);let w=xt(t,[a],!0)[0];return u=t.mul(u,w),{x:u,y:p}}}function dn(t){return{hash:t,hmac:(n,...e)=>Jt(t,n,xe(...e)),randomBytes:Lt}}function Pe(t,n){let e=r=>ze({...t,...dn(r)});return{...e(n),create:e}}Y();W();D();var un=G;function it(t,n){if(_t(t),_t(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);let e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function hn(t,n){let e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function _t(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function mn(t,n,e,r){wt(t),wt(n),_t(e),n.length>255&&(n=r(X(Ht("H2C-OVERSIZE-DST-"),n)));let{outputLen:i,blockLen:s}=r,c=Math.ceil(e/i);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");let a=X(n,it(n.length,1)),o=it(0,s),l=it(e,2),u=new Array(c),p=r(X(o,t,l,it(0,1),a));u[0]=r(X(p,it(1,1),a));for(let v=1;v<=c;v++){let N=[hn(p,u[v-1]),it(v+1,1),a];u[v]=r(X(...N))}return X(...u).slice(0,e)}function wn(t,n,e,r,i){if(wt(t),wt(n),_t(e),n.length>255){let s=Math.ceil(2*r/8);n=i.create({dkLen:s}).update(Ht("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:e}).update(t).update(it(e,2)).update(n).update(it(n.length,1)).digest()}function Ve(t,n,e){nt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:i,m:s,hash:c,expand:a,DST:o}=e;wt(t),_t(n);let l=typeof o=="string"?Ht(o):o,u=r.toString(2).length,p=Math.ceil((u+i)/8),x=n*s*p,v;if(a==="xmd")v=mn(t,l,x,c);else if(a==="xof")v=wn(t,l,x,i,c);else if(a==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');let N=new Array(n);for(let w=0;w<n;w++){let H=new Array(s);for(let A=0;A<s;A++){let T=p*(A+w*s),g=v.subarray(T,T+p);H[A]=U(un(g),r)}N[w]=H}return N}function je(t,n){let e=n.map(r=>Array.from(r).reverse());return(r,i)=>{let[s,c,a,o]=e.map(p=>p.reduce((x,v)=>t.add(t.mul(x,r),v))),[l,u]=xt(t,[c,o],!0);return r=t.mul(s,l),i=t.mul(i,t.mul(a,u)),{x:r,y:i}}}function Ke(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(s){return t.fromAffine(n(s))}function i(s){let c=s.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(s,c){let a=Ve(s,2,{...e,DST:e.DST,...c}),o=r(a[0]),l=r(a[1]);return i(o.add(l))},encodeToCurve(s,c){let a=Ve(s,1,{...e,DST:e.encodeDST,...c});return i(r(a[0]))},mapToCurve(s){if(!Array.isArray(s))throw new Error("expected array of bigints");for(let c of s)if(typeof c!="bigint")throw new Error("expected array of bigints");return i(r(s))}}}var Tt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ue=BigInt(0),Nt=BigInt(1),Mt=BigInt(2),Ye=(t,n)=>(t+n/Mt)/n;function We(t){let n=Tt,e=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),c=BigInt(23),a=BigInt(44),o=BigInt(88),l=t*t*t%n,u=l*l*t%n,p=Q(u,e,n)*u%n,x=Q(p,e,n)*u%n,v=Q(x,Mt,n)*l%n,N=Q(v,i,n)*v%n,w=Q(N,s,n)*N%n,H=Q(w,a,n)*w%n,A=Q(H,o,n)*H%n,T=Q(A,a,n)*w%n,g=Q(T,e,n)*u%n,f=Q(g,c,n)*N%n,m=Q(f,r,n)*l%n,b=Q(m,Mt,n);if(!ct.eql(ct.sqr(b),t))throw new Error("Cannot find square root");return b}var ct=It(Tt,void 0,void 0,{sqrt:We}),Vt=Pe({a:ue,b:BigInt(7),Fp:ct,n:zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let n=zt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Nt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),a=Ye(s*t,n),o=Ye(-r*t,n),l=U(t-a*e-o*i,n),u=U(-a*r-o*s,n),p=l>c,x=u>c;if(p&&(l=n-l),x&&(u=n-u),l>c||u>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:p,k1:l,k2neg:x,k2:u}}}},Ot),De={};function Pt(t,...n){let e=De[t];if(e===void 0){let r=Ot(Uint8Array.from(t,i=>i.charCodeAt(0)));e=X(r,r),De[t]=e}return Ot(X(e,...n))}var he=t=>t.toRawBytes(!0).slice(1),le=t=>tt(t,32),ae=t=>U(t,Tt),Rt=t=>U(t,zt),me=Vt.ProjectivePoint,gn=(t,n,e)=>me.BASE.multiplyAndAddUnsafe(t,n,e);function de(t){let n=Vt.utils.normPrivateKeyToScalar(t),e=me.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:Rt(-n),bytes:he(e)}}function Ge(t){et("x",t,Nt,Tt);let n=ae(t*t),e=ae(n*t+BigInt(7)),r=We(e);r%Mt!==ue&&(r=ae(-r));let i=new me(t,r,Nt);return i.assertValidity(),i}var vt=G;function Xe(...t){return Rt(vt(Pt("BIP0340/challenge",...t)))}function bn(t){return de(t).bytes}function yn(t,n,e=Lt(32)){let r=z("message",t),{bytes:i,scalar:s}=de(n),c=z("auxRand",e,32),a=le(s^vt(Pt("BIP0340/aux",c))),o=Pt("BIP0340/nonce",a,i,r),l=Rt(vt(o));if(l===ue)throw new Error("sign failed: k is zero");let{bytes:u,scalar:p}=de(l),x=Xe(u,i,r),v=new Uint8Array(64);if(v.set(u,0),v.set(le(Rt(p+x*s)),32),!Qe(v,r,i))throw new Error("sign: Invalid signature produced");return v}function Qe(t,n,e){let r=z("signature",t,64),i=z("message",n),s=z("publicKey",e,32);try{let c=Ge(vt(s)),a=vt(r.subarray(0,32));if(!bt(a,Nt,Tt))return!1;let o=vt(r.subarray(32,64));if(!bt(o,Nt,zt))return!1;let l=Xe(le(a),he(c),i),u=gn(c,o,Rt(-l));return!(!u||!u.hasEvenY()||u.toAffine().x!==a)}catch{return!1}}var ur={getPublicKey:bn,sign:yn,verify:Qe,utils:{randomPrivateKey:Vt.utils.randomPrivateKey,lift_x:Ge,pointToBytes:he,numberToBytesBE:tt,bytesToNumberBE:G,taggedHash:Pt,mod:U}},pn=je(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),En=Me(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}),Je=Ke(Vt.ProjectivePoint,t=>{let{x:n,y:e}=En(ct.create(t[0]));return pn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:Ot}),hr=Je.hashToCurve,mr=Je.encodeToCurve;export{U as a,Q as b,qn as c,xt as d,It as e,ke as f,Ce as g,se as h,Vt as i,ur as j,Je as k,hr as l,mr as m};
/*! Bundled license information:

@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
