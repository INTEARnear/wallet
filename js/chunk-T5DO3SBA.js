import{a as Je}from"./chunk-RRN7SHYG.js";import{A as We,a as V,b as Pe,c as Ie,d as Se,e as ke,f as tt,g as Ae,h as Bt,i as _e,j as Fe,k as Be,l as Ne,m as Re,n as qe,o as Me,p as je,q as Ge,r as Kt,s as De,t as Le,u as Ue,v as Rt,w as st,x as qt,z as $e}from"./chunk-YY5EM6U5.js";import{A as we,C as j,F as xe,Fa as kt,Ga as At,Ha as _t,Ia as Ft,J as R,Ja as Ee,K as Q,Ka as Y,Ma as Nt,Na as Oe,O as J,P as ye,Q as Vt,Qa as ze,Ra as He,V as be,W as Pt,X as It,Xa as nt,Y as ve,Z as Ce,aa as Te,ca as St,d as z,f as le,l as pe,la as Et,m as Jt,n as yt,o as bt,p as vt,q as he,qa as N,s as A,t as Ct,v as ge,va as ot,x as Tt}from"./chunk-JGRP444H.js";function I(t,r,e){let o=t[r.name];if(typeof o=="function")return o;let n=t[e];return typeof n=="function"?n:s=>r(t,s)}function Ve(t,{method:r}){let e={};return t.transport.type==="fallback"&&t.transport.onResponse?.(({method:o,response:n,status:s,transport:a})=>{s==="success"&&r===o&&(e[n]=a.request)}),o=>e[o]||t.request}function Ke(t){let{chainId:r,nonce:e,to:o}=t,n=t.contractAddress??t.address,s=Tt(xe(["0x05",Ie([r?A(r):"0x",n,e?A(e):"0x"])]));return o==="bytes"?ge(s):s}async function Mt(t){let{authorization:r,signature:e}=t;return Pe({hash:Ke(r),signature:e??r})}function Xe(t,{docsPath:r,...e}){let o=(()=>{let n=At(t,e);return n instanceof kt?t:n})();return new Se(o,{docsPath:r,...e})}async function H(t,{blockHash:r,blockNumber:e,blockTag:o,includeTransactions:n}={}){let s=o??"latest",a=n??!1,u=e!==void 0?A(e):void 0,c=null;if(r?c=await t.request({method:"eth_getBlockByHash",params:[r,a]},{dedupe:!0}):c=await t.request({method:"eth_getBlockByNumber",params:[u||s,a]},{dedupe:!!u}),!c)throw new Bt({blockHash:r,blockNumber:e});return(t.chain?.formatters?.block?.format||Fe)(c)}async function jt(t){let r=await t.request({method:"eth_gasPrice"});return BigInt(r)}async function Ze(t,r){let{block:e,chain:o=t.chain,request:n}=r||{};try{let s=o?.fees?.maxPriorityFeePerGas??o?.fees?.defaultPriorityFee;if(typeof s=="function"){let u=e||await I(t,H,"getBlock")({}),c=await s({block:u,client:t,request:n});if(c===null)throw new Error;return c}if(typeof s<"u")return s;let a=await t.request({method:"eth_maxPriorityFeePerGas"});return yt(a)}catch{let[s,a]=await Promise.all([e?Promise.resolve(e):I(t,H,"getBlock")({}),I(t,jt,"getGasPrice")({})]);if(typeof s.baseFeePerGas!="bigint")throw new tt;let u=a-s.baseFeePerGas;return u<0n?0n:u}}async function Xt(t,r){let{block:e,chain:o=t.chain,request:n,type:s="eip1559"}=r||{},a=await(async()=>typeof o?.fees?.baseFeeMultiplier=="function"?o.fees.baseFeeMultiplier({block:e,client:t,request:n}):o?.fees?.baseFeeMultiplier??1.2)();if(a<1)throw new ke;let c=10**(a.toString().split(".")[1]?.length??0),i=d=>d*BigInt(Math.ceil(a*c))/BigInt(c),f=e||await I(t,H,"getBlock")({});if(typeof o?.fees?.estimateFeesPerGas=="function"){let d=await o.fees.estimateFeesPerGas({block:e,client:t,multiply:i,request:n,type:s});if(d!==null)return d}if(s==="eip1559"){if(typeof f.baseFeePerGas!="bigint")throw new tt;let d=typeof n?.maxPriorityFeePerGas=="bigint"?n.maxPriorityFeePerGas:await Ze(t,{block:f,chain:o,request:n}),l=i(f.baseFeePerGas);return{maxFeePerGas:n?.maxFeePerGas??l+d,maxPriorityFeePerGas:d}}return{gasPrice:n?.gasPrice??i(await I(t,jt,"getGasPrice")({}))}}async function Qe(t,{address:r,blockTag:e="latest",blockNumber:o}){let n=await t.request({method:"eth_getTransactionCount",params:[r,typeof o=="bigint"?A(o):e]},{dedupe:!!o});return bt(n)}async function Gt(t){let r=await t.request({method:"eth_chainId"},{dedupe:!0});return bt(r)}var Ot=["blobVersionedHashes","chainId","fees","gas","nonce","type"],Ye=new Map;async function K(t,r){let{account:e=t.account,blobs:o,chain:n,gas:s,kzg:a,nonce:u,nonceManager:c,parameters:i=Ot,type:f}=r,m=e&&R(e),d={...r,...m?{from:m?.address}:{}},l;async function x(){return l||(l=await I(t,H,"getBlock")({blockTag:"latest"}),l)}let w;async function v(){return w||(n?n.id:typeof r.chainId<"u"?r.chainId:(w=await I(t,Gt,"getChainId")({}),w))}if(i.includes("nonce")&&typeof u>"u"&&m)if(c){let y=await v();d.nonce=await c.consume({address:m.address,chainId:y,client:t})}else d.nonce=await I(t,Qe,"getTransactionCount")({address:m.address,blockTag:"pending"});if((i.includes("blobVersionedHashes")||i.includes("sidecars"))&&o&&a){let y=Be({blobs:o,kzg:a});if(i.includes("blobVersionedHashes")){let b=Re({commitments:y,to:"hex"});d.blobVersionedHashes=b}if(i.includes("sidecars")){let b=Ne({blobs:o,commitments:y,kzg:a}),C=qe({blobs:o,commitments:y,proofs:b,to:"hex"});d.sidecars=C}}if(i.includes("chainId")&&(d.chainId=await v()),(i.includes("fees")||i.includes("type"))&&typeof f>"u")try{d.type=Me(d)}catch{let y=Ye.get(t.uid);typeof y>"u"&&(y=typeof(await x())?.baseFeePerGas=="bigint",Ye.set(t.uid,y)),d.type=y?"eip1559":"legacy"}if(i.includes("fees"))if(d.type!=="legacy"&&d.type!=="eip2930"){if(typeof d.maxFeePerGas>"u"||typeof d.maxPriorityFeePerGas>"u"){let y=await x(),{maxFeePerGas:b,maxPriorityFeePerGas:C}=await Xt(t,{block:y,chain:n,request:d});if(typeof r.maxPriorityFeePerGas>"u"&&r.maxFeePerGas&&r.maxFeePerGas<C)throw new Ae({maxPriorityFeePerGas:C});d.maxPriorityFeePerGas=C,d.maxFeePerGas=b}}else{if(typeof r.maxFeePerGas<"u"||typeof r.maxPriorityFeePerGas<"u")throw new tt;if(typeof r.gasPrice>"u"){let y=await x(),{gasPrice:b}=await Xt(t,{block:y,chain:n,request:d,type:"legacy"});d.gasPrice=b}}return i.includes("gas")&&typeof s>"u"&&(d.gas=await I(t,it,"estimateGas")({...d,account:m&&{address:m.address,type:"json-rpc"}})),Y(d),delete d.parameters,d}async function at(t,{address:r,blockNumber:e,blockTag:o="latest"}){let n=typeof e=="bigint"?A(e):void 0,s=await t.request({method:"eth_getBalance",params:[r,n||o]});return BigInt(s)}async function it(t,r){let{account:e=t.account}=r,o=e?R(e):void 0;try{let k=function(F){let{block:M,request:D,rpcStateOverride:L}=F;return t.request({method:"eth_estimateGas",params:L?[D,M??"pending",L]:M?[D,M]:[D]})},{accessList:n,authorizationList:s,blobs:a,blobVersionedHashes:u,blockNumber:c,blockTag:i,data:f,gas:m,gasPrice:d,maxFeePerBlobGas:l,maxFeePerGas:x,maxPriorityFeePerGas:w,nonce:v,value:y,stateOverride:b,...C}=await K(t,{...r,parameters:o?.type==="local"?void 0:["blobVersionedHashes"]}),p=(typeof c=="bigint"?A(c):void 0)||i,h=Ee(b),g=await(async()=>{if(C.to)return C.to;if(s&&s.length>0)return await Mt({authorization:s[0]}).catch(()=>{throw new z("`to` is required. Could not infer from `authorizationList`")})})();Y(r);let P=t.chain?.formatters?.transactionRequest?.format,E=(P||Ft)({..._t(C,{format:P}),from:o?.address,accessList:n,authorizationList:s,blobs:a,blobVersionedHashes:u,data:f,gas:m,gasPrice:d,maxFeePerBlobGas:l,maxFeePerGas:x,maxPriorityFeePerGas:w,nonce:v,to:g,value:y}),B=BigInt(await k({block:p,request:E,rpcStateOverride:h}));if(s){let F=await at(t,{address:E.from}),M=await Promise.all(s.map(async D=>{let{address:L}=D,Fr=await k({block:p,request:{authorizationList:void 0,data:f,from:o?.address,to:L,value:A(F)},rpcStateOverride:h}).catch(()=>100000n);return 2n*BigInt(Fr)}));B+=M.reduce((D,L)=>D+L,0n)}return B}catch(n){throw Xe(n,{...r,account:o,chain:t.chain})}}async function ct(t,r){let{abi:e,address:o,args:n,functionName:s,...a}=r,u=Q({abi:e,args:n,functionName:s});try{let{data:c}=await I(t,nt,"call")({...a,data:u,to:o});return Nt({abi:e,args:n,functionName:s,data:c||"0x"})}catch(c){throw V(c,{abi:e,address:o,args:n,docsPath:"/docs/contract/readContract",functionName:s})}}var Zt=new Map,tr=new Map,Br=0;function X(t,r,e){let o=++Br,n=()=>Zt.get(t)||[],s=()=>{let f=n();Zt.set(t,f.filter(m=>m.id!==o))},a=()=>{let f=n();if(!f.some(d=>d.id===o))return;let m=tr.get(t);f.length===1&&m&&m(),s()},u=n();if(Zt.set(t,[...u,{id:o,fns:r}]),u&&u.length>0)return a;let c={};for(let f in r)c[f]=(...m)=>{let d=n();if(d.length!==0)for(let l of d)l.fns[f]?.(...m)};let i=e(c);return typeof i=="function"&&tr.set(t,i),a}function zt(t,{emitOnBegin:r,initialWaitTime:e,interval:o}){let n=!0,s=()=>n=!1;return(async()=>{let u;r&&(u=await t({unpoll:s}));let c=await e?.(u)??o;await Kt(c);let i=async()=>{n&&(await t({unpoll:s}),await Kt(o),i())};i()})(),s}var Nr=t=>`blockNumber.${t}`;async function er(t,{cacheTime:r=t.cacheTime}={}){let e=await De(()=>t.request({method:"eth_blockNumber"}),{cacheKey:Nr(t.uid),cacheTime:r});return BigInt(e)}async function rr(t,{filter:r}){let e="strict"in r&&r.strict,o=await r.request({method:"eth_getFilterChanges",params:[r.id]});if(typeof o[0]=="string")return o;let n=o.map(s=>Ge(s));return!("abi"in r)||!r.abi?n:je({abi:r.abi,logs:n,strict:e})}async function or(t,{filter:r}){return r.request({method:"eth_uninstallFilter",params:[r.id]})}var U=class extends z{constructor({docsPath:r}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:r,docsSlug:"account",name:"AccountNotFoundError"})}},et=class extends z{constructor({docsPath:r,metaMessages:e,type:o}){super(`Account type "${o}" is not supported.`,{docsPath:r,metaMessages:e,name:"AccountTypeNotSupportedError"})}};function nr(t,{docsPath:r,...e}){let o=(()=>{let n=At(t,e);return n instanceof kt?t:n})();return new be(o,{docsPath:r,...e})}async function sr(t,{serializedTransaction:r}){return t.request({method:"eth_sendRawTransaction",params:[r]},{retryCount:0})}var Qt=new we(128);async function ut(t,r){let{account:e=t.account,chain:o=t.chain,accessList:n,authorizationList:s,blobs:a,data:u,gas:c,gasPrice:i,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:d,nonce:l,type:x,value:w,...v}=r;if(typeof e>"u")throw new U({docsPath:"/docs/actions/wallet/sendTransaction"});let y=e?R(e):null;try{Y(r);let b=await(async()=>{if(r.to)return r.to;if(r.to!==null&&s&&s.length>0)return await Mt({authorization:s[0]}).catch(()=>{throw new z("`to` is required. Could not infer from `authorizationList`.")})})();if(y?.type==="json-rpc"||y===null){let C;o!==null&&(C=await I(t,Gt,"getChainId")({}),Le({currentChainId:C,chain:o}));let S=t.chain?.formatters?.transactionRequest?.format,h=(S||Ft)({..._t(v,{format:S}),accessList:n,authorizationList:s,blobs:a,chainId:C,data:u,from:y?.address,gas:c,gasPrice:i,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:d,nonce:l,to:b,type:x,value:w}),g=Qt.get(t.uid),P=g?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:P,params:[h]},{retryCount:0})}catch(T){if(g===!1)throw T;let E=T;if(E.name==="InvalidInputRpcError"||E.name==="InvalidParamsRpcError"||E.name==="MethodNotFoundRpcError"||E.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[h]},{retryCount:0}).then(k=>(Qt.set(t.uid,!0),k)).catch(k=>{let B=k;throw B.name==="MethodNotFoundRpcError"||B.name==="MethodNotSupportedRpcError"?(Qt.set(t.uid,!1),E):B});throw E}}if(y?.type==="local"){let C=await I(t,K,"prepareTransactionRequest")({account:y,accessList:n,authorizationList:s,blobs:a,chain:o,data:u,gas:c,gasPrice:i,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:d,nonce:l,nonceManager:y.nonceManager,parameters:[...Ot,"sidecars"],type:x,value:w,...v,to:b}),S=o?.serializers?.transaction,p=await y.signTransaction(C,{serializer:S});return await I(t,sr,"sendRawTransaction")({serializedTransaction:p})}throw y?.type==="smart"?new et({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new et({docsPath:"/docs/actions/wallet/sendTransaction",type:y?.type})}catch(b){throw b instanceof et?b:nr(b,{...r,account:y,chain:r.chain||void 0})}}async function Yt(t,r){let{abi:e,account:o=t.account,address:n,args:s,dataSuffix:a,functionName:u,...c}=r;if(typeof o>"u")throw new U({docsPath:"/docs/contract/writeContract"});let i=o?R(o):null,f=Q({abi:e,args:s,functionName:u});try{return await I(t,ut,"sendTransaction")({data:`${f}${a?a.replace("0x",""):""}`,to:n,account:i,...c})}catch(m){throw V(m,{abi:e,address:n,args:s,docsPath:"/docs/contract/writeContract",functionName:u,sender:i?.address})}}async function ir(t){let r=Ve(t,{method:"eth_newPendingTransactionFilter"}),e=await t.request({method:"eth_newPendingTransactionFilter"});return{id:e,request:r(e),type:"transaction"}}function Rr(t,{body:r,onError:e,onResponse:o}){return t.request({body:r,onError:e,onResponse:o}),t}async function qr(t,{body:r,timeout:e=1e4}){return t.requestAsync({body:r,timeout:e})}var ft={http(t,r){return We(t).request(r)},webSocket:Rr,webSocketAsync:qr};async function dt(t,{blockHash:r,blockNumber:e,blockTag:o,hash:n,index:s}){let a=o||"latest",u=e!==void 0?A(e):void 0,c=null;if(n?c=await t.request({method:"eth_getTransactionByHash",params:[n]},{dedupe:!0}):r?c=await t.request({method:"eth_getTransactionByBlockHashAndIndex",params:[r,A(s)]},{dedupe:!0}):(u||a)&&(c=await t.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[u||a,A(s)]},{dedupe:!!u})),!c)throw new Pt({blockHash:r,blockNumber:e,blockTag:a,hash:n,index:s});return(t.chain?.formatters?.transaction?.format||_e)(c)}async function te(t,{hash:r}){let e=await t.request({method:"eth_getTransactionReceipt",params:[r]},{dedupe:!0});if(!e)throw new It({hash:r});return(t.chain?.formatters?.transactionReceipt?.format||Ue)(e)}async function ee(t,r){let{account:e,allowFailure:o=!0,batchSize:n,blockNumber:s,blockTag:a,multicallAddress:u,stateOverride:c}=r,i=r.contracts,f=n??(typeof t.batch?.multicall=="object"&&t.batch.multicall.batchSize||1024),m=u;if(!m){if(!t.chain)throw new Error("client chain not configured. multicallAddress is required.");m=ze({blockNumber:s,chain:t.chain,contract:"multicall3"})}let d=[[]],l=0,x=0;for(let y=0;y<i.length;y++){let{abi:b,address:C,args:S,functionName:p}=i[y];try{let h=Q({abi:b,args:S,functionName:p});x+=(h.length-2)/2,f>0&&x>f&&d[l].length>0&&(l++,x=(h.length-2)/2,d[l]=[]),d[l]=[...d[l],{allowFailure:!0,callData:h,target:C}]}catch(h){let g=V(h,{abi:b,address:C,args:S,docsPath:"/docs/contract/multicall",functionName:p,sender:e});if(!o)throw g;d[l]=[...d[l],{allowFailure:!0,callData:"0x",target:C}]}}let w=await Promise.allSettled(d.map(y=>I(t,ct,"readContract")({abi:Oe,account:e,address:m,args:[y],blockNumber:s,blockTag:a,functionName:"aggregate3",stateOverride:c}))),v=[];for(let y=0;y<w.length;y++){let b=w[y];if(b.status==="rejected"){if(!o)throw b.reason;for(let S=0;S<d[y].length;S++)v.push({status:"failure",error:b.reason,result:void 0});continue}let C=b.value;for(let S=0;S<C.length;S++){let{returnData:p,success:h}=C[S],{callData:g}=d[y][S],{abi:P,address:T,functionName:E,args:k}=i[v.length];try{if(g==="0x")throw new le;if(!h)throw new Te({data:p});let B=Nt({abi:P,args:k,data:p,functionName:E});v.push(o?{result:B,status:"success"}:B)}catch(B){let F=V(B,{abi:P,address:T,args:k,docsPath:"/docs/contract/multicall",functionName:E});if(!o)throw F;v.push({error:F,result:void 0,status:"failure"})}}}if(v.length!==i.length)throw new z("multicall results mismatch");return v}function ar(t,{emitOnBegin:r=!1,emitMissed:e=!1,onBlockNumber:o,onError:n,poll:s,pollingInterval:a=t.pollingInterval}){let u=typeof s<"u"?s:!(t.transport.type==="webSocket"||t.transport.type==="fallback"&&t.transport.transports[0].config.type==="webSocket"),c;return u?(()=>{let m=J(["watchBlockNumber",t.uid,r,e,a]);return X(m,{onBlockNumber:o,onError:n},d=>zt(async()=>{try{let l=await I(t,er,"getBlockNumber")({cacheTime:0});if(c){if(l===c)return;if(l-c>1&&e)for(let x=c+1n;x<l;x++)d.onBlockNumber(x,c),c=x}(!c||l>c)&&(d.onBlockNumber(l,c),c=l)}catch(l){d.onError?.(l)}},{emitOnBegin:r,interval:a}))})():(()=>{let m=J(["watchBlockNumber",t.uid,r,e]);return X(m,{onBlockNumber:o,onError:n},d=>{let l=!0,x=()=>l=!1;return(async()=>{try{let w=(()=>{if(t.transport.type==="fallback"){let y=t.transport.transports.find(b=>b.config.type==="webSocket");return y?y.value:t.transport}return t.transport})(),{unsubscribe:v}=await w.subscribe({params:["newHeads"],onData(y){if(!l)return;let b=yt(y.result?.number);d.onBlockNumber(b,c),c=b},onError(y){d.onError?.(y)}});x=v,l||x()}catch(w){n?.(w)}})(),()=>x()})})()}async function re(t,{confirmations:r=1,hash:e,onReplaced:o,pollingInterval:n=t.pollingInterval,retryCount:s=6,retryDelay:a=({count:c})=>~~(1<<c)*200,timeout:u=18e4}){let c=J(["waitForTransactionReceipt",t.uid,e]),i,f,m,d=!1,l,x,{promise:w,resolve:v,reject:y}=He(),b=u?setTimeout(()=>{x(),l(),y(new ve({hash:e}))},u):void 0;return l=X(c,{onReplaced:o,resolve:v,reject:y},C=>{x=I(t,ar,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:n,async onBlockNumber(S){let p=g=>{clearTimeout(b),x(),g(),l()},h=S;if(!d)try{if(m){if(r>1&&(!m.blockNumber||h-m.blockNumber+1n<r))return;p(()=>C.resolve(m));return}if(i||(d=!0,await st(async()=>{i=await I(t,dt,"getTransaction")({hash:e}),i.blockNumber&&(h=i.blockNumber)},{delay:a,retryCount:s}),d=!1),m=await I(t,te,"getTransactionReceipt")({hash:e}),r>1&&(!m.blockNumber||h-m.blockNumber+1n<r))return;p(()=>C.resolve(m))}catch(g){if(g instanceof Pt||g instanceof It){if(!i){d=!1;return}try{f=i,d=!0;let P=await st(()=>I(t,H,"getBlock")({blockNumber:h,includeTransactions:!0}),{delay:a,retryCount:s,shouldRetry:({error:k})=>k instanceof Bt});d=!1;let T=P.transactions.find(({from:k,nonce:B})=>k===f.from&&B===f.nonce);if(!T||(m=await I(t,te,"getTransactionReceipt")({hash:T.hash}),r>1&&(!m.blockNumber||h-m.blockNumber+1n<r)))return;let E="replaced";T.to===f.to&&T.value===f.value&&T.input===f.input?E="repriced":T.from===T.to&&T.value===0n&&(E="cancelled"),p(()=>{C.onReplaced?.({reason:E,replacedTransaction:f,transaction:T,transactionReceipt:m}),C.resolve(m)})}catch(P){p(()=>C.reject(P))}}else p(()=>C.reject(g))}}})}),w}function oe(t,{batch:r=!0,onError:e,onTransactions:o,poll:n,pollingInterval:s=t.pollingInterval}){return(typeof n<"u"?n:t.transport.type!=="webSocket")?(()=>{let i=J(["watchPendingTransactions",t.uid,r,s]);return X(i,{onTransactions:o,onError:e},f=>{let m,d=zt(async()=>{try{if(!m)try{m=await I(t,ir,"createPendingTransactionFilter")({});return}catch(x){throw d(),x}let l=await I(t,rr,"getFilterChanges")({filter:m});if(l.length===0)return;if(r)f.onTransactions(l);else for(let x of l)f.onTransactions([x])}catch(l){f.onError?.(l)}},{emitOnBegin:!0,interval:s});return async()=>{m&&await I(t,or,"uninstallFilter")({filter:m}),d()}})})():(()=>{let i=!0,f=()=>i=!1;return(async()=>{try{let{unsubscribe:m}=await t.transport.subscribe({params:["newPendingTransactions"],onData(d){if(!i)return;let l=d.result;o([l])},onError(d){e?.(d)}});f=m,i||f()}catch(m){e?.(m)}})(),()=>f()})()}async function ne(t,{account:r=t.account,message:e}){if(!r)throw new U({docsPath:"/docs/actions/wallet/signMessage"});let o=R(r);if(o.signMessage)return o.signMessage({message:e});let n=typeof e=="string"?Ct(e):e.raw instanceof Uint8Array?he(e.raw):e.raw;return t.request({method:"personal_sign",params:[n,o.address]},{retryCount:0})}var rt="2.17.2";var cr=()=>`@wagmi/core@${rt}`;var ur=function(t,r,e,o){if(e==="a"&&!o)throw new TypeError("Private accessor was defined without a getter");if(typeof r=="function"?t!==r||!o:!r.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?o:e==="a"?o.call(t):o?o.value:r.get(t)},Ht,fr,q=class t extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return cr()}constructor(r,e={}){super(),Ht.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});let o=e.cause instanceof t?e.cause.details:e.cause?.message?e.cause.message:e.details,n=e.cause instanceof t&&e.cause.docsPath||e.docsPath;this.message=[r||"An error occurred.","",...e.metaMessages?[...e.metaMessages,""]:[],...n?[`Docs: ${this.docsBaseUrl}${n}.html${e.docsSlug?`#${e.docsSlug}`:""}`]:[],...o?[`Details: ${o}`]:[],`Version: ${this.version}`].join(`
`),e.cause&&(this.cause=e.cause),this.details=o,this.docsPath=n,this.metaMessages=e.metaMessages,this.shortMessage=r}walk(r){return ur(this,Ht,"m",fr).call(this,this,r)}};Ht=new WeakSet,fr=function t(r,e){return e?.(r)?r:r.cause?ur(this,Ht,"m",t).call(this,r.cause,e):r};var G=class extends q{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}},mt=class extends q{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}},Z=class extends q{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}};var lt=class extends q{constructor({address:r,connector:e}){super(`Account "${r}" not found for connector "${e.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}},pt=class extends q{constructor({connectionChainId:r,connectorChainId:e}){super(`The current chain of the connector (id: ${e}) does not match the connection's chain (id: ${r}).`,{metaMessages:[`Current Chain ID:  ${e}`,`Expected Chain ID: ${r}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}},ht=class extends q{constructor({connector:r}){super(`Connector "${r.name}" unavailable while reconnecting.`,{details:["During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.","All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.","This error commonly occurs for connectors that asynchronously inject after reconnection has already started."].join(" ")}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}};var O=class extends q{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}},gt=class extends q{constructor({connector:r}){super(`"${r.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}};wt.type="injected";function wt(t={}){let{shimDisconnect:r=!0,unstable_shimAsyncInject:e}=t;function o(){let c=t.target;if(typeof c=="function"){let i=c();if(i)return i}return typeof c=="object"?c:typeof c=="string"?{...Mr[c]??{id:c,name:`${c[0].toUpperCase()}${c.slice(1)}`,provider:`is${c[0].toUpperCase()}${c.slice(1)}`}}:{id:"injected",name:"Injected",provider(i){return i?.ethereum}}}let n,s,a,u;return c=>({get icon(){return o().icon},get id(){return o().id},get name(){return o().name},get supportsSimulation(){return!0},type:wt.type,async setup(){let i=await this.getProvider();i?.on&&t.target&&(a||(a=this.onConnect.bind(this),i.on("connect",a)),n||(n=this.onAccountsChanged.bind(this),i.on("accountsChanged",n)))},async connect({chainId:i,isReconnecting:f}={}){let m=await this.getProvider();if(!m)throw new O;let d=[];if(f)d=await this.getAccounts().catch(()=>[]);else if(r)try{d=(await m.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0]?.caveats?.[0]?.value?.map(x=>j(x)),d.length>0&&(d=await this.getAccounts())}catch(l){let x=l;if(x.code===N.code)throw new N(x);if(x.code===Et.code)throw x}try{!d?.length&&!f&&(d=(await m.request({method:"eth_requestAccounts"})).map(w=>j(w))),a&&(m.removeListener("connect",a),a=void 0),n||(n=this.onAccountsChanged.bind(this),m.on("accountsChanged",n)),s||(s=this.onChainChanged.bind(this),m.on("chainChanged",s)),u||(u=this.onDisconnect.bind(this),m.on("disconnect",u));let l=await this.getChainId();return i&&l!==i&&(l=(await this.switchChain({chainId:i}).catch(w=>{if(w.code===N.code)throw w;return{id:l}}))?.id??l),r&&await c.storage?.removeItem(`${this.id}.disconnected`),t.target||await c.storage?.setItem("injected.connected",!0),{accounts:d,chainId:l}}catch(l){let x=l;throw x.code===N.code?new N(x):x.code===Et.code?new Et(x):x}},async disconnect(){let i=await this.getProvider();if(!i)throw new O;s&&(i.removeListener("chainChanged",s),s=void 0),u&&(i.removeListener("disconnect",u),u=void 0),a||(a=this.onConnect.bind(this),i.on("connect",a));try{await $e(()=>i.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}r&&await c.storage?.setItem(`${this.id}.disconnected`,!0),t.target||await c.storage?.removeItem("injected.connected")},async getAccounts(){let i=await this.getProvider();if(!i)throw new O;return(await i.request({method:"eth_accounts"})).map(m=>j(m))},async getChainId(){let i=await this.getProvider();if(!i)throw new O;let f=await i.request({method:"eth_chainId"});return Number(f)},async getProvider(){if(typeof window>"u")return;let i,f=o();return typeof f.provider=="function"?i=f.provider(window):typeof f.provider=="string"?i=Dt(window,f.provider):i=f.provider,i&&!i.removeListener&&("off"in i&&typeof i.off=="function"?i.removeListener=i.off:i.removeListener=()=>{}),i},async isAuthorized(){try{if(r&&await c.storage?.getItem(`${this.id}.disconnected`)||!t.target&&!await c.storage?.getItem("injected.connected"))return!1;if(!await this.getProvider()){if(e!==void 0&&e!==!1){let d=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",d),!!await this.getProvider()),l=typeof e=="number"?e:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(w=>window.addEventListener("ethereum#initialized",()=>w(d()),{once:!0}))]:[],new Promise(w=>setTimeout(()=>w(d()),l))]))return!0}throw new O}return!!(await st(()=>this.getAccounts())).length}catch{return!1}},async switchChain({addEthereumChainParameter:i,chainId:f}){let m=await this.getProvider();if(!m)throw new O;let d=c.chains.find(x=>x.id===f);if(!d)throw new ot(new G);let l=new Promise(x=>{let w=v=>{"chainId"in v&&v.chainId===f&&(c.emitter.off("change",w),x())};c.emitter.on("change",w)});try{return await Promise.all([m.request({method:"wallet_switchEthereumChain",params:[{chainId:A(f)}]}).then(async()=>{await this.getChainId()===f&&c.emitter.emit("change",{chainId:f})}),l]),d}catch(x){let w=x;if(w.code===4902||w?.data?.originalError?.code===4902)try{let{default:v,...y}=d.blockExplorers??{},b;i?.blockExplorerUrls?b=i.blockExplorerUrls:v&&(b=[v.url,...Object.values(y).map(p=>p.url)]);let C;i?.rpcUrls?.length?C=i.rpcUrls:C=[d.rpcUrls.default?.http[0]??""];let S={blockExplorerUrls:b,chainId:A(f),chainName:i?.chainName??d.name,iconUrls:i?.iconUrls,nativeCurrency:i?.nativeCurrency??d.nativeCurrency,rpcUrls:C};return await Promise.all([m.request({method:"wallet_addEthereumChain",params:[S]}).then(async()=>{if(await this.getChainId()===f)c.emitter.emit("change",{chainId:f});else throw new N(new Error("User rejected switch after adding network."))}),l]),d}catch(v){throw new N(v)}throw w.code===N.code?new N(w):new ot(w)}},async onAccountsChanged(i){if(i.length===0)this.onDisconnect();else if(c.emitter.listenerCount("connect")){let f=(await this.getChainId()).toString();this.onConnect({chainId:f}),r&&await c.storage?.removeItem(`${this.id}.disconnected`)}else c.emitter.emit("change",{accounts:i.map(f=>j(f))})},onChainChanged(i){let f=Number(i);c.emitter.emit("change",{chainId:f})},async onConnect(i){let f=await this.getAccounts();if(f.length===0)return;let m=Number(i.chainId);c.emitter.emit("connect",{accounts:f,chainId:m});let d=await this.getProvider();d&&(a&&(d.removeListener("connect",a),a=void 0),n||(n=this.onAccountsChanged.bind(this),d.on("accountsChanged",n)),s||(s=this.onChainChanged.bind(this),d.on("chainChanged",s)),u||(u=this.onDisconnect.bind(this),d.on("disconnect",u)))},async onDisconnect(i){let f=await this.getProvider();i&&i.code===1013&&f&&(await this.getAccounts()).length||(c.emitter.emit("disconnect"),f&&(s&&(f.removeListener("chainChanged",s),s=void 0),u&&(f.removeListener("disconnect",u),u=void 0),a||(a=this.onConnect.bind(this),f.on("connect",a))))}})}var Mr={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(t){return t?.coinbaseWalletExtension?t.coinbaseWalletExtension:Dt(t,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(t){return Dt(t,r=>{if(!r.isMetaMask||r.isBraveWallet&&!r._events&&!r._state)return!1;let e=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPhantom","isPortal","isRabby","isTokenPocket","isTokenary","isUniswapWallet","isZerion"];for(let o of e)if(r[o])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(t){return t?.phantom?.ethereum?t.phantom?.ethereum:Dt(t,"isPhantom")}}};function Dt(t,r){function e(n){return typeof r=="function"?r(n):typeof r=="string"?n[r]:!0}let o=t.ethereum;if(o?.providers)return o.providers.find(n=>e(n));if(o&&e(o))return o}se.type="mock";function se(t){let r=new Map,e=t.features??{defaultConnected:!1},o=e.defaultConnected,n;return s=>({id:"mock",name:"Mock Connector",type:se.type,async setup(){n=s.chains[0].id},async connect({chainId:a}={}){if(e.connectError)throw typeof e.connectError=="boolean"?new N(new Error("Failed to connect.")):e.connectError;let c=await(await this.getProvider()).request({method:"eth_requestAccounts"}),i=await this.getChainId();return a&&i!==a&&(i=(await this.switchChain({chainId:a})).id),o=!0,{accounts:c.map(f=>j(f)),chainId:i}},async disconnect(){o=!1},async getAccounts(){if(!o)throw new Z;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>j(c))},async getChainId(){let u=await(await this.getProvider()).request({method:"eth_chainId"});return Jt(u,"number")},async isAuthorized(){return!e.reconnect||!o?!1:!!(await this.getAccounts()).length},async switchChain({chainId:a}){let u=await this.getProvider(),c=s.chains.find(i=>i.id===a);if(!c)throw new ot(new G);return await u.request({method:"wallet_switchEthereumChain",params:[{chainId:A(a)}]}),c},onAccountsChanged(a){a.length===0?this.onDisconnect():s.emitter.emit("change",{accounts:a.map(u=>j(u))})},onChainChanged(a){let u=Number(a);s.emitter.emit("change",{chainId:u})},async onDisconnect(a){s.emitter.emit("disconnect"),o=!1},async getProvider({chainId:a}={}){let c=(s.chains.find(f=>f.id===a)??s.chains[0]).rpcUrls.default.http[0];return qt({request:async({method:f,params:m})=>{if(f==="eth_chainId")return A(n);if(f==="eth_requestAccounts")return t.accounts;if(f==="eth_signTypedData_v4"&&e.signTypedDataError)throw typeof e.signTypedDataError=="boolean"?new N(new Error("Failed to sign typed data.")):e.signTypedDataError;if(f==="wallet_switchEthereumChain"){if(e.switchChainError)throw typeof e.switchChainError=="boolean"?new N(new Error("Failed to switch chain.")):e.switchChainError;n=Jt(m[0].chainId,"number"),this.onChainChanged(n.toString());return}if(f==="wallet_watchAsset"){if(e.watchAssetError)throw typeof e.watchAssetError=="boolean"?new N(new Error("Failed to switch chain.")):e.watchAssetError;return o}if(f==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:m[0]==="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:m[0]==="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"}}};if(f==="wallet_sendCalls"){let w=[],v=m[0].calls;for(let b of v){let{result:C,error:S}=await ft.http(c,{body:{method:"eth_sendTransaction",params:[b]}});if(S)throw new St({body:{method:f,params:m},error:S,url:c});w.push(C)}let y=Tt(Ct(JSON.stringify(v)));return r.set(y,w),{id:y}}if(f==="wallet_getCallsStatus"){let w=r.get(m[0]);if(!w)return{atomic:!1,chainId:"0x1",id:m[0],status:100,receipts:[],version:"2.0.0"};let y=(await Promise.all(w.map(async b=>{let{result:C,error:S}=await ft.http(c,{body:{method:"eth_getTransactionReceipt",params:[b],id:0}});if(S)throw new St({body:{method:f,params:m},error:S,url:c});return C?{blockHash:C.blockHash,blockNumber:C.blockNumber,gasUsed:C.gasUsed,logs:C.logs,status:C.status,transactionHash:C.transactionHash}:null}))).filter(b=>b!==null);return y.length===0?{atomic:!1,chainId:"0x1",id:m[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:m[0],status:200,receipts:y,version:"2.0.0"}}if(f==="wallet_showCallsStatus")return;if(f==="personal_sign"){if(e.signMessageError)throw typeof e.signMessageError=="boolean"?new N(new Error("Failed to sign message.")):e.signMessageError;f="eth_sign",m=[m[1],m[0]]}let d={method:f,params:m},{error:l,result:x}=await ft.http(c,{body:d});if(l)throw new St({body:d,error:l,url:c});return x}})({retryCount:0})}})}function _(t,r,e){let o=t[r.name];if(typeof o=="function")return o;let n=t[e];return typeof n=="function"?n:s=>r(t,s)}async function jr(t,r){let e;if(typeof r.connector=="function"?e=t._internal.connectors.setup(r.connector):e=r.connector,e.uid===t.state.current)throw new mt;try{t.setState(u=>({...u,status:"connecting"})),e.emitter.emit("message",{type:"connecting"});let{connector:o,...n}=r,s=await e.connect(n),a=s.accounts;return e.emitter.off("connect",t._internal.events.connect),e.emitter.on("change",t._internal.events.change),e.emitter.on("disconnect",t._internal.events.disconnect),await t.storage?.setItem("recentConnectorId",e.id),t.setState(u=>({...u,connections:new Map(u.connections).set(e.uid,{accounts:a,chainId:s.chainId,connector:e}),current:e.uid,status:"connected"})),{accounts:a,chainId:s.chainId}}catch(o){throw t.setState(n=>({...n,status:n.current?"connected":"disconnected"})),o}}async function $(t,r={}){let e;if(r.connector){let{connector:i}=r;if(t.state.status==="reconnecting"&&!i.getAccounts&&!i.getChainId)throw new ht({connector:i});let[f,m]=await Promise.all([i.getAccounts().catch(d=>{if(r.account===null)return[];throw d}),i.getChainId()]);e={accounts:f,chainId:m,connector:i}}else e=t.state.connections.get(t.state.current);if(!e)throw new Z;let o=r.chainId??e.chainId,n=await e.connector.getChainId();if(n!==e.chainId)throw new pt({connectionChainId:e.chainId,connectorChainId:n});let s=e.connector;if(s.getClient)return s.getClient({chainId:o});let a=R(r.account??e.accounts[0]);if(a&&(a.address=j(a.address)),r.account&&!e.accounts.some(i=>i.toLowerCase()===a.address.toLowerCase()))throw new lt({address:a.address,connector:s});let u=t.chains.find(i=>i.id===o),c=await e.connector.getProvider({chainId:o});return Rt({account:a,chain:u,name:"Connector Client",transport:i=>qt(c)({...i,retryCount:0})})}async function Gr(t,r={}){let e;if(r.connector)e=r.connector;else{let{connections:n,current:s}=t.state;e=n.get(s)?.connector}let o=t.state.connections;e&&(await e.disconnect(),e.emitter.off("change",t._internal.events.change),e.emitter.off("disconnect",t._internal.events.disconnect),e.emitter.on("connect",t._internal.events.connect),o.delete(e.uid)),t.setState(n=>{if(o.size===0)return{...n,connections:new Map,current:null,status:"disconnected"};let s=o.values().next().value;return{...n,connections:new Map(o),current:s.connector.uid}});{let n=t.state.current;if(!n)return;let s=t.state.connections.get(n)?.connector;if(!s)return;await t.storage?.setItem("recentConnectorId",s.id)}}async function Or(t,r){let{chainId:e,connector:o,...n}=r,s;r.account?s=r.account:s=(await $(t,{account:r.account,chainId:e,connector:o})).account;let a=t.getClient({chainId:e});return _(a,it,"estimateGas")({...n,account:s})}function ie(t){return typeof t=="number"?t:t==="wei"?0:Math.abs(ye[t])}function xt(t){let r=t.state.current,e=t.state.connections.get(r),o=e?.accounts,n=o?.[0],s=t.chains.find(u=>u.id===e?.chainId),a=t.state.status;switch(a){case"connected":return{address:n,addresses:o,chain:s,chainId:e?.chainId,connector:e?.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:a};case"reconnecting":return{address:n,addresses:o,chain:s,chainId:e?.chainId,connector:e?.connector,isConnected:!!n,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:a};case"connecting":return{address:n,addresses:o,chain:s,chainId:e?.chainId,connector:e?.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:a};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:a}}}async function dr(t,r){let{allowFailure:e=!0,chainId:o,contracts:n,...s}=r,a=t.getClient({chainId:o});return _(a,ee,"multicall")({allowFailure:e,contracts:n,...s})}function mr(t,r){let{chainId:e,...o}=r,n=t.getClient({chainId:e});return _(n,ct,"readContract")(o)}async function lr(t,r){let{allowFailure:e=!0,blockNumber:o,blockTag:n,...s}=r,a=r.contracts;try{let u={};for(let[m,d]of a.entries()){let l=d.chainId??t.state.chainId;u[l]||(u[l]=[]),u[l]?.push({contract:d,index:m})}let c=()=>Object.entries(u).map(([m,d])=>dr(t,{...s,allowFailure:e,blockNumber:o,blockTag:n,chainId:Number.parseInt(m),contracts:d.map(({contract:l})=>l)})),i=(await Promise.all(c())).flat(),f=Object.values(u).flatMap(m=>m.map(({index:d})=>d));return i.reduce((m,d,l)=>(m&&(m[f[l]]=d),m),[])}catch(u){if(u instanceof Ce)throw u;let c=()=>a.map(i=>mr(t,{...i,blockNumber:o,blockTag:n}));return e?(await Promise.allSettled(c())).map(i=>i.status==="fulfilled"?{result:i.value,status:"success"}:{error:i.reason,result:void 0,status:"failure"}):await Promise.all(c())}}async function hr(t,r){let{address:e,blockNumber:o,blockTag:n,chainId:s,token:a,unit:u="ether"}=r;if(a)try{return await pr(t,{balanceAddress:e,chainId:s,symbolType:"string",tokenAddress:a})}catch(d){if(d.name==="ContractFunctionExecutionError"){let l=await pr(t,{balanceAddress:e,chainId:s,symbolType:"bytes32",tokenAddress:a}),x=vt(pe(l.symbol,{dir:"right"}));return{...l,symbol:x}}throw d}let c=t.getClient({chainId:s}),f=await _(c,at,"getBalance")(o?{address:e,blockNumber:o}:{address:e,blockTag:n}),m=t.chains.find(d=>d.id===s)??c.chain;return{decimals:m.nativeCurrency.decimals,formatted:Vt(f,ie(u)),symbol:m.nativeCurrency.symbol,value:f}}async function pr(t,r){let{balanceAddress:e,chainId:o,symbolType:n,tokenAddress:s,unit:a}=r,u={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:n}]}],address:s},[c,i,f]=await lr(t,{allowFailure:!1,contracts:[{...u,functionName:"balanceOf",args:[e],chainId:o},{...u,functionName:"decimals",chainId:o},{...u,functionName:"symbol",chainId:o}]}),m=Vt(c??"0",ie(a??i));return{decimals:i,formatted:m,symbol:f,value:c}}function W(t,r){if(t===r)return!0;if(t&&r&&typeof t=="object"&&typeof r=="object"){if(t.constructor!==r.constructor)return!1;let e,o;if(Array.isArray(t)&&Array.isArray(r)){if(e=t.length,e!==r.length)return!1;for(o=e;o--!==0;)if(!W(t[o],r[o]))return!1;return!0}if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();let n=Object.keys(t);if(e=n.length,e!==Object.keys(r).length)return!1;for(o=e;o--!==0;)if(!Object.prototype.hasOwnProperty.call(r,n[o]))return!1;for(o=e;o--!==0;){let s=n[o];if(s&&!W(t[s],r[s]))return!1}return!0}return t!==t&&r!==r}var Lt=[];function ae(t){let r=[...t.state.connections.values()];return t.state.status==="reconnecting"||W(Lt,r)?Lt:(Lt=r,r)}async function zr(t,r){let{account:e,chainId:o,...n}=r,s=e??xt(t).address,a=t.getClient({chainId:o});return _(a,K,"prepareTransactionRequest")({...n,...s?{account:s}:{}})}var ce=!1;async function ue(t,r={}){if(ce)return[];ce=!0,t.setState(i=>({...i,status:i.current?"reconnecting":"connecting"}));let e=[];if(r.connectors?.length)for(let i of r.connectors){let f;typeof i=="function"?f=t._internal.connectors.setup(i):f=i,e.push(f)}else e.push(...t.connectors);let o;try{o=await t.storage?.getItem("recentConnectorId")}catch{}let n={};for(let[,i]of t.state.connections)n[i.connector.id]=1;o&&(n[o]=0);let s=Object.keys(n).length>0?[...e].sort((i,f)=>(n[i.id]??10)-(n[f.id]??10)):e,a=!1,u=[],c=[];for(let i of s){let f=await i.getProvider().catch(()=>{});if(!f||c.some(l=>l===f)||!await i.isAuthorized())continue;let d=await i.connect({isReconnecting:!0}).catch(()=>null);d&&(i.emitter.off("connect",t._internal.events.connect),i.emitter.on("change",t._internal.events.change),i.emitter.on("disconnect",t._internal.events.disconnect),t.setState(l=>{let x=new Map(a?l.connections:new Map).set(i.uid,{accounts:d.accounts,chainId:d.chainId,connector:i});return{...l,current:a?l.current:i.uid,connections:x}}),u.push({accounts:d.accounts,chainId:d.chainId,connector:i}),c.push(f),a=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(a?t.setState(i=>({...i,status:"connected"})):t.setState(i=>({...i,connections:new Map,current:null,status:"disconnected"}))),ce=!1,u}async function Hr(t,r){let{account:e,chainId:o,connector:n,...s}=r,a;return typeof e=="object"&&e?.type==="local"?a=t.getClient({chainId:o}):a=await $(t,{account:e??void 0,chainId:o,connector:n}),await _(a,ut,"sendTransaction")({...s,...e?{account:e}:{},chain:o?{id:o}:null,gas:s.gas??void 0})}async function Dr(t,r){let{account:e,connector:o,...n}=r,s;return typeof e=="object"&&e.type==="local"?s=t.getClient():s=await $(t,{account:e,connector:o}),_(s,ne,"signMessage")({...n,...e?{account:e}:{}})}async function gr(t,r){let{addEthereumChainParameter:e,chainId:o}=r,n=t.state.connections.get(r.connector?.uid??t.state.current);if(n){let a=n.connector;if(!a.switchChain)throw new gt({connector:a});return await a.switchChain({addEthereumChainParameter:e,chainId:o})}let s=t.chains.find(a=>a.id===o);if(!s)throw new G;return t.setState(a=>({...a,chainId:o})),s}function Lr(t,r){let{onChange:e}=r;return t.subscribe(()=>xt(t),e,{equalityFn(o,n){let{connector:s,...a}=o,{connector:u,...c}=n;return W(a,c)&&s?.id===u?.id&&s?.uid===u?.uid}})}function Ur(t,r){let{onChange:e}=r;return t.subscribe(()=>ae(t),e,{equalityFn:W})}function $r(t,r){let{onChange:e}=r;return t._internal.connectors.subscribe((o,n)=>{e(Object.values(o),n)})}function Wr(t,r){let{syncConnectedChain:e=t._internal.syncConnectedChain,...o}=r,n,s=c=>{n&&n();let i=t.getClient({chainId:c});return n=_(i,oe,"watchPendingTransactions")(o),n},a=s(r.chainId),u;return e&&!r.chainId&&(u=t.subscribe(({chainId:c})=>c,async c=>s(c))),()=>{a?.(),u?.()}}async function wr(t,r){let{chainId:e,timeout:o=0,...n}=r,s=t.getClient({chainId:e}),u=await _(s,re,"waitForTransactionReceipt")({...n,timeout:o});if(u.status==="reverted"){let i=await _(s,dt,"getTransaction")({hash:u.transactionHash}),m=await _(s,nt,"call")({...i,data:i.input,gasPrice:i.type!=="eip1559"?i.gasPrice:void 0,maxFeePerGas:i.type==="eip1559"?i.maxFeePerGas:void 0,maxPriorityFeePerGas:i.type==="eip1559"?i.maxPriorityFeePerGas:void 0}),d=m?.data?vt(`0x${m.data.substring(138)}`):"unknown reason";throw new Error(d)}return{...u,chainId:s.chain.id}}async function Jr(t,r){let{account:e,chainId:o,connector:n,...s}=r,a;return typeof e=="object"&&e?.type==="local"?a=t.getClient({chainId:o}):a=await $(t,{account:e??void 0,chainId:o,connector:n}),await _(a,Yt,"writeContract")({...s,...e?{account:e}:{},chain:o?{id:o}:null})}function xr(t){if(typeof window>"u")return;let r=e=>t(e.detail);return window.addEventListener("eip6963:announceProvider",r),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",r)}function fe(){let t=new Set,r=[],e=()=>xr(n=>{r.some(({info:s})=>s.uuid===n.info.uuid)||(r=[...r,n],t.forEach(s=>s(r,{added:[n]})))}),o=e();return{_listeners(){return t},clear(){t.forEach(n=>n([],{removed:[...r]})),r=[]},destroy(){this.clear(),t.clear(),o?.()},findProvider({rdns:n}){return r.find(s=>s.info.rdns===n)},getProviders(){return r},reset(){this.clear(),o?.(),o=e()},subscribe(n,{emitImmediately:s}={}){return t.add(n),s&&n(r,{added:r}),()=>t.delete(n)}}}var Vr=t=>(r,e,o)=>{let n=o.subscribe;return o.subscribe=(a,u,c)=>{let i=a;if(u){let f=c?.equalityFn||Object.is,m=a(o.getState());i=d=>{let l=a(d);if(!f(m,l)){let x=m;u(m=l,x)}},c?.fireImmediately&&u(m,m)}return n(i)},t(r,e,o)},yr=Vr;function Kr(t,r){let e;try{e=t()}catch{return}return{getItem:n=>{var s;let a=c=>c===null?null:JSON.parse(c,r?.reviver),u=(s=e.getItem(n))!=null?s:null;return u instanceof Promise?u.then(a):a(u)},setItem:(n,s)=>e.setItem(n,JSON.stringify(s,r?.replacer)),removeItem:n=>e.removeItem(n)}}var de=t=>r=>{try{let e=t(r);return e instanceof Promise?e:{then(o){return de(o)(e)},catch(o){return this}}}catch(e){return{then(o){return this},catch(o){return de(o)(e)}}}},Xr=(t,r)=>(e,o,n)=>{let s={storage:Kr(()=>localStorage),partialize:w=>w,version:0,merge:(w,v)=>({...v,...w}),...r},a=!1,u=new Set,c=new Set,i=s.storage;if(!i)return t((...w)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),e(...w)},o,n);let f=()=>{let w=s.partialize({...o()});return i.setItem(s.name,{state:w,version:s.version})},m=n.setState;n.setState=(w,v)=>{m(w,v),f()};let d=t((...w)=>{e(...w),f()},o,n);n.getInitialState=()=>d;let l,x=()=>{var w,v;if(!i)return;a=!1,u.forEach(b=>{var C;return b((C=o())!=null?C:d)});let y=((v=s.onRehydrateStorage)==null?void 0:v.call(s,(w=o())!=null?w:d))||void 0;return de(i.getItem.bind(i))(s.name).then(b=>{if(b)if(typeof b.version=="number"&&b.version!==s.version){if(s.migrate)return[!0,s.migrate(b.state,b.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,b.state];return[!1,void 0]}).then(b=>{var C;let[S,p]=b;if(l=s.merge(p,(C=o())!=null?C:d),e(l,!0),S)return f()}).then(()=>{y?.(l,void 0),l=o(),a=!0,c.forEach(b=>b(l))}).catch(b=>{y?.(void 0,b)})};return n.persist={setOptions:w=>{s={...s,...w},w.storage&&(i=w.storage)},clearStorage:()=>{i?.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>x(),hasHydrated:()=>a,onHydrate:w=>(u.add(w),()=>{u.delete(w)}),onFinishHydration:w=>(c.add(w),()=>{c.delete(w)})},s.skipHydration||x(),l||d},br=Xr;var vr=t=>{let r,e=new Set,o=(i,f)=>{let m=typeof i=="function"?i(r):i;if(!Object.is(m,r)){let d=r;r=f??(typeof m!="object"||m===null)?m:Object.assign({},r,m),e.forEach(l=>l(r,d))}},n=()=>r,u={setState:o,getState:n,getInitialState:()=>c,subscribe:i=>(e.add(i),()=>e.delete(i))},c=r=t(o,n,u);return u},Ut=t=>t?vr(t):vr;var me=class{constructor(r){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Je.default})}on(r,e){this._emitter.on(r,e)}once(r,e){this._emitter.once(r,e)}off(r,e){this._emitter.off(r,e)}emit(r,...e){let o=e[0];this._emitter.emit(r,{uid:this.uid,...o})}listenerCount(r){return this._emitter.listenerCount(r)}};function Cr(t){return new me(t)}function Tr(t,r){return JSON.parse(t,(e,o)=>{let n=o;return n?.__type==="bigint"&&(n=BigInt(n.value)),n?.__type==="Map"&&(n=new Map(n.value)),r?.(e,n)??n})}function Pr(t,r){return t.slice(0,r).join(".")||"."}function Ir(t,r){let{length:e}=t;for(let o=0;o<e;++o)if(t[o]===r)return o+1;return 0}function Zr(t,r){let e=typeof t=="function",o=typeof r=="function",n=[],s=[];return function(u,c){if(typeof c=="object")if(n.length){let i=Ir(n,this);i===0?n[n.length]=this:(n.splice(i),s.splice(i)),s[s.length]=u;let f=Ir(n,c);if(f!==0)return o?r.call(this,u,c,Pr(s,f)):`[ref=${Pr(s,f)}]`}else n[0]=c,s[0]=u;return e?t.call(this,u,c):c}}function Sr(t,r,e,o){return JSON.stringify(t,Zr((n,s)=>{let a=s;return typeof a=="bigint"&&(a={__type:"bigint",value:s.toString()}),a instanceof Map&&(a={__type:"Map",value:Array.from(s.entries())}),r?.(n,a)??a},o),e??void 0)}function Er(t){let{deserialize:r=Tr,key:e="wagmi",serialize:o=Sr,storage:n=kr}=t;function s(a){return a instanceof Promise?a.then(u=>u).catch(()=>null):a}return{...n,key:e,async getItem(a,u){let c=n.getItem(`${e}.${a}`),i=await s(c);return i?r(i)??null:u??null},async setItem(a,u){let c=`${e}.${a}`;u===null?await s(n.removeItem(c)):await s(n.setItem(c,o(u)))},async removeItem(a){await s(n.removeItem(`${e}.${a}`))}}}var kr={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function Ar(){let t=typeof window<"u"&&window.localStorage?window.localStorage:kr;return{getItem(r){return t.getItem(r)},removeItem(r){t.removeItem(r)},setItem(r,e){try{t.setItem(r,e)}catch{}}}}var $t=256,Wt;function _r(t=11){if(!Wt||$t+t>256*2){Wt="",$t=0;for(let r=0;r<256;r++)Wt+=(256+Math.random()*256|0).toString(16).substring(1)}return Wt.substring($t,$t+++t)}function Qr(t){let{multiInjectedProviderDiscovery:r=!0,storage:e=Er({storage:Ar()}),syncConnectedChain:o=!0,ssr:n=!1,...s}=t,a=typeof window<"u"&&r?fe():void 0,u=Ut(()=>s.chains),c=Ut(()=>{let p=[],h=new Set;for(let g of s.connectors??[]){let P=i(g);if(p.push(P),!n&&P.rdns){let T=typeof P.rdns=="string"?[P.rdns]:P.rdns;for(let E of T)h.add(E)}}if(!n&&a){let g=a.getProviders();for(let P of g)h.has(P.info.rdns)||p.push(i(f(P)))}return p});function i(p){let h=Cr(_r()),g={...p({emitter:h,chains:u.getState(),storage:e,transports:s.transports}),emitter:h,uid:h.uid};return h.on("connect",C),g.setup?.(),g}function f(p){let{info:h}=p,g=p.provider;return wt({target:{...h,id:h.rdns,provider:g}})}let m=new Map;function d(p={}){let h=p.chainId??v.getState().chainId,g=u.getState().find(T=>T.id===h);if(p.chainId&&!g)throw new G;{let T=m.get(v.getState().chainId);if(T&&!g)return T;if(!g)throw new G}{let T=m.get(h);if(T)return T}let P;if(s.client)P=s.client({chain:g});else{let T=g.id,E=u.getState().map(F=>F.id),k={},B=Object.entries(s);for(let[F,M]of B)if(!(F==="chains"||F==="client"||F==="connectors"||F==="transports"))if(typeof M=="object")if(T in M)k[F]=M[T];else{if(E.some(L=>L in M))continue;k[F]=M}else k[F]=M;P=Rt({...k,chain:g,batch:k.batch??{multicall:!0},transport:F=>s.transports[T]({...F,connectors:c})})}return m.set(h,P),P}function l(){return{chainId:u.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let x,w="0.0.0-canary-";rt.startsWith(w)?x=Number.parseInt(rt.replace(w,"")):x=Number.parseInt(rt.split(".")[0]??"0");let v=Ut(yr(e?br(l,{migrate(p,h){if(h===x)return p;let g=l(),P=y(p,g.chainId);return{...g,chainId:P}},name:"store",partialize(p){return{connections:{__type:"Map",value:Array.from(p.connections.entries()).map(([h,g])=>{let{id:P,name:T,type:E,uid:k}=g.connector;return[h,{...g,connector:{id:P,name:T,type:E,uid:k}}]})},chainId:p.chainId,current:p.current}},merge(p,h){typeof p=="object"&&p&&"status"in p&&delete p.status;let g=y(p,h.chainId);return{...h,...p,chainId:g}},skipHydration:n,storage:e,version:x}):l));v.setState(l());function y(p,h){return p&&typeof p=="object"&&"chainId"in p&&typeof p.chainId=="number"&&u.getState().some(g=>g.id===p.chainId)?p.chainId:h}o&&v.subscribe(({connections:p,current:h})=>h?p.get(h)?.chainId:void 0,p=>{if(u.getState().some(g=>g.id===p))return v.setState(g=>({...g,chainId:p??g.chainId}))}),a?.subscribe(p=>{let h=new Set,g=new Set;for(let T of c.getState())if(h.add(T.id),T.rdns){let E=typeof T.rdns=="string"?[T.rdns]:T.rdns;for(let k of E)g.add(k)}let P=[];for(let T of p){if(g.has(T.info.rdns))continue;let E=i(f(T));h.has(E.id)||P.push(E)}e&&!v.persist.hasHydrated()||c.setState(T=>[...T,...P],!0)});function b(p){v.setState(h=>{let g=h.connections.get(p.uid);return g?{...h,connections:new Map(h.connections).set(p.uid,{accounts:p.accounts??g.accounts,chainId:p.chainId??g.chainId,connector:g.connector})}:h})}function C(p){v.getState().status==="connecting"||v.getState().status==="reconnecting"||v.setState(h=>{let g=c.getState().find(P=>P.uid===p.uid);return g?(g.emitter.listenerCount("connect")&&g.emitter.off("connect",b),g.emitter.listenerCount("change")||g.emitter.on("change",b),g.emitter.listenerCount("disconnect")||g.emitter.on("disconnect",S),{...h,connections:new Map(h.connections).set(p.uid,{accounts:p.accounts,chainId:p.chainId,connector:g}),current:p.uid,status:"connected"}):h})}function S(p){v.setState(h=>{let g=h.connections.get(p.uid);if(g){let T=g.connector;T.emitter.listenerCount("change")&&g.connector.emitter.off("change",b),T.emitter.listenerCount("disconnect")&&g.connector.emitter.off("disconnect",S),T.emitter.listenerCount("connect")||g.connector.emitter.on("connect",C)}if(h.connections.delete(p.uid),h.connections.size===0)return{...h,connections:new Map,current:null,status:"disconnected"};let P=h.connections.values().next().value;return{...h,connections:new Map(h.connections),current:P.connector.uid}})}return{get chains(){return u.getState()},get connectors(){return c.getState()},storage:e,getClient:d,get state(){return v.getState()},setState(p){let h;typeof p=="function"?h=p(v.getState()):h=p;let g=l();typeof h!="object"&&(h=g),Object.keys(g).some(T=>!(T in h))&&(h=g),v.setState(h,!0)},subscribe(p,h,g){return v.subscribe(p,h,g?{...g,fireImmediately:g.emitImmediately}:void 0)},_internal:{mipd:a,store:v,ssr:!!n,syncConnectedChain:o,transports:s.transports,chains:{setState(p){let h=typeof p=="function"?p(u.getState()):p;if(h.length!==0)return u.setState(h,!0)},subscribe(p){return u.subscribe(p)}},connectors:{providerDetailToConnector:f,setup:i,setState(p){return c.setState(typeof p=="function"?p(c.getState()):p,!0)},subscribe(p){return c.subscribe(p)}},events:{change:b,connect:C,disconnect:S}}}}function Yr(t,r){let{initialState:e,reconnectOnMount:o}=r;return e&&!t._internal.store.persist.hasHydrated()&&t.setState({...e,chainId:t.chains.some(n=>n.id===e.chainId)?e.chainId:t.chains[0].id,connections:o?e.connections:new Map,status:o?"reconnecting":"disconnected"}),{async onMount(){t._internal.ssr&&(await t._internal.store.persist.rehydrate(),t._internal.mipd&&t._internal.connectors.setState(n=>{let s=new Set;for(let c of n??[])if(c.rdns){let i=Array.isArray(c.rdns)?c.rdns:[c.rdns];for(let f of i)s.add(f)}let a=[],u=t._internal.mipd?.getProviders()??[];for(let c of u){if(s.has(c.info.rdns))continue;let i=t._internal.connectors.providerDetailToConnector(c),f=t._internal.connectors.setup(i);a.push(f)}return[...n,...a]})),o?ue(t):t.storage&&t.setState(n=>({...n,connections:new Map}))}}}function to(t){let{chain:r}=t,e=r.rpcUrls.default.http[0];if(!t.transports)return[e];let o=t.transports?.[r.id]?.({chain:r});return(o?.value?.transports||[o]).map(({value:s})=>s?.url||e)}export{q as a,G as b,jr as c,Gr as d,Or as e,xt as f,hr as g,ae as h,zr as i,ue as j,Hr as k,Dr as l,O as m,gr as n,Lr as o,Ur as p,$r as q,Wr as r,wr as s,Jr as t,wt as u,se as v,Qr as w,Yr as x,to as y};
