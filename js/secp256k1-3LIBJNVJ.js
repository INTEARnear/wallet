import{a as pt}from"./chunk-2LXNZIUV.js";import{a as Mt,b as ut,c as ht,d as Et,e as qt,f as Pt,g as Y,h as Vt,i as J,j as jt,k as z,l as D,m as _t,n as mt,o as $,p as be,q as ct,r as ye,s as F,t as Kt}from"./chunk-FFQJ55XB.js";import{f as le,g as de,h as ue,i as zt,l as he,q as me,r as we,s as ge,u as It}from"./chunk-6IYG3UUA.js";import"./chunk-57YRCRKT.js";var Nt=class extends ge{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,ue(n);let r=me(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),he(s)}update(n){return zt(this),this.iHash.update(n),this}digestInto(n){zt(this),de(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:r,finished:i,destroyed:s,blockLen:c,outputLen:a}=this;return n=n,n.finished=i,n.destroyed=s,n.blockLen=c,n.outputLen=a,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Yt=(e,n,t)=>new Nt(e,n).update(t).digest();Yt.create=(e,n)=>new Nt(e,n);var j=BigInt(0),P=BigInt(1),ft=BigInt(2),De=BigInt(3),Ee=BigInt(4),xe=BigInt(5),ve=BigInt(8);function U(e,n){let t=e%n;return t>=j?t:n+t}function W(e,n,t){let r=e;for(;n-- >j;)r*=r,r%=t;return r}function Rt(e,n){if(e===j)throw new Error("invert: expected non-zero number");if(n<=j)throw new Error("invert: expected positive modulus, got "+n);let t=U(e,n),r=n,i=j,s=P,c=P,a=j;for(;t!==j;){let l=r/t,u=r%t,p=i-c*l,x=s-a*l;r=t,t=u,i=c,s=a,c=p,a=x}if(r!==P)throw new Error("invert: does not exist");return U(i,n)}function Be(e,n){let t=(e.ORDER+P)/Ee,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function We(e,n){let t=(e.ORDER-xe)/ve,r=e.mul(n,ft),i=e.pow(r,t),s=e.mul(n,i),c=e.mul(e.mul(s,ft),i),a=e.mul(s,e.sub(c,e.ONE));if(!e.eql(e.sqr(a),n))throw new Error("Cannot find square root");return a}function Ge(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-P,t=0;for(;n%ft===j;)n/=ft,t++;let r=ft,i=xt(e);for(;pe(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Be;let s=i.pow(r,n),c=(n+P)/ft;return function(o,l){if(o.is0(l))return l;if(pe(o,l)!==1)throw new Error("Cannot find square root");let u=t,p=o.mul(o.ONE,s),x=o.pow(l,n),v=o.pow(l,c);for(;!o.eql(x,o.ONE);){if(o.is0(x))return o.ZERO;let N=1,w=o.sqr(x);for(;!o.eql(w,o.ONE);)if(N++,w=o.sqr(w),N===u)throw new Error("Cannot find square root");let H=P<<BigInt(u-N-1),A=o.pow(p,H);u=N,p=o.sqr(A),x=o.mul(x,p),v=o.mul(v,A)}return v}}function Xe(e){return e%Ee===De?Be:e%ve===xe?We:Ge(e)}var Qe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Tt(e){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Qe.reduce((r,i)=>(r[i]="function",r),n);return F(e,t)}function Je(e,n,t){if(t<j)throw new Error("invalid exponent, negatives unsupported");if(t===j)return e.ONE;if(t===P)return n;let r=e.ONE,i=n;for(;t>j;)t&P&&(r=e.mul(r,i)),i=e.sqr(i),t>>=P;return r}function wt(e,n,t=!1){let r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((c,a,o)=>e.is0(a)?c:(r[o]=c,e.mul(c,a)),e.ONE),s=e.inv(i);return n.reduceRight((c,a,o)=>e.is0(a)?c:(r[o]=e.mul(c,r[o]),e.mul(c,a)),s),r}function pe(e,n){let t=(e.ORDER-P)/ft,r=e.pow(n,t),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),c=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!c)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Dt(e,n){n!==void 0&&le(n);let t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function xt(e,n,t=!1,r={}){if(e<=j)throw new Error("invalid field: expected ORDER > 0, got "+e);let{nBitLength:i,nByteLength:s}=Dt(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,a=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:s,MASK:ct(i),ZERO:j,ONE:P,create:o=>U(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return j<=o&&o<e},is0:o=>o===j,isOdd:o=>(o&P)===P,neg:o=>U(-o,e),eql:(o,l)=>o===l,sqr:o=>U(o*o,e),add:(o,l)=>U(o+l,e),sub:(o,l)=>U(o-l,e),mul:(o,l)=>U(o*l,e),pow:(o,l)=>Je(a,o,l),div:(o,l)=>U(o*Rt(l,e),e),sqrN:o=>o*o,addN:(o,l)=>o+l,subN:(o,l)=>o-l,mulN:(o,l)=>o*l,inv:o=>Rt(o,e),sqrt:r.sqrt||(o=>(c||(c=Xe(e)),c(a,o))),toBytes:o=>t?jt(o,s):J(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?Vt(o):Y(o)},invertBatch:o=>wt(a,o),cmov:(o,l,u)=>u?l:o});return Object.freeze(a)}function Se(e){if(typeof e!="bigint")throw new Error("field order must be bigint");let n=e.toString(2).length;return Math.ceil(n/8)}function Wt(e){let n=Se(e);return n+Math.ceil(n/2)}function Oe(e,n,t=!1){let r=e.length,i=Se(n),s=Wt(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);let c=t?Vt(e):Y(e),a=U(c,n-P)+P;return t?jt(a,i):J(a,i)}var Ae=BigInt(0),$t=BigInt(1);function Gt(e,n){let t=n.negate();return e?t:n}function qe(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Xt(e,n){qe(e,n);let t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,s=ct(e),c=BigInt(e);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:c}}function Ie(e,n,t){let{windowSize:r,mask:i,maxNumber:s,shiftBy:c}=t,a=Number(e&i),o=e>>c;a>r&&(a-=s,o+=$t);let l=n*r,u=l+Math.abs(a)-1,p=a===0,x=a<0,v=n%2!==0;return{nextN:o,offset:u,isZero:p,isNeg:x,isNegF:v,offsetF:l}}function $e(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Fe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}var Qt=new WeakMap,_e=new WeakMap;function Jt(e){return _e.get(e)||1}function Ne(e,n){return{constTimeNegate:Gt,hasPrecomputes(t){return Jt(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>Ae;)r&$t&&(i=i.add(s)),s=s.double(),r>>=$t;return i},precomputeWindow(t,r){let{windows:i,windowSize:s}=Xt(r,n),c=[],a=t,o=a;for(let l=0;l<i;l++){o=a,c.push(o);for(let u=1;u<s;u++)o=o.add(a),c.push(o);a=o.double()}return c},wNAF(t,r,i){let s=e.ZERO,c=e.BASE,a=Xt(t,n);for(let o=0;o<a.windows;o++){let{nextN:l,offset:u,isZero:p,isNeg:x,isNegF:v,offsetF:N}=Ie(i,o,a);i=l,p?c=c.add(Gt(v,r[N])):s=s.add(Gt(x,r[u]))}return{p:s,f:c}},wNAFUnsafe(t,r,i,s=e.ZERO){let c=Xt(t,n);for(let a=0;a<c.windows&&i!==Ae;a++){let{nextN:o,offset:l,isZero:u,isNeg:p}=Ie(i,a,c);if(i=o,!u){let x=r[l];s=s.add(p?x.negate():x)}}return s},getPrecomputes(t,r,i){let s=Qt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&Qt.set(r,i(s))),s},wNAFCached(t,r,i){let s=Jt(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){let c=Jt(t);return c===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,t,i),r,s)},setWindowSize(t,r){qe(r,n),_e.set(t,r),Qt.delete(t)}}}function Re(e,n,t,r){$e(t,e),Fe(r,n);let i=t.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");let c=e.ZERO,a=be(BigInt(i)),o=1;a>12?o=a-3:a>4?o=a-2:a>0&&(o=2);let l=ct(o),u=new Array(Number(l)+1).fill(c),p=Math.floor((n.BITS-1)/o)*o,x=c;for(let v=p;v>=0;v-=o){u.fill(c);for(let w=0;w<s;w++){let H=r[w],A=Number(H>>BigInt(v)&l);u[A]=u[A].add(t[w])}let N=c;for(let w=u.length-1,H=c;w>0;w--)H=H.add(u[w]),N=N.add(H);if(x=x.add(N),v!==0)for(let w=0;w<o;w++)x=x.double()}return x}function Ft(e){return Tt(e.Fp),F(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Dt(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Te(e){e.lowS!==void 0&&ht("lowS",e.lowS),e.prehash!==void 0&&ht("prehash",e.prehash)}function tn(e){let n=Ft(e);F(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});let{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}var ee=class extends Error{constructor(n=""){super(n)}},tt={Err:ee,_tlv:{encode:(e,n)=>{let{Err:t}=tt;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");let r=n.length/2,i=Et(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");let s=r>127?Et(i.length/2|128):"";return Et(e)+s+i+n},decode(e,n){let{Err:t}=tt,r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");let i=n[r++],s=!!(i&128),c=0;if(!s)c=i;else{let o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");let l=n.subarray(r,r+o);if(l.length!==o)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let u of l)c=c<<8|u;if(r+=o,c<128)throw new t("tlv.decode(long): not minimal encoding")}let a=n.subarray(r,r+c);if(a.length!==c)throw new t("tlv.decode: wrong value length");return{v:a,l:n.subarray(r+c)}}},_int:{encode(e){let{Err:n}=tt;if(e<X)throw new n("integer: negative integers are not allowed");let t=Et(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){let{Err:n}=tt;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return Y(e)}},toSig(e){let{Err:n,_int:t,_tlv:r}=tt,i=z("signature",e),{v:s,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");let{v:a,l:o}=r.decode(2,s),{v:l,l:u}=r.decode(2,o);if(u.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(e){let{_tlv:n,_int:t}=tt,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}};function te(e,n){return qt(J(e,n))}var X=BigInt(0),k=BigInt(1),nt=BigInt(2),vt=BigInt(3),ne=BigInt(4);function en(e){let n=tn(e),{Fp:t}=n,r=xt(n.n,n.nBitLength),i=n.toBytes||((g,f,m)=>{let b=f.toAffine();return D(Uint8Array.from([4]),t.toBytes(b.x),t.toBytes(b.y))}),s=n.fromBytes||(g=>{let f=g.subarray(1),m=t.fromBytes(f.subarray(0,t.BYTES)),b=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:m,y:b}});function c(g){let{a:f,b:m}=n,b=t.sqr(g),E=t.mul(b,g);return t.add(t.add(E,t.mul(g,f)),m)}function a(g,f){let m=t.sqr(f),b=c(g);return t.eql(m,b)}if(!a(n.Gx,n.Gy))throw new Error("bad curve params: generator point");let o=t.mul(t.pow(n.a,vt),ne),l=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(o,l)))throw new Error("bad curve params: a or b");function u(g){return mt(g,k,n.n)}function p(g){let{allowedPrivateKeyLengths:f,nByteLength:m,wrapPrivateKey:b,n:E}=n;if(f&&typeof g!="bigint"){if(Mt(g)&&(g=qt(g)),typeof g!="string"||!f.includes(g.length))throw new Error("invalid private key");g=g.padStart(m*2,"0")}let I;try{I=typeof g=="bigint"?g:Y(z("private key",g,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof g)}return b&&(I=U(I,E)),$("private key",I,k,E),I}function x(g){if(!(g instanceof w))throw new Error("ProjectivePoint expected")}let v=Kt((g,f)=>{let{px:m,py:b,pz:E}=g;if(t.eql(E,t.ONE))return{x:m,y:b};let I=g.is0();f==null&&(f=I?t.ONE:t.inv(E));let L=t.mul(m,f),Z=t.mul(b,f),B=t.mul(E,f);if(I)return{x:t.ZERO,y:t.ZERO};if(!t.eql(B,t.ONE))throw new Error("invZ was invalid");return{x:L,y:Z}}),N=Kt(g=>{if(g.is0()){if(n.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}let{x:f,y:m}=g.toAffine();if(!t.isValid(f)||!t.isValid(m))throw new Error("bad point: x or y not FE");if(!a(f,m))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class w{constructor(f,m,b){if(f==null||!t.isValid(f))throw new Error("x required");if(m==null||!t.isValid(m)||t.is0(m))throw new Error("y required");if(b==null||!t.isValid(b))throw new Error("z required");this.px=f,this.py=m,this.pz=b,Object.freeze(this)}static fromAffine(f){let{x:m,y:b}=f||{};if(!f||!t.isValid(m)||!t.isValid(b))throw new Error("invalid affine point");if(f instanceof w)throw new Error("projective point not allowed");let E=I=>t.eql(I,t.ZERO);return E(m)&&E(b)?w.ZERO:new w(m,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){let m=wt(t,f.map(b=>b.pz));return f.map((b,E)=>b.toAffine(m[E])).map(w.fromAffine)}static fromHex(f){let m=w.fromAffine(s(z("pointHex",f)));return m.assertValidity(),m}static fromPrivateKey(f){return w.BASE.multiply(p(f))}static msm(f,m){return Re(w,r,f,m)}_setWindowSize(f){T.setWindowSize(this,f)}assertValidity(){N(this)}hasEvenY(){let{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){x(f);let{px:m,py:b,pz:E}=this,{px:I,py:L,pz:Z}=f,B=t.eql(t.mul(m,Z),t.mul(I,E)),R=t.eql(t.mul(b,Z),t.mul(L,E));return B&&R}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){let{a:f,b:m}=n,b=t.mul(m,vt),{px:E,py:I,pz:L}=this,Z=t.ZERO,B=t.ZERO,R=t.ZERO,S=t.mul(E,E),M=t.mul(I,I),h=t.mul(L,L),d=t.mul(E,I);return d=t.add(d,d),R=t.mul(E,L),R=t.add(R,R),Z=t.mul(f,R),B=t.mul(b,h),B=t.add(Z,B),Z=t.sub(M,B),B=t.add(M,B),B=t.mul(Z,B),Z=t.mul(d,Z),R=t.mul(b,R),h=t.mul(f,h),d=t.sub(S,h),d=t.mul(f,d),d=t.add(d,R),R=t.add(S,S),S=t.add(R,S),S=t.add(S,h),S=t.mul(S,d),B=t.add(B,S),h=t.mul(I,L),h=t.add(h,h),S=t.mul(h,d),Z=t.sub(Z,S),R=t.mul(h,M),R=t.add(R,R),R=t.add(R,R),new w(Z,B,R)}add(f){x(f);let{px:m,py:b,pz:E}=this,{px:I,py:L,pz:Z}=f,B=t.ZERO,R=t.ZERO,S=t.ZERO,M=n.a,h=t.mul(n.b,vt),d=t.mul(m,I),y=t.mul(b,L),_=t.mul(E,Z),O=t.add(m,b),q=t.add(I,L);O=t.mul(O,q),q=t.add(d,y),O=t.sub(O,q),q=t.add(m,E);let C=t.add(I,Z);return q=t.mul(q,C),C=t.add(d,_),q=t.sub(q,C),C=t.add(b,E),B=t.add(L,Z),C=t.mul(C,B),B=t.add(y,_),C=t.sub(C,B),S=t.mul(M,q),B=t.mul(h,_),S=t.add(B,S),B=t.sub(y,S),S=t.add(y,S),R=t.mul(B,S),y=t.add(d,d),y=t.add(y,d),_=t.mul(M,_),q=t.mul(h,q),y=t.add(y,_),_=t.sub(d,_),_=t.mul(M,_),q=t.add(q,_),d=t.mul(y,q),R=t.add(R,d),d=t.mul(C,q),B=t.mul(O,B),B=t.sub(B,d),d=t.mul(O,y),S=t.mul(C,S),S=t.add(S,d),new w(B,R,S)}subtract(f){return this.add(f.negate())}is0(){return this.equals(w.ZERO)}wNAF(f){return T.wNAFCached(this,f,w.normalizeZ)}multiplyUnsafe(f){let{endo:m,n:b}=n;$("scalar",f,X,b);let E=w.ZERO;if(f===X)return E;if(this.is0()||f===k)return this;if(!m||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,f,w.normalizeZ);let{k1neg:I,k1:L,k2neg:Z,k2:B}=m.splitScalar(f),R=E,S=E,M=this;for(;L>X||B>X;)L&k&&(R=R.add(M)),B&k&&(S=S.add(M)),M=M.double(),L>>=k,B>>=k;return I&&(R=R.negate()),Z&&(S=S.negate()),S=new w(t.mul(S.px,m.beta),S.py,S.pz),R.add(S)}multiply(f){let{endo:m,n:b}=n;$("scalar",f,k,b);let E,I;if(m){let{k1neg:L,k1:Z,k2neg:B,k2:R}=m.splitScalar(f),{p:S,f:M}=this.wNAF(Z),{p:h,f:d}=this.wNAF(R);S=T.constTimeNegate(L,S),h=T.constTimeNegate(B,h),h=new w(t.mul(h.px,m.beta),h.py,h.pz),E=S.add(h),I=M.add(d)}else{let{p:L,f:Z}=this.wNAF(f);E=L,I=Z}return w.normalizeZ([E,I])[0]}multiplyAndAddUnsafe(f,m,b){let E=w.BASE,I=(Z,B)=>B===X||B===k||!Z.equals(E)?Z.multiplyUnsafe(B):Z.multiply(B),L=I(this,m).add(I(f,b));return L.is0()?void 0:L}toAffine(f){return v(this,f)}isTorsionFree(){let{h:f,isTorsionFree:m}=n;if(f===k)return!0;if(m)return m(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:f,clearCofactor:m}=n;return f===k?this:m?m(w,this):this.multiplyUnsafe(n.h)}toRawBytes(f=!0){return ht("isCompressed",f),this.assertValidity(),i(w,this,f)}toHex(f=!0){return ht("isCompressed",f),qt(this.toRawBytes(f))}}w.BASE=new w(n.Gx,n.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);let{endo:H,nBitLength:A}=n,T=Ne(w,H?Math.ceil(A/2):A);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:p,weierstrassEquation:c,isWithinCurveOrder:u}}function nn(e){let n=Ft(e);return F(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Le(e){let n=nn(e),{Fp:t,n:r,nByteLength:i,nBitLength:s}=n,c=t.BYTES+1,a=2*t.BYTES+1;function o(h){return U(h,r)}function l(h){return Rt(h,r)}let{ProjectivePoint:u,normPrivateKeyToScalar:p,weierstrassEquation:x,isWithinCurveOrder:v}=en({...n,toBytes(h,d,y){let _=d.toAffine(),O=t.toBytes(_.x),q=D;return ht("isCompressed",y),y?q(Uint8Array.from([d.hasEvenY()?2:3]),O):q(Uint8Array.from([4]),O,t.toBytes(_.y))},fromBytes(h){let d=h.length,y=h[0],_=h.subarray(1);if(d===c&&(y===2||y===3)){let O=Y(_);if(!mt(O,k,t.ORDER))throw new Error("Point is not on curve");let q=x(O),C;try{C=t.sqrt(q)}catch(G){let K=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+K)}let V=(C&k)===k;return(y&1)===1!==V&&(C=t.neg(C)),{x:O,y:C}}else if(d===a&&y===4){let O=t.fromBytes(_.subarray(0,t.BYTES)),q=t.fromBytes(_.subarray(t.BYTES,2*t.BYTES));return{x:O,y:q}}else{let O=c,q=a;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+q+", got "+d)}}});function N(h){let d=r>>k;return h>d}function w(h){return N(h)?o(-h):h}let H=(h,d,y)=>Y(h.slice(d,y));class A{constructor(d,y,_){$("r",d,k,r),$("s",y,k,r),this.r=d,this.s=y,_!=null&&(this.recovery=_),Object.freeze(this)}static fromCompact(d){let y=i;return d=z("compactSignature",d,y*2),new A(H(d,0,y),H(d,y,2*y))}static fromDER(d){let{r:y,s:_}=tt.toSig(z("DER",d));return new A(y,_)}assertValidity(){}addRecoveryBit(d){return new A(this.r,this.s,d)}recoverPublicKey(d){let{r:y,s:_,recovery:O}=this,q=E(z("msgHash",d));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");let C=O===2||O===3?y+n.n:y;if(C>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let V=(O&1)===0?"02":"03",Q=u.fromHex(V+te(C,t.BYTES)),G=l(C),K=o(-q*G),at=o(_*G),et=u.BASE.multiplyAndAddUnsafe(Q,K,at);if(!et)throw new Error("point at infinify");return et.assertValidity(),et}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new A(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Pt(this.toDERHex())}toDERHex(){return tt.hexFromSig(this)}toCompactRawBytes(){return Pt(this.toCompactHex())}toCompactHex(){let d=i;return te(this.r,d)+te(this.s,d)}}let T={isValidPrivateKey(h){try{return p(h),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{let h=Wt(n.n);return Oe(n.randomBytes(h),n.n)},precompute(h=8,d=u.BASE){return d._setWindowSize(h),d.multiply(BigInt(3)),d}};function g(h,d=!0){return u.fromPrivateKey(h).toRawBytes(d)}function f(h){if(typeof h=="bigint")return!1;if(h instanceof u)return!0;let y=z("key",h).length,_=t.BYTES,O=_+1,q=2*_+1;if(!(n.allowedPrivateKeyLengths||i===O))return y===O||y===q}function m(h,d,y=!0){if(f(h)===!0)throw new Error("first arg must be private key");if(f(d)===!1)throw new Error("second arg must be public key");return u.fromHex(d).multiply(p(h)).toRawBytes(y)}let b=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");let d=Y(h),y=h.length*8-s;return y>0?d>>BigInt(y):d},E=n.bits2int_modN||function(h){return o(b(h))},I=ct(s);function L(h){return $("num < 2^"+s,h,X,I),J(h,i)}function Z(h,d,y=B){if(["recovered","canonical"].some(st=>st in y))throw new Error("sign() legacy options not supported");let{hash:_,randomBytes:O}=n,{lowS:q,prehash:C,extraEntropy:V}=y;q==null&&(q=!0),h=z("msgHash",h),Te(y),C&&(h=z("prehashed msgHash",_(h)));let Q=E(h),G=p(d),K=[L(G),L(Q)];if(V!=null&&V!==!1){let st=V===!0?O(t.BYTES):V;K.push(z("extraEntropy",st))}let at=D(...K),et=Q;function Ct(st){let lt=b(st);if(!v(lt))return;let Ut=l(lt),bt=u.BASE.multiply(lt).toAffine(),it=o(bt.x);if(it===X)return;let yt=o(Ut*o(et+it*G));if(yt===X)return;let dt=(bt.x===it?0:2)|Number(bt.y&k),ae=yt;return q&&N(yt)&&(ae=w(yt),dt^=1),new A(it,ae,dt)}return{seed:at,k2sig:Ct}}let B={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};function S(h,d,y=B){let{seed:_,k2sig:O}=Z(h,d,y),q=n;return ye(q.hash.outputLen,q.nByteLength,q.hmac)(_,O)}u.BASE._setWindowSize(8);function M(h,d,y,_=R){let O=h;d=z("msgHash",d),y=z("publicKey",y);let{lowS:q,prehash:C,format:V}=_;if(Te(_),"strict"in _)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");let Q=typeof O=="string"||Mt(O),G=!Q&&!V&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!Q&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,at;try{if(G&&(K=new A(O.r,O.s)),Q){try{V!=="compact"&&(K=A.fromDER(O))}catch(dt){if(!(dt instanceof tt.Err))throw dt}!K&&V!=="der"&&(K=A.fromCompact(O))}at=u.fromHex(y)}catch{return!1}if(!K||q&&K.hasHighS())return!1;C&&(d=n.hash(d));let{r:et,s:Ct}=K,st=E(d),lt=l(Ct),Ut=o(st*lt),bt=o(et*lt),it=u.BASE.multiplyAndAddUnsafe(at,Ut,bt)?.toAffine();return it?o(it.x)===et:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:m,sign:S,verify:M,ProjectivePoint:u,Signature:A,utils:T}}function rn(e,n){let t=e.ORDER,r=X;for(let N=t-k;N%nt===X;N/=nt)r+=k;let i=r,s=nt<<i-k-k,c=s*nt,a=(t-k)/c,o=(a-k)/nt,l=c-k,u=s,p=e.pow(n,a),x=e.pow(n,(a+k)/nt),v=(N,w)=>{let H=p,A=e.pow(w,l),T=e.sqr(A);T=e.mul(T,w);let g=e.mul(N,T);g=e.pow(g,o),g=e.mul(g,A),A=e.mul(g,w),T=e.mul(g,N);let f=e.mul(T,A);g=e.pow(f,u);let m=e.eql(g,e.ONE);A=e.mul(T,x),g=e.mul(f,H),T=e.cmov(A,T,m),f=e.cmov(g,f,m);for(let b=i;b>k;b--){let E=b-nt;E=nt<<E-k;let I=e.pow(f,E),L=e.eql(I,e.ONE);A=e.mul(T,H),H=e.mul(H,H),I=e.mul(f,H),T=e.cmov(A,T,L),f=e.cmov(I,f,L)}return{isValid:m,value:T}};if(e.ORDER%ne===vt){let N=(e.ORDER-vt)/ne,w=e.sqrt(e.neg(n));v=(H,A)=>{let T=e.sqr(A),g=e.mul(H,A);T=e.mul(T,g);let f=e.pow(T,N);f=e.mul(f,g);let m=e.mul(f,w),b=e.mul(e.sqr(f),A),E=e.eql(b,H),I=e.cmov(m,f,E);return{isValid:E,value:I}}}return v}function Ze(e,n){if(Tt(e),!e.isValid(n.A)||!e.isValid(n.B)||!e.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let t=rn(e,n.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let i,s,c,a,o,l,u,p;i=e.sqr(r),i=e.mul(i,n.Z),s=e.sqr(i),s=e.add(s,i),c=e.add(s,e.ONE),c=e.mul(c,n.B),a=e.cmov(n.Z,e.neg(s),!e.eql(s,e.ZERO)),a=e.mul(a,n.A),s=e.sqr(c),l=e.sqr(a),o=e.mul(l,n.A),s=e.add(s,o),s=e.mul(s,c),l=e.mul(l,a),o=e.mul(l,n.B),s=e.add(s,o),u=e.mul(i,c);let{isValid:x,value:v}=t(s,l);p=e.mul(i,r),p=e.mul(p,v),u=e.cmov(u,c,x),p=e.cmov(p,v,x);let N=e.isOdd(r)===e.isOdd(p);p=e.cmov(e.neg(p),p,N);let w=wt(e,[a],!0)[0];return u=e.mul(u,w),{x:u,y:p}}}function on(e){return{hash:e,hmac:(n,...t)=>Yt(e,n,we(...t)),randomBytes:It}}function He(e,n){let t=r=>Le({...e,...on(r)});return{...t(n),create:t}}var sn=Y;function rt(e,n){if(Bt(e),Bt(n),e<0||e>=1<<8*n)throw new Error("invalid I2OSP input: "+e);let t=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)t[r]=e&255,e>>>=8;return new Uint8Array(t)}function cn(e,n){let t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e[r]^n[r];return t}function Bt(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function fn(e,n,t,r){ut(e),ut(n),Bt(t),n.length>255&&(n=r(D(_t("H2C-OVERSIZE-DST-"),n)));let{outputLen:i,blockLen:s}=r,c=Math.ceil(t/i);if(t>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");let a=D(n,rt(n.length,1)),o=rt(0,s),l=rt(t,2),u=new Array(c),p=r(D(o,e,l,rt(0,1),a));u[0]=r(D(p,rt(1,1),a));for(let v=1;v<=c;v++){let N=[cn(p,u[v-1]),rt(v+1,1),a];u[v]=r(D(...N))}return D(...u).slice(0,t)}function an(e,n,t,r,i){if(ut(e),ut(n),Bt(t),n.length>255){let s=Math.ceil(2*r/8);n=i.create({dkLen:s}).update(_t("H2C-OVERSIZE-DST-")).update(n).digest()}if(t>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:t}).update(e).update(rt(t,2)).update(n).update(rt(n.length,1)).digest()}function ke(e,n,t){F(t,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:i,m:s,hash:c,expand:a,DST:o}=t;ut(e),Bt(n);let l=typeof o=="string"?_t(o):o,u=r.toString(2).length,p=Math.ceil((u+i)/8),x=n*s*p,v;if(a==="xmd")v=fn(e,l,x,c);else if(a==="xof")v=an(e,l,x,i,c);else if(a==="_internal_pass")v=e;else throw new Error('expand must be "xmd" or "xof"');let N=new Array(n);for(let w=0;w<n;w++){let H=new Array(s);for(let A=0;A<s;A++){let T=p*(A+w*s),g=v.subarray(T,T+p);H[A]=U(sn(g),r)}N[w]=H}return N}function Ce(e,n){let t=n.map(r=>Array.from(r).reverse());return(r,i)=>{let[s,c,a,o]=t.map(p=>p.reduce((x,v)=>e.add(e.mul(x,r),v))),[l,u]=wt(e,[c,o],!0);return r=e.mul(s,l),i=e.mul(i,e.mul(a,u)),{x:r,y:i}}}function Ue(e,n,t){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(s){return e.fromAffine(n(s))}function i(s){let c=s.clearCofactor();return c.equals(e.ZERO)?e.ZERO:(c.assertValidity(),c)}return{defaults:t,hashToCurve(s,c){let a=ke(s,2,{...t,DST:t.DST,...c}),o=r(a[0]),l=r(a[1]);return i(o.add(l))},encodeToCurve(s,c){let a=ke(s,1,{...t,DST:t.encodeDST,...c});return i(r(a[0]))},mapToCurve(s){if(!Array.isArray(s))throw new Error("expected array of bigints");for(let c of s)if(typeof c!="bigint")throw new Error("expected array of bigints");return i(r(s))}}}var At=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ie=BigInt(0),St=BigInt(1),Zt=BigInt(2),ze=(e,n)=>(e+n/Zt)/n;function Pe(e){let n=At,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),c=BigInt(23),a=BigInt(44),o=BigInt(88),l=e*e*e%n,u=l*l*e%n,p=W(u,t,n)*u%n,x=W(p,t,n)*u%n,v=W(x,Zt,n)*l%n,N=W(v,i,n)*v%n,w=W(N,s,n)*N%n,H=W(w,a,n)*w%n,A=W(H,o,n)*H%n,T=W(A,a,n)*w%n,g=W(T,t,n)*u%n,f=W(g,c,n)*N%n,m=W(f,r,n)*l%n,b=W(m,Zt,n);if(!ot.eql(ot.sqr(b),e))throw new Error("Cannot find square root");return b}var ot=xt(At,void 0,void 0,{sqrt:Pe}),kt=He({a:ie,b:BigInt(7),Fp:ot,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{let n=Lt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-St*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,c=BigInt("0x100000000000000000000000000000000"),a=ze(s*e,n),o=ze(-r*e,n),l=U(e-a*t-o*i,n),u=U(-a*r-o*s,n),p=l>c,x=u>c;if(p&&(l=n-l),x&&(u=n-u),l>c||u>c)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:p,k1:l,k2neg:x,k2:u}}}},pt),Me={};function Ht(e,...n){let t=Me[e];if(t===void 0){let r=pt(Uint8Array.from(e,i=>i.charCodeAt(0)));t=D(r,r),Me[e]=t}return pt(D(t,...n))}var ce=e=>e.toRawBytes(!0).slice(1),oe=e=>J(e,32),re=e=>U(e,At),Ot=e=>U(e,Lt),fe=kt.ProjectivePoint,ln=(e,n,t)=>fe.BASE.multiplyAndAddUnsafe(e,n,t);function se(e){let n=kt.utils.normPrivateKeyToScalar(e),t=fe.fromPrivateKey(n);return{scalar:t.hasEvenY()?n:Ot(-n),bytes:ce(t)}}function Ve(e){$("x",e,St,At);let n=re(e*e),t=re(n*e+BigInt(7)),r=Pe(t);r%Zt!==ie&&(r=re(-r));let i=new fe(e,r,St);return i.assertValidity(),i}var gt=Y;function je(...e){return Ot(gt(Ht("BIP0340/challenge",...e)))}function dn(e){return se(e).bytes}function un(e,n,t=It(32)){let r=z("message",e),{bytes:i,scalar:s}=se(n),c=z("auxRand",t,32),a=oe(s^gt(Ht("BIP0340/aux",c))),o=Ht("BIP0340/nonce",a,i,r),l=Ot(gt(o));if(l===ie)throw new Error("sign failed: k is zero");let{bytes:u,scalar:p}=se(l),x=je(u,i,r),v=new Uint8Array(64);if(v.set(u,0),v.set(oe(Ot(p+x*s)),32),!Ke(v,r,i))throw new Error("sign: Invalid signature produced");return v}function Ke(e,n,t){let r=z("signature",e,64),i=z("message",n),s=z("publicKey",t,32);try{let c=Ve(gt(s)),a=gt(r.subarray(0,32));if(!mt(a,St,At))return!1;let o=gt(r.subarray(32,64));if(!mt(o,St,Lt))return!1;let l=je(oe(a),ce(c),i),u=ln(c,o,Ot(-l));return!(!u||!u.hasEvenY()||u.toAffine().x!==a)}catch{return!1}}var Pn={getPublicKey:dn,sign:un,verify:Ke,utils:{randomPrivateKey:kt.utils.randomPrivateKey,lift_x:Ve,pointToBytes:ce,numberToBytesBE:J,bytesToNumberBE:Y,taggedHash:Ht,mod:U}},hn=Ce(ot,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(n=>BigInt(n)))),mn=Ze(ot,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ot.create(BigInt("-11"))}),Ye=Ue(kt.ProjectivePoint,e=>{let{x:n,y:t}=mn(ot.create(e[0]));return hn(n,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ot.ORDER,m:1,k:128,expand:"xmd",hash:pt}),Vn=Ye.hashToCurve,jn=Ye.encodeToCurve;export{jn as encodeToCurve,Vn as hashToCurve,Pn as schnorr,kt as secp256k1,Ye as secp256k1_hasher};
/*! Bundled license information:

@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
