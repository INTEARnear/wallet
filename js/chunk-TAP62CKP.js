import{b as Dt}from"./chunk-XVL5DJMZ.js";import{a as Nt}from"./chunk-NBB6K44E.js";import{Aa as ot,Cb as Ot,D as It,E as St,Kb as kt,Lb as Mt,O as Et,P as Pt,Rb as Rt,S as At,Vb as it,X as rt,da as Tt,za as jt}from"./chunk-SH2H32CZ.js";import{Ba as R,Cb as et,Cf as _t,Ob as nt,Pa as xt,Tb as O,Yb as K,fa as ft,ja as yt,na as L,oa as vt,ua as bt}from"./chunk-J26BEOSD.js";import{i as f,k as h,o as m}from"./chunk-JY5TIRRF.js";f();m();h();f();m();h();f();m();h();f();m();h();f();m();h();var G="3.2.2";var qt=()=>`@wagmi/core@${G}`;var Ft=function(e,n,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof n=="function"?e!==n||!r:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(e):r?r.value:n.get(e)},ct,Ut,N=class e extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return qt()}constructor(n,t={}){super(),ct.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});let r=t.cause instanceof e?t.cause.details:t.cause?.message?t.cause.message:t.details,o=t.cause instanceof e&&t.cause.docsPath||t.docsPath;this.message=[n||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...o?[`Docs: ${this.docsBaseUrl}${o}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=r,this.docsPath=o,this.metaMessages=t.metaMessages,this.shortMessage=n}walk(n){return Ft(this,ct,"m",Ut).call(this,this,n)}};ct=new WeakSet,Ut=function e(n,t){return t?.(n)?n:n.cause?Ft(this,ct,"m",e).call(this,n.cause,t):n};var D=class extends N{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}},V=class extends N{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}},W=class extends N{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}};var X=class extends N{constructor({address:n,connector:t}){super(`Account "${n}" not found for connector "${t.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}},Z=class extends N{constructor({connectionChainId:n,connectorChainId:t}){super(`The current chain of the connector (id: ${t}) does not match the connection's chain (id: ${n}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${n}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}},Q=class extends N{constructor({connector:n}){super(`Connector "${n.name}" unavailable while reconnecting.`,{details:["During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.","All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.","This error commonly occurs for connectors that asynchronously inject after reconnection has already started."].join(" ")}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}};f();m();h();var U=class extends N{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}},Y=class extends N{constructor({connector:n}){super(`"${n.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}};tt.type="injected";function tt(e={}){let{shimDisconnect:n=!0,unstable_shimAsyncInject:t}=e;function r(){let u=e.target;if(typeof u=="function"){let c=u();if(c)return c}return typeof u=="object"?u:typeof u=="string"?{...te[u]??{id:u,name:`${u[0].toUpperCase()}${u.slice(1)}`,provider:`is${u[0].toUpperCase()}${u.slice(1)}`}}:{id:"injected",name:"Injected",provider(c){return c?.ethereum}}}let o,i,s,d;return u=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},type:tt.type,async setup(){let c=await this.getProvider();c?.on&&e.target&&(s||(s=this.onConnect.bind(this),c.on("connect",s)),o||(o=this.onAccountsChanged.bind(this),c.on("accountsChanged",o)))},async connect({chainId:c,isReconnecting:a,withCapabilities:C}={}){let y=await this.getProvider();if(!y)throw new U;let v=[];if(a)v=await this.getAccounts().catch(()=>[]);else if(n)try{v=(await y.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0]?.caveats?.[0]?.value?.map(p=>R(p)),v.length>0&&(v=await this.getAccounts())}catch(E){let p=E;if(p.code===O.code)throw new O(p);if(p.code===nt.code)throw p}try{!v?.length&&!a&&(v=(await y.request({method:"eth_requestAccounts"})).map(b=>R(b))),s&&(y.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),y.on("accountsChanged",o)),i||(i=this.onChainChanged.bind(this),y.on("chainChanged",i)),d||(d=this.onDisconnect.bind(this),y.on("disconnect",d));let E=await this.getChainId();return c&&E!==c&&(E=(await this.switchChain({chainId:c}).catch(b=>{if(b.code===O.code)throw b;return{id:E}}))?.id??E),n&&await u.storage?.removeItem(`${this.id}.disconnected`),e.target||await u.storage?.setItem("injected.connected",!0),{accounts:C?v.map(p=>({address:p,capabilities:{}})):v,chainId:E}}catch(E){let p=E;throw p.code===O.code?new O(p):p.code===nt.code?new nt(p):p}},async disconnect(){let c=await this.getProvider();if(!c)throw new U;i&&(c.removeListener("chainChanged",i),i=void 0),d&&(c.removeListener("disconnect",d),d=void 0),s||(s=this.onConnect.bind(this),c.on("connect",s));try{await jt(()=>c.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}n&&await u.storage?.setItem(`${this.id}.disconnected`,!0),e.target||await u.storage?.removeItem("injected.connected")},async getAccounts(){let c=await this.getProvider();if(!c)throw new U;return(await c.request({method:"eth_accounts"})).map(C=>R(C))},async getChainId(){let c=await this.getProvider();if(!c)throw new U;let a=await c.request({method:"eth_chainId"});return Number(a)},async getProvider(){if(typeof window>"u")return;let c,a=r();return typeof a.provider=="function"?c=a.provider(window):typeof a.provider=="string"?c=st(window,a.provider):c=a.provider,c&&!c.removeListener&&("off"in c&&typeof c.off=="function"?c.removeListener=c.off:c.removeListener=()=>{}),c},async isAuthorized(){try{if(n&&await u.storage?.getItem(`${this.id}.disconnected`)||!e.target&&!await u.storage?.getItem("injected.connected"))return!1;if(!await this.getProvider()){if(t!==void 0&&t!==!1){let y=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",y),!!await this.getProvider()),v=typeof t=="number"?t:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(p=>window.addEventListener("ethereum#initialized",()=>p(y()),{once:!0}))]:[],new Promise(p=>setTimeout(()=>p(y()),v))]))return!0}throw new U}return!!(await At(()=>this.getAccounts())).length}catch{return!1}},async switchChain({addEthereumChainParameter:c,chainId:a}){let C=await this.getProvider();if(!C)throw new U;let y=u.chains.find(E=>E.id===a);if(!y)throw new K(new D);let v=new Promise(E=>{let p=b=>{"chainId"in b&&b.chainId===a&&(u.emitter.off("change",p),E())};u.emitter.on("change",p)});try{return await Promise.all([C.request({method:"wallet_switchEthereumChain",params:[{chainId:L(a)}]}).then(async()=>{await this.getChainId()===a&&u.emitter.emit("change",{chainId:a})}),v]),y}catch(E){let p=E;if(p.code===4902||p?.data?.originalError?.code===4902)try{let{default:b,...k}=y.blockExplorers??{},P;c?.blockExplorerUrls?P=c.blockExplorerUrls:b&&(P=[b.url,...Object.values(k).map(l=>l.url)]);let T;c?.rpcUrls?.length?T=c.rpcUrls:T=[y.rpcUrls.default?.http[0]??""];let M={blockExplorerUrls:P,chainId:L(a),chainName:c?.chainName??y.name,iconUrls:c?.iconUrls,nativeCurrency:c?.nativeCurrency??y.nativeCurrency,rpcUrls:T};return await Promise.all([C.request({method:"wallet_addEthereumChain",params:[M]}).then(async()=>{if(await this.getChainId()===a)u.emitter.emit("change",{chainId:a});else throw new O(new Error("User rejected switch after adding network."))}),v]),y}catch(b){throw new O(b)}throw p.code===O.code?new O(p):new K(p)}},async onAccountsChanged(c){if(c.length===0)this.onDisconnect();else if(u.emitter.listenerCount("connect")){let a=(await this.getChainId()).toString();this.onConnect({chainId:a}),n&&await u.storage?.removeItem(`${this.id}.disconnected`)}else u.emitter.emit("change",{accounts:c.map(a=>R(a))})},onChainChanged(c){let a=Number(c);u.emitter.emit("change",{chainId:a})},async onConnect(c){let a=await this.getAccounts();if(a.length===0)return;let C=Number(c.chainId);u.emitter.emit("connect",{accounts:a,chainId:C});let y=await this.getProvider();y&&(s&&(y.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),y.on("accountsChanged",o)),i||(i=this.onChainChanged.bind(this),y.on("chainChanged",i)),d||(d=this.onDisconnect.bind(this),y.on("disconnect",d)))},async onDisconnect(c){let a=await this.getProvider();c&&c.code===1013&&a&&(await this.getAccounts()).length||(u.emitter.emit("disconnect"),a&&(i&&(a.removeListener("chainChanged",i),i=void 0),d&&(a.removeListener("disconnect",d),d=void 0),s||(s=this.onConnect.bind(this),a.on("connect",s))))}})}var te={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(e){return e?.coinbaseWalletExtension?e.coinbaseWalletExtension:st(e,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(e){return st(e,n=>{if(!n.isMetaMask||n.isBraveWallet&&!n._events&&!n._state)return!1;let t=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPhantom","isPortal","isRabby","isTokenPocket","isTokenary","isUniswapWallet","isZerion"];for(let r of t)if(n[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(e){return e?.phantom?.ethereum?e.phantom?.ethereum:st(e,"isPhantom")}}};function st(e,n){function t(o){return typeof n=="function"?n(o):typeof n=="string"?o[n]:!0}let r=e.ethereum;if(r?.providers)return r.providers.find(o=>t(o));if(r&&t(r))return r}f();m();h();ht.type="mock";function ht(e){let n=new Map,t=e.features??{defaultConnected:!1},r=t.defaultConnected,o;return i=>({id:"mock",name:"Mock Connector",type:ht.type,async setup(){o=i.chains[0].id},async connect({chainId:s,withCapabilities:d}={}){if(t.connectError)throw typeof t.connectError=="boolean"?new O(new Error("Failed to connect.")):t.connectError;let c=await(await this.getProvider()).request({method:"eth_requestAccounts"}),a=await this.getChainId();return s&&a!==s&&(a=(await this.switchChain({chainId:s})).id),r=!0,{accounts:d?c.map(C=>({address:R(C),capabilities:{foo:{bar:C}}})):c.map(C=>R(C)),chainId:a}},async disconnect(){r=!1},async getAccounts(){if(!r)throw new W;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(u=>R(u))},async getChainId(){let d=await(await this.getProvider()).request({method:"eth_chainId"});return ft(d,"number")},async isAuthorized(){return!t.reconnect||!r?!1:!!(await this.getAccounts()).length},async switchChain({chainId:s}){let d=await this.getProvider(),u=i.chains.find(c=>c.id===s);if(!u)throw new K(new D);return await d.request({method:"wallet_switchEthereumChain",params:[{chainId:L(s)}]}),u},onAccountsChanged(s){s.length===0?this.onDisconnect():i.emitter.emit("change",{accounts:s.map(d=>R(d))})},onChainChanged(s){let d=Number(s);i.emitter.emit("change",{chainId:d})},async onDisconnect(s){i.emitter.emit("disconnect"),r=!1},async getProvider({chainId:s}={}){let u=(i.chains.find(a=>a.id===s)??i.chains[0]).rpcUrls.default.http[0];return it({request:async({method:a,params:C})=>{if(a==="eth_chainId")return L(o);if(a==="eth_requestAccounts")return e.accounts;if(a==="eth_signTypedData_v4"&&t.signTypedDataError)throw typeof t.signTypedDataError=="boolean"?new O(new Error("Failed to sign typed data.")):t.signTypedDataError;if(a==="wallet_switchEthereumChain"){if(t.switchChainError)throw typeof t.switchChainError=="boolean"?new O(new Error("Failed to switch chain.")):t.switchChainError;o=ft(C[0].chainId,"number"),this.onChainChanged(o.toString());return}if(a==="wallet_watchAsset"){if(t.watchAssetError)throw typeof t.watchAssetError=="boolean"?new O(new Error("Failed to switch chain.")):t.watchAssetError;return r}if(a==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:C[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:C[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"}}};if(a==="wallet_sendCalls"){let p=[],b=C[0].calls,k=C[0].from;for(let T of b){let{result:M,error:l}=await ot.http(u,{body:{method:"eth_sendTransaction",params:[{...T,...typeof k<"u"?{from:k}:{}}]}});if(l)throw new et({body:{method:a,params:C},error:l,url:u});p.push(M)}let P=bt(vt(JSON.stringify(b)));return n.set(P,p),{id:P}}if(a==="wallet_getCallsStatus"){let p=n.get(C[0]);if(!p)return{atomic:!1,chainId:"0x1",id:C[0],status:100,receipts:[],version:"2.0.0"};let k=(await Promise.all(p.map(async P=>{let{result:T,error:M}=await ot.http(u,{body:{method:"eth_getTransactionReceipt",params:[P],id:0}});if(M)throw new et({body:{method:a,params:C},error:M,url:u});return T?{blockHash:T.blockHash,blockNumber:T.blockNumber,gasUsed:T.gasUsed,logs:T.logs,status:T.status,transactionHash:T.transactionHash}:null}))).filter(P=>P!==null);return k.length===0?{atomic:!1,chainId:"0x1",id:C[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:C[0],status:200,receipts:k,version:"2.0.0"}}if(a==="wallet_showCallsStatus")return;if(a==="personal_sign"){if(t.signMessageError)throw typeof t.signMessageError=="boolean"?new O(new Error("Failed to sign message.")):t.signMessageError;a="eth_sign",C=[C[1],C[0]]}let y={method:a,params:C},{error:v,result:E}=await ot.http(u,{body:y});if(v)throw new et({body:y,error:v,url:u});return E}})({retryCount:0})}})}f();m();h();f();m();h();function j(e,n,t){let r=e[n.name];if(typeof r=="function")return r;let o=e[t];return typeof o=="function"?o:i=>n(e,i)}f();m();h();async function ee(e,n){let t;if(typeof n.connector=="function"?t=e._internal.connectors.setup(n.connector):t=n.connector,t.uid===e.state.current)throw new V;try{e.setState(s=>({...s,status:"connecting"})),t.emitter.emit("message",{type:"connecting"});let{connector:r,...o}=n,i=await t.connect(o);return t.emitter.off("connect",e._internal.events.connect),t.emitter.on("change",e._internal.events.change),t.emitter.on("disconnect",e._internal.events.disconnect),await e.storage?.setItem("recentConnectorId",t.id),e.setState(s=>({...s,connections:new Map(s.connections).set(t.uid,{accounts:o.withCapabilities?i.accounts.map(d=>typeof d=="object"?d.address:d):i.accounts,chainId:i.chainId,connector:t}),current:t.uid,status:"connected"})),{accounts:o.withCapabilities?i.accounts.map(s=>typeof s=="object"?s:{address:s,capabilities:{}}):i.accounts,chainId:i.chainId}}catch(r){throw e.setState(o=>({...o,status:o.current?"connected":"disconnected"})),r}}f();m();h();async function z(e,n={}){let{assertChainId:t=!0}=n,r;if(n.connector){let{connector:a}=n;if(e.state.status==="reconnecting"&&!a.getAccounts&&!a.getChainId)throw new Q({connector:a});let[C,y]=await Promise.all([a.getAccounts().catch(v=>{if(n.account===null)return[];throw v}),a.getChainId()]);r={accounts:C,chainId:y,connector:a}}else r=e.state.connections.get(e.state.current);if(!r)throw new W;let o=n.chainId??r.chainId,i=await r.connector.getChainId();if(t&&i!==o)throw new Z({connectionChainId:o,connectorChainId:i});let s=r.connector;if(s.getClient)return s.getClient({chainId:o});let d=xt(n.account??r.accounts[0]);if(d&&(d.address=R(d.address)),n.account&&!r.accounts.some(a=>a.toLowerCase()===d.address.toLowerCase()))throw new X({address:d.address,connector:s});let u=e.chains.find(a=>a.id===o),c=await r.connector.getProvider({chainId:o});return rt({account:d,chain:u,name:"Connector Client",transport:a=>it(c)({...a,retryCount:0})})}f();m();h();async function ne(e,n={}){let t;if(n.connector)t=n.connector;else{let{connections:o,current:i}=e.state;t=o.get(i)?.connector}let r=e.state.connections;t&&(await t.disconnect(),t.emitter.off("change",e._internal.events.change),t.emitter.off("disconnect",e._internal.events.disconnect),t.emitter.on("connect",e._internal.events.connect),r.delete(t.uid)),e.setState(o=>{if(r.size===0)return{...o,connections:new Map,current:null,status:"disconnected"};let i=r.values().next().value;return{...o,connections:new Map(r),current:i.connector.uid}});{let o=e.state.current;if(!o)return;let i=e.state.connections.get(o)?.connector;if(!i)return;await e.storage?.setItem("recentConnectorId",i.id)}}f();m();h();async function re(e,n){let{chainId:t,connector:r,...o}=n,i;n.account?i=n.account:i=(await z(e,{account:n.account,assertChainId:!1,chainId:t,connector:r})).account;let s=e.getClient({chainId:t});return j(s,St,"estimateGas")({...o,account:i})}f();m();h();async function oe(e,n){let{address:t,blockNumber:r,blockTag:o,chainId:i}=n,s=e.getClient({chainId:i}),u=await j(s,Tt,"getBalance")(r?{address:t,blockNumber:r}:{address:t,blockTag:o}),c=e.chains.find(a=>a.id===i)??s.chain;return{decimals:c.nativeCurrency.decimals,symbol:c.nativeCurrency.symbol,value:u}}f();m();h();function B(e,n){if(e===n)return!0;if(e&&n&&typeof e=="object"&&typeof n=="object"){if(e.constructor!==n.constructor)return!1;let t,r;if(Array.isArray(e)&&Array.isArray(n)){if(t=e.length,t!==n.length)return!1;for(r=t;r--!==0;)if(!B(e[r],n[r]))return!1;return!0}if(typeof e.valueOf=="function"&&e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(typeof e.toString=="function"&&e.toString!==Object.prototype.toString)return e.toString()===n.toString();let o=Object.keys(e);if(t=o.length,t!==Object.keys(n).length)return!1;for(r=t;r--!==0;)if(!Object.hasOwn(n,o[r]))return!1;for(r=t;r--!==0;){let i=o[r];if(i&&!B(e[i],n[i]))return!1}return!0}return e!==e&&n!==n}f();m();h();function J(e){let n=e.state.current,t=e.state.connections.get(n),r=t?.accounts,o=r?.[0],i=e.chains.find(d=>d.id===t?.chainId),s=e.state.status;switch(s){case"connected":return{address:o,addresses:r,chain:i,chainId:t?.chainId,connector:t?.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:s};case"reconnecting":return{address:o,addresses:r,chain:i,chainId:t?.chainId,connector:t?.connector,isConnected:!!o,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:s};case"connecting":return{address:o,addresses:r,chain:i,chainId:t?.chainId,connector:t?.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:s};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:s}}}f();m();h();var at=[];function mt(e){let n=[...e.state.connections.values()];return e.state.status==="reconnecting"||B(at,n)?at:(at=n,n)}f();m();h();async function ie(e,n){let{account:t,chainId:r,...o}=n,i=t??J(e).address,s=e.getClient({chainId:r});return j(s,It,"prepareTransactionRequest")({...o,...i?{account:i}:{}})}f();m();h();var pt=!1;async function ce(e,n={}){if(pt)return[];pt=!0,e.setState(c=>({...c,status:c.current?"reconnecting":"connecting"}));let t=[];if(n.connectors?.length)for(let c of n.connectors){let a;typeof c=="function"?a=e._internal.connectors.setup(c):a=c,t.push(a)}else t.push(...e.connectors);let r;try{r=await e.storage?.getItem("recentConnectorId")}catch{}let o={};for(let[,c]of e.state.connections)o[c.connector.id]=1;r&&(o[r]=0);let i=Object.keys(o).length>0?[...t].sort((c,a)=>(o[c.id]??10)-(o[a.id]??10)):t,s=!1,d=[],u=[];for(let c of i){let a=await c.getProvider().catch(()=>{});if(!a||u.some(v=>v===a)||!await c.isAuthorized())continue;let y=await c.connect({isReconnecting:!0}).catch(()=>null);y&&(c.emitter.off("connect",e._internal.events.connect),c.emitter.on("change",e._internal.events.change),c.emitter.on("disconnect",e._internal.events.disconnect),e.setState(v=>{let E=new Map(s?v.connections:new Map).set(c.uid,{accounts:y.accounts,chainId:y.chainId,connector:c});return{...v,current:s?v.current:c.uid,connections:E}}),d.push({accounts:y.accounts,chainId:y.chainId,connector:c}),u.push(a),s=!0)}return(e.state.status==="reconnecting"||e.state.status==="connecting")&&(s?e.setState(c=>({...c,status:"connected"})):e.setState(c=>({...c,connections:new Map,current:null,status:"disconnected"}))),pt=!1,d}f();m();h();async function se(e,n){let{account:t,chainId:r,connector:o,...i}=n,s;return typeof t=="object"&&t?.type==="local"?s=e.getClient({chainId:r}):s=await z(e,{account:t??void 0,assertChainId:!1,chainId:r,connector:o}),await j(s,Et,"sendTransaction")({...i,...t?{account:t}:{},chain:r?{id:r}:null,gas:i.gas??void 0})}f();m();h();async function ae(e,n){let{account:t,connector:r,...o}=n,i;return typeof t=="object"&&t.type==="local"?i=e.getClient():i=await z(e,{account:t,connector:r}),j(i,Rt,"signMessage")({...o,...t?{account:t}:{}})}f();m();h();async function ue(e,n){let{addEthereumChainParameter:t,chainId:r}=n,o=e.state.connections.get(n.connector?.uid??e.state.current);if(o){let s=o.connector;if(!s.switchChain)throw new Y({connector:s});return await s.switchChain({addEthereumChainParameter:t,chainId:r})}let i=e.chains.find(s=>s.id===r);if(!i)throw new D;return e.setState(s=>({...s,chainId:r})),i}f();m();h();async function de(e,n){let{chainId:t,timeout:r=0,...o}=n,i=e.getClient({chainId:t}),d=await j(i,kt,"waitForTransactionReceipt")({...o,timeout:r});if(d.status==="reverted"){let u=j(i,Ot,"getTransaction"),{from:c,...a}=await u({hash:d.transactionHash}),y=await j(i,_t,"call")({...a,account:c,data:a.input,gasPrice:a.type!=="eip1559"?a.gasPrice:void 0,maxFeePerGas:a.type==="eip1559"?a.maxFeePerGas:void 0,maxPriorityFeePerGas:a.type==="eip1559"?a.maxPriorityFeePerGas:void 0}),v=y?.data?yt(`0x${y.data.substring(138)}`):"unknown reason";throw new Error(v)}return{...d,chainId:i.chain.id}}f();m();h();function $t(e,n){let{onChange:t}=n;return e.subscribe(()=>J(e),t,{equalityFn(r,o){let{connector:i,...s}=r,{connector:d,...u}=o;return B(s,u)&&i?.id===d?.id&&i?.uid===d?.uid}})}f();m();h();function le(e,n){let{onChange:t}=n;return e.subscribe(()=>mt(e),t,{equalityFn:B})}f();m();h();function fe(e,n){let{onChange:t}=n;return e._internal.connectors.subscribe((r,o)=>{t(Object.values(r),o)})}f();m();h();function he(e,n){let{syncConnectedChain:t=e._internal.syncConnectedChain,...r}=n,o,i=u=>{o&&o();let c=e.getClient({chainId:u});return o=j(c,Mt,"watchPendingTransactions")(r),o},s=i(n.chainId),d;return t&&!n.chainId&&(d=e.subscribe(({chainId:u})=>u,async u=>i(u))),()=>{s?.(),d?.()}}f();m();h();async function me(e,n){let{account:t,chainId:r,connector:o,...i}=n,s;return typeof t=="object"&&t?.type==="local"?s=e.getClient({chainId:r}):s=await z(e,{account:t??void 0,assertChainId:!1,chainId:r,connector:o}),await j(s,Pt,"writeContract")({...i,...t?{account:t}:{},chain:r?{id:r}:null})}f();m();h();f();m();h();var pe=e=>(n,t,r)=>{let o=r.subscribe;return r.subscribe=(s,d,u)=>{let c=s;if(d){let a=u?.equalityFn||Object.is,C=s(r.getState());c=y=>{let v=s(y);if(!a(C,v)){let E=C;d(C=v,E)}},u?.fireImmediately&&d(C,C)}return o(c)},e(n,t,r)},zt=pe;function ge(e,n){let t;try{t=e()}catch{return}return{getItem:o=>{var i;let s=u=>u===null?null:JSON.parse(u,n?.reviver),d=(i=t.getItem(o))!=null?i:null;return d instanceof Promise?d.then(s):s(d)},setItem:(o,i)=>t.setItem(o,JSON.stringify(i,n?.replacer)),removeItem:o=>t.removeItem(o)}}var gt=e=>n=>{try{let t=e(n);return t instanceof Promise?t:{then(r){return gt(r)(t)},catch(r){return this}}}catch(t){return{then(r){return this},catch(r){return gt(r)(t)}}}},we=(e,n)=>(t,r,o)=>{let i={storage:ge(()=>localStorage),partialize:p=>p,version:0,merge:(p,b)=>({...b,...p}),...n},s=!1,d=new Set,u=new Set,c=i.storage;if(!c)return e((...p)=>{console.warn(`[zustand persist middleware] Unable to update item '${i.name}', the given storage is currently unavailable.`),t(...p)},r,o);let a=()=>{let p=i.partialize({...r()});return c.setItem(i.name,{state:p,version:i.version})},C=o.setState;o.setState=(p,b)=>{C(p,b),a()};let y=e((...p)=>{t(...p),a()},r,o);o.getInitialState=()=>y;let v,E=()=>{var p,b;if(!c)return;s=!1,d.forEach(P=>{var T;return P((T=r())!=null?T:y)});let k=((b=i.onRehydrateStorage)==null?void 0:b.call(i,(p=r())!=null?p:y))||void 0;return gt(c.getItem.bind(c))(i.name).then(P=>{if(P)if(typeof P.version=="number"&&P.version!==i.version){if(i.migrate)return[!0,i.migrate(P.state,P.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,P.state];return[!1,void 0]}).then(P=>{var T;let[M,l]=P;if(v=i.merge(l,(T=r())!=null?T:y),t(v,!0),M)return a()}).then(()=>{k?.(v,void 0),v=r(),s=!0,u.forEach(P=>P(v))}).catch(P=>{k?.(void 0,P)})};return o.persist={setOptions:p=>{i={...i,...p},p.storage&&(c=p.storage)},clearStorage:()=>{c?.removeItem(i.name)},getOptions:()=>i,rehydrate:()=>E(),hasHydrated:()=>s,onHydrate:p=>(d.add(p),()=>{d.delete(p)}),onFinishHydration:p=>(u.add(p),()=>{u.delete(p)})},i.skipHydration||E(),v||y},Bt=we;f();m();h();var Wt=e=>{let n,t=new Set,r=(c,a)=>{let C=typeof c=="function"?c(n):c;if(!Object.is(C,n)){let y=n;n=a??(typeof C!="object"||C===null)?C:Object.assign({},n,C),t.forEach(v=>v(n,y))}},o=()=>n,d={setState:r,getState:o,getInitialState:()=>u,subscribe:c=>(t.add(c),()=>t.delete(c))},u=n=e(r,o,d);return d},ut=e=>e?Wt(e):Wt;f();m();h();var wt=class{constructor(n){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Nt.default})}on(n,t){this._emitter.on(n,t)}once(n,t){this._emitter.once(n,t)}off(n,t){this._emitter.off(n,t)}emit(n,...t){let r=t[0];this._emitter.emit(n,{uid:this.uid,...r})}listenerCount(n){return this._emitter.listenerCount(n)}};function Ht(e){return new wt(e)}f();m();h();f();m();h();function Lt(e,n){return JSON.parse(e,(t,r)=>{let o=r;return o?.__type==="bigint"&&(o=BigInt(o.value)),o?.__type==="Map"&&(o=new Map(o.value)),n?.(t,o)??o})}f();m();h();function Gt(e,n){return e.slice(0,n).join(".")||"."}function Jt(e,n){let{length:t}=e;for(let r=0;r<t;++r)if(e[r]===n)return r+1;return 0}function Ce(e,n){let t=typeof e=="function",r=typeof n=="function",o=[],i=[];return function(d,u){if(typeof u=="object")if(o.length){let c=Jt(o,this);c===0?o[o.length]=this:(o.splice(c),i.splice(c)),i[i.length]=d;let a=Jt(o,u);if(a!==0)return r?n.call(this,d,u,Gt(i,a)):`[ref=${Gt(i,a)}]`}else o[0]=u,i[0]=d;return t?e.call(this,d,u):u}}function Kt(e,n,t,r){return JSON.stringify(e,Ce((o,i)=>{let s=i;return typeof s=="bigint"&&(s={__type:"bigint",value:i.toString()}),s instanceof Map&&(s={__type:"Map",value:Array.from(i.entries())}),n?.(o,s)??s},r),t??void 0)}function Vt(e){let{deserialize:n=Lt,key:t="wagmi",serialize:r=Kt,storage:o=Xt}=e;function i(s){return s instanceof Promise?s.then(d=>d).catch(()=>null):s}return{...o,key:t,async getItem(s,d){let u=o.getItem(`${t}.${s}`),c=await i(u);return c?n(c)??null:d??null},async setItem(s,d){let u=`${t}.${s}`;d===null?await i(o.removeItem(u)):await i(o.setItem(u,r(d)))},async removeItem(s){await i(o.removeItem(`${t}.${s}`))}}}var Xt={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function Zt(){let e=typeof window<"u"&&window.localStorage?window.localStorage:Xt;return{getItem(n){return e.getItem(n)},removeItem(n){e.removeItem(n)},setItem(n,t){try{e.setItem(n,t)}catch{}}}}f();m();h();var dt=256,lt;function Qt(e=11){if(!lt||dt+e>256*2){lt="",dt=0;for(let n=0;n<256;n++)lt+=(256+Math.random()*256|0).toString(16).substring(1)}return lt.substring(dt,dt+++e)}function ye(e){let{multiInjectedProviderDiscovery:n=!0,storage:t=Vt({storage:Zt()}),syncConnectedChain:r=!0,ssr:o=!1,...i}=e,s=typeof window<"u"&&n?Dt():void 0,d=ut(()=>i.chains),u=ut(()=>{let l=[],w=new Set;for(let g of i.connectors??[]){let A=c(g);if(l.push(A),!o&&A.rdns){let x=typeof A.rdns=="string"?[A.rdns]:A.rdns;for(let q of x)w.add(q)}}if(!o&&s){let g=s.getProviders();for(let A of g)w.has(A.info.rdns)||l.push(c(a(A)))}return l});function c(l){let w=Ht(Qt()),g={...l({emitter:w,chains:d.getState(),storage:t,transports:i.transports}),emitter:w,uid:w.uid};return w.on("connect",T),g.setup?.(),g}function a(l){let{info:w}=l,g=l.provider;return tt({target:{...w,id:w.rdns,provider:g}})}let C=new Map;function y(l={}){let w=l.chainId??b.getState().chainId,g=d.getState().find(x=>x.id===w);if(l.chainId&&!g)throw new D;{let x=C.get(b.getState().chainId);if(x&&!g)return x;if(!g)throw new D}{let x=C.get(w);if(x)return x}let A;if(i.client)A=i.client({chain:g});else{let x=g.id,q=d.getState().map(F=>F.id),$={},Ct=Object.entries(i);for(let[F,H]of Ct)if(!(F==="chains"||F==="client"||F==="connectors"||F==="transports"))if(typeof H=="object")if(x in H)$[F]=H[x];else{if(q.some(Yt=>Yt in H))continue;$[F]=H}else $[F]=H;A=rt({...$,chain:g,batch:$.batch??{multicall:!0},transport:F=>i.transports[x]({...F,connectors:u})})}return C.set(w,A),A}function v(){return{chainId:d.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let E,p="0.0.0-canary-";G.startsWith(p)?E=Number.parseInt(G.replace(p,""),10):E=Number.parseInt(G.split(".")[0]??"0",10);let b=ut(zt(t?Bt(v,{migrate(l,w){if(w===E)return l;let g=v(),A=k(l,g.chainId);return{...g,chainId:A}},name:"store",partialize(l){return{connections:{__type:"Map",value:Array.from(l.connections.entries()).map(([w,g])=>{let{id:A,name:x,type:q,uid:$}=g.connector;return[w,{...g,connector:{id:A,name:x,type:q,uid:$}}]})},chainId:l.chainId,current:l.current}},merge(l,w){typeof l=="object"&&l&&"status"in l&&delete l.status;let g=k(l,w.chainId);return{...w,...l,chainId:g}},skipHydration:o,storage:t,version:E}):v));b.setState(v());function k(l,w){return l&&typeof l=="object"&&"chainId"in l&&typeof l.chainId=="number"&&d.getState().some(g=>g.id===l.chainId)?l.chainId:w}r&&b.subscribe(({connections:l,current:w})=>w?l.get(w)?.chainId:void 0,l=>{if(d.getState().some(g=>g.id===l))return b.setState(g=>({...g,chainId:l??g.chainId}))}),s?.subscribe(l=>{let w=new Set,g=new Set;for(let x of u.getState())if(w.add(x.id),x.rdns){let q=typeof x.rdns=="string"?[x.rdns]:x.rdns;for(let $ of q)g.add($)}let A=[];for(let x of l){if(g.has(x.info.rdns))continue;let q=c(a(x));w.has(q.id)||A.push(q)}t&&!b.persist.hasHydrated()||u.setState(x=>[...x,...A],!0)});function P(l){b.setState(w=>{let g=w.connections.get(l.uid);return g?{...w,connections:new Map(w.connections).set(l.uid,{accounts:l.accounts??g.accounts,chainId:l.chainId??g.chainId,connector:g.connector})}:w})}function T(l){b.getState().status==="connecting"||b.getState().status==="reconnecting"||b.setState(w=>{let g=u.getState().find(A=>A.uid===l.uid);return g?(g.emitter.listenerCount("connect")&&g.emitter.off("connect",P),g.emitter.listenerCount("change")||g.emitter.on("change",P),g.emitter.listenerCount("disconnect")||g.emitter.on("disconnect",M),{...w,connections:new Map(w.connections).set(l.uid,{accounts:l.accounts,chainId:l.chainId,connector:g}),current:l.uid,status:"connected"}):w})}function M(l){b.setState(w=>{let g=w.connections.get(l.uid);if(g){let x=g.connector;x.emitter.listenerCount("change")&&g.connector.emitter.off("change",P),x.emitter.listenerCount("disconnect")&&g.connector.emitter.off("disconnect",M),x.emitter.listenerCount("connect")||g.connector.emitter.on("connect",T)}if(w.connections.delete(l.uid),w.connections.size===0)return{...w,connections:new Map,current:null,status:"disconnected"};let A=w.connections.values().next().value;return{...w,connections:new Map(w.connections),current:A.connector.uid}})}return{get chains(){return d.getState()},get connectors(){return u.getState()},storage:t,getClient:y,get state(){return b.getState()},setState(l){let w;typeof l=="function"?w=l(b.getState()):w=l;let g=v();typeof w!="object"&&(w=g),Object.keys(g).some(x=>!(x in w))&&(w=g),b.setState(w,!0)},subscribe(l,w,g){return b.subscribe(l,w,g?{...g,fireImmediately:g.emitImmediately}:void 0)},_internal:{mipd:s,async revalidate(){let l=b.getState(),w=l.connections,g=l.current;for(let[,A]of w){let x=A.connector;x.isAuthorized&&await x.isAuthorized()||(w.delete(x.uid),g===x.uid&&(g=null))}b.setState(A=>({...A,connections:w,current:g}))},store:b,ssr:!!o,syncConnectedChain:r,transports:i.transports,chains:{setState(l){let w=typeof l=="function"?l(d.getState()):l;if(w.length!==0)return d.setState(w,!0)},subscribe(l){return d.subscribe(l)}},connectors:{providerDetailToConnector:a,setup:c,setState(l){return u.setState(typeof l=="function"?l(u.getState()):l,!0)},subscribe(l){return u.subscribe(l)}},events:{change:P,connect:T,disconnect:M}}}}f();m();h();function ve(e){let{chain:n}=e,t=n.rpcUrls.default.http[0];if(!e.transports)return[t];let r=e.transports?.[n.id]?.({chain:n});return(r?.value?.transports||[r]).map(({value:i})=>i?.url||t)}export{D as a,ee as b,ne as c,re as d,oe as e,J as f,mt as g,ie as h,ce as i,se as j,ae as k,U as l,ue as m,de as n,$t as o,le as p,fe as q,he as r,me as s,tt as t,ht as u,ye as v,ve as w};
