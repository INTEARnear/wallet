import"./chunk-CJAFSYKO.js";import"./chunk-TTFJII2K.js";import"./chunk-ZFRNME6I.js";import"./chunk-5PGJTF3M.js";import{b as Ie,d as oo}from"./chunk-UYWH7IPM.js";import{D as Ve,F as Dt,L as ro,N as so,b as Y,g as Qs,j as _n,k as eo,l as to,o as no}from"./chunk-ORERQN7J.js";import{a as Cr,d as Vs,h as Hs,i as Tr,j as qs,k as Gs,l as js}from"./chunk-R4QSWZFH.js";import"./chunk-Z65QX34R.js";import{a as kr}from"./chunk-RRN7SHYG.js";import{a as Or,b as Ys,c as Xs}from"./chunk-5UJIL6SO.js";import"./chunk-XEUUDCWO.js";import{c as Js,d as Zs}from"./chunk-WN72UQGN.js";import"./chunk-2T2LG5CT.js";import"./chunk-KG5GTMNR.js";import"./chunk-ANQ7QFBQ.js";import"./chunk-ZMTN5ZA6.js";import"./chunk-C76LFVKJ.js";import"./chunk-AXPE5NAX.js";import{d as Ls,e as Ps,g as Bs,h as xs}from"./chunk-YDPF4UGR.js";import{a as ce}from"./chunk-LQBGFF7Y.js";import"./chunk-F3BT2OCD.js";import"./chunk-OIFNSKKM.js";import"./chunk-YY5EM6U5.js";import{a as Nr}from"./chunk-LHWHJQRC.js";import{a as vs}from"./chunk-AMYL42KT.js";import"./chunk-V7H3HPRQ.js";import"./chunk-EAWY7VYO.js";import{a as Oe,b as Te,c as Fs,d as Ir,e as pn,f as Ws,g as Ks,h as $s,i as gn}from"./chunk-HGX345GB.js";import{b as Ds}from"./chunk-JJVWQEYF.js";import{w as Er}from"./chunk-JGRP444H.js";import"./chunk-URLXKBQX.js";import{c as fn,e as Ms,h as hn,j as wr,k as De,l as Sr,o as Et,s as zs,t as br}from"./chunk-FFQJ55XB.js";import{H as Us}from"./chunk-6K56CBXQ.js";import"./chunk-WGWCH7J2.js";import{c as $e,f as Ue,g as ks}from"./chunk-57YRCRKT.js";var ho=$e((bp,fo)=>{"use strict";var yn=Xs().Buffer;function fa(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<s.length;n++){var r=s.charAt(n),o=r.charCodeAt(0);if(e[o]!==255)throw new TypeError(r+" is ambiguous");e[o]=n}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),f=Math.log(256)/Math.log(i);function d(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=yn.from(p)),!yn.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var y=0,g=0,A=0,C=p.length;A!==C&&p[A]===0;)A++,y++;for(var x=(C-A)*f+1>>>0,Q=new Uint8Array(x);A!==C;){for(var O=p[A],ne=0,re=x-1;(O!==0||ne<g)&&re!==-1;re--,ne++)O+=256*Q[re]>>>0,Q[re]=O%i>>>0,O=O/i>>>0;if(O!==0)throw new Error("Non-zero carry");g=ne,A++}for(var K=x-g;K!==x&&Q[K]===0;)K++;for(var le=a.repeat(y);K<x;++K)le+=s.charAt(Q[K]);return le}function m(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return yn.alloc(0);for(var y=0,g=0,A=0;p[y]===a;)g++,y++;for(var C=(p.length-y)*c+1>>>0,x=new Uint8Array(C);y<p.length;){var Q=p.charCodeAt(y);if(Q>255)return;var O=e[Q];if(O===255)return;for(var ne=0,re=C-1;(O!==0||ne<A)&&re!==-1;re--,ne++)O+=i*x[re]>>>0,x[re]=O%256>>>0,O=O/256>>>0;if(O!==0)throw new Error("Non-zero carry");A=ne,y++}for(var K=C-A;K!==C&&x[K]===0;)K++;var le=yn.allocUnsafe(g+(C-K));le.fill(0,0,g);for(var Rt=g;K!==C;)le[Rt++]=x[K++];return le}function I(p){var y=m(p);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:d,decodeUnsafe:m,decode:I}}fo.exports=fa});var go=$e((Ip,po)=>{var ha=ho(),pa="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";po.exports=ha(pa)});var yo=$e((Np,_o)=>{"use strict";var mn=Xs().Buffer;function ga(s){if(s.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var n=0;n<s.length;n++){var r=s.charAt(n),o=r.charCodeAt(0);if(e[o]!==255)throw new TypeError(r+" is ambiguous");e[o]=n}var i=s.length,a=s.charAt(0),c=Math.log(i)/Math.log(256),f=Math.log(256)/Math.log(i);function d(p){if((Array.isArray(p)||p instanceof Uint8Array)&&(p=mn.from(p)),!mn.isBuffer(p))throw new TypeError("Expected Buffer");if(p.length===0)return"";for(var y=0,g=0,A=0,C=p.length;A!==C&&p[A]===0;)A++,y++;for(var x=(C-A)*f+1>>>0,Q=new Uint8Array(x);A!==C;){for(var O=p[A],ne=0,re=x-1;(O!==0||ne<g)&&re!==-1;re--,ne++)O+=256*Q[re]>>>0,Q[re]=O%i>>>0,O=O/i>>>0;if(O!==0)throw new Error("Non-zero carry");g=ne,A++}for(var K=x-g;K!==x&&Q[K]===0;)K++;for(var le=a.repeat(y);K<x;++K)le+=s.charAt(Q[K]);return le}function m(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return mn.alloc(0);for(var y=0,g=0,A=0;p[y]===a;)g++,y++;for(var C=(p.length-y)*c+1>>>0,x=new Uint8Array(C);y<p.length;){var Q=p.charCodeAt(y);if(Q>255)return;var O=e[Q];if(O===255)return;for(var ne=0,re=C-1;(O!==0||ne<A)&&re!==-1;re--,ne++)O+=i*x[re]>>>0,x[re]=O%256>>>0,O=O/256>>>0;if(O!==0)throw new Error("Non-zero carry");A=ne,y++}for(var K=C-A;K!==C&&x[K]===0;)K++;var le=mn.allocUnsafe(g+(C-K));le.fill(0,0,g);for(var Rt=g;K!==C;)le[Rt++]=x[K++];return le}function I(p){var y=m(p);if(y)return y;throw new Error("Non-base"+i+" character")}return{encode:d,decodeUnsafe:m,decode:I}}_o.exports=ga});var Ao=$e((Cp,mo)=>{var _a=yo(),ya="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";mo.exports=_a(ya)});var Ro=$e(Br=>{"use strict";function He(s,e,t){return e<=s&&s<=t}function Sn(s){if(s===void 0)return{};if(s===Object(s))return s;throw TypeError("Could not convert argument to dictionary")}function ma(s){for(var e=String(s),t=e.length,n=0,r=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)r.push(o);else if(56320<=o&&o<=57343)r.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)r.push(65533);else{var i=s.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;r.push(65536+(a<<10)+c),n+=1}else r.push(65533)}n+=1}return r}function Aa(s){for(var e="",t=0;t<s.length;++t){var n=s[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var An=-1;function Pr(s){this.tokens=[].slice.call(s)}Pr.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():An},prepend:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(s)},push:function(s){if(Array.isArray(s))for(var e=s;e.length;)this.tokens.push(e.shift());else this.tokens.push(s)}};var wt=-1;function Lr(s,e){if(s)throw TypeError("Decoder error");return e||65533}var Rn="utf-8";function En(s,e){if(!(this instanceof En))return new En(s,e);if(s=s!==void 0?String(s).toLowerCase():Rn,s!==Rn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Sn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}En.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=Sn(t),this._streaming||(this._decoder=new Ra({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var r=new Pr(n),o=[],i;!r.endOfStream()&&(i=this._decoder.handler(r,r.read()),i!==wt);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(r,r.read()),i===wt)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!r.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Aa(o)}};function wn(s,e){if(!(this instanceof wn))return new wn(s,e);if(s=s!==void 0?String(s).toLowerCase():Rn,s!==Rn)throw new Error("Encoding not supported. Only utf-8 is supported");e=Sn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}wn.prototype={encode:function(e,t){e=e?String(e):"",t=Sn(t),this._streaming||(this._encoder=new Ea(this._options)),this._streaming=!!t.stream;for(var n=[],r=new Pr(ma(e)),o;!r.endOfStream()&&(o=this._encoder.handler(r,r.read()),o!==wt);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(r,r.read()),o!==wt;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function Ra(s){var e=s.fatal,t=0,n=0,r=0,o=128,i=191;this.handler=function(a,c){if(c===An&&r!==0)return r=0,Lr(e);if(c===An)return wt;if(r===0){if(He(c,0,127))return c;if(He(c,194,223))r=1,t=c-192;else if(He(c,224,239))c===224&&(o=160),c===237&&(i=159),r=2,t=c-224;else if(He(c,240,244))c===240&&(o=144),c===244&&(i=143),r=3,t=c-240;else return Lr(e);return t=t<<6*r,null}if(!He(c,o,i))return t=r=n=0,o=128,i=191,a.prepend(c),Lr(e);if(o=128,i=191,n+=1,t+=c-128<<6*(r-n),n!==r)return null;var f=t;return t=r=n=0,f}}function Ea(s){var e=s.fatal;this.handler=function(t,n){if(n===An)return wt;if(He(n,0,127))return n;var r,o;He(n,128,2047)?(r=1,o=192):He(n,2048,65535)?(r=2,o=224):He(n,65536,1114111)&&(r=3,o=240);for(var i=[(n>>6*r)+o];r>0;){var a=n>>6*(r-1);i.push(128|a&63),r-=1}return i}}Br.TextEncoder=wn;Br.TextDecoder=En});var Io=$e(G=>{"use strict";var wa=G&&G.__createBinding||(Object.create?function(s,e,t,n){n===void 0&&(n=t),Object.defineProperty(s,n,{enumerable:!0,get:function(){return e[t]}})}:function(s,e,t,n){n===void 0&&(n=t),s[n]=e[t]}),Sa=G&&G.__setModuleDefault||(Object.create?function(s,e){Object.defineProperty(s,"default",{enumerable:!0,value:e})}:function(s,e){s.default=e}),ze=G&&G.__decorate||function(s,e,t,n){var r=arguments.length,o=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(s,e,t,n);else for(var a=s.length-1;a>=0;a--)(i=s[a])&&(o=(r<3?i(o):r>3?i(e,t,o):i(e,t))||o);return r>3&&o&&Object.defineProperty(e,t,o),o},ba=G&&G.__importStar||function(s){if(s&&s.__esModule)return s;var e={};if(s!=null)for(var t in s)t!=="default"&&Object.hasOwnProperty.call(s,t)&&wa(e,s,t);return Sa(e,s),e},Eo=G&&G.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(G,"__esModule",{value:!0});G.deserializeUnchecked=G.deserialize=G.serialize=G.BinaryReader=G.BinaryWriter=G.BorshError=G.baseDecode=G.baseEncode=void 0;var Je=Eo(Ys()),wo=Eo(Ao()),Ia=ba(Ro()),Na=typeof TextDecoder!="function"?Ia.TextDecoder:TextDecoder,Ca=new Na("utf-8",{fatal:!0});function Oa(s){return typeof s=="string"&&(s=Buffer.from(s,"utf8")),wo.default.encode(Buffer.from(s))}G.baseEncode=Oa;function Ta(s){return Buffer.from(wo.default.decode(s))}G.baseDecode=Ta;var xr=1024,ue=class extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}};G.BorshError=ue;var bn=class{constructor(){this.buf=Buffer.alloc(xr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(xr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Je.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Je.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Je.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new Je.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(xr)]),this.length+=e.length}writeString(e){this.maybeResize();let t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(let n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}};G.BinaryWriter=bn;function Fe(s,e,t){let n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(o){if(o instanceof RangeError){let i=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new ue("Reached the end of buffer when deserializing")}throw o}}}var _e=class{constructor(e){this.buf=e,this.offset=0}readU8(){let e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){let e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){let e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){let e=this.readBuffer(8);return new Je.default(e,"le")}readU128(){let e=this.readBuffer(16);return new Je.default(e,"le")}readU256(){let e=this.readBuffer(32);return new Je.default(e,"le")}readU512(){let e=this.readBuffer(64);return new Je.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new ue(`Expected buffer length ${e} isn't within bounds`);let t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){let e=this.readU32(),t=this.readBuffer(e);try{return Ca.decode(t)}catch(n){throw new ue(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){let t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}};ze([Fe],_e.prototype,"readU8",null);ze([Fe],_e.prototype,"readU16",null);ze([Fe],_e.prototype,"readU32",null);ze([Fe],_e.prototype,"readU64",null);ze([Fe],_e.prototype,"readU128",null);ze([Fe],_e.prototype,"readU256",null);ze([Fe],_e.prototype,"readU512",null);ze([Fe],_e.prototype,"readString",null);ze([Fe],_e.prototype,"readFixedArray",null);ze([Fe],_e.prototype,"readArray",null);G.BinaryReader=_e;function So(s){return s.charAt(0).toUpperCase()+s.slice(1)}function ut(s,e,t,n,r){try{if(typeof n=="string")r[`write${So(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new ue(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new ue(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let o=0;o<n[1];o++)ut(s,null,t[o],n[0],r)}else r.writeArray(t,o=>{ut(s,e,o,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),ut(s,e,t,n.type,r));break}case"map":{r.writeU32(t.size),t.forEach((o,i)=>{ut(s,e,i,n.key,r),ut(s,e,o,n.value,r)});break}default:throw new ue(`FieldType ${n} unrecognized`)}else bo(s,t,r)}catch(o){throw o instanceof ue&&o.addToFieldPath(e),o}}function bo(s,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}let n=s.get(e.constructor);if(!n)throw new ue(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,o])=>{ut(s,r,e[r],o,t)});else if(n.kind==="enum"){let r=e[n.field];for(let o=0;o<n.values.length;++o){let[i,a]=n.values[o];if(i===r){t.writeU8(o),ut(s,i,e[i],a,t);break}}}else throw new ue(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function ka(s,e,t=bn){let n=new t;return bo(s,e,n),n.toArray()}G.serialize=ka;function dt(s,e,t,n){try{if(typeof t=="string")return n[`read${So(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){let r=[];for(let o=0;o<t[1];o++)r.push(dt(s,null,t[0],n));return r}else return n.readArray(()=>dt(s,e,t[0],n))}if(t.kind==="option")return n.readU8()?dt(s,e,t.type,n):void 0;if(t.kind==="map"){let r=new Map,o=n.readU32();for(let i=0;i<o;i++){let a=dt(s,e,t.key,n),c=dt(s,e,t.value,n);r.set(a,c)}return r}return Ur(s,t,n)}catch(r){throw r instanceof ue&&r.addToFieldPath(e),r}}function Ur(s,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);let n=s.get(e);if(!n)throw new ue(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){let r={};for(let[o,i]of s.get(e).fields)r[o]=dt(s,o,i,t);return new e(r)}if(n.kind==="enum"){let r=t.readU8();if(r>=n.values.length)throw new ue(`Enum index: ${r} is out of range`);let[o,i]=n.values[r],a=dt(s,o,i,t);return new e({[o]:a})}throw new ue(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function va(s,e,t,n=_e){let r=new n(t),o=Ur(s,e,r);if(r.offset<t.length)throw new ue(`Unexpected ${t.length-r.offset} bytes after deserialized data`);return o}G.deserialize=va;function La(s,e,t,n=_e){let r=new n(t);return Ur(s,e,r)}G.deserializeUnchecked=La});var Fr=$e(h=>{"use strict";Object.defineProperty(h,"__esModule",{value:!0});h.s16=h.s8=h.nu64be=h.u48be=h.u40be=h.u32be=h.u24be=h.u16be=h.nu64=h.u48=h.u40=h.u32=h.u24=h.u16=h.u8=h.offset=h.greedy=h.Constant=h.UTF8=h.CString=h.Blob=h.Boolean=h.BitField=h.BitStructure=h.VariantLayout=h.Union=h.UnionLayoutDiscriminator=h.UnionDiscriminator=h.Structure=h.Sequence=h.DoubleBE=h.Double=h.FloatBE=h.Float=h.NearInt64BE=h.NearInt64=h.NearUInt64BE=h.NearUInt64=h.IntBE=h.Int=h.UIntBE=h.UInt=h.OffsetLayout=h.GreedyCount=h.ExternalLayout=h.bindConstructorLayout=h.nameWithProperty=h.Layout=h.uint8ArrayToBuffer=h.checkUint8Array=void 0;h.constant=h.utf8=h.cstr=h.blob=h.unionLayoutDiscriminator=h.union=h.seq=h.bits=h.struct=h.f64be=h.f64=h.f32be=h.f32=h.ns64be=h.s48be=h.s40be=h.s32be=h.s24be=h.s16be=h.ns64=h.s48=h.s40=h.s32=h.s24=void 0;var Mr=Or();function It(s){if(!(s instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}h.checkUint8Array=It;function V(s){return It(s),Mr.Buffer.from(s.buffer,s.byteOffset,s.length)}h.uint8ArrayToBuffer=V;var H=class{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){let t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}};h.Layout=H;function zr(s,e){return e.property?s+"["+e.property+"]":s}h.nameWithProperty=zr;function Pa(s,e){if(typeof s!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(s,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof H))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");s.layout_=e,e.boundConstructor_=s,e.makeDestinationObject=()=>new s,Object.defineProperty(s.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(s,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}h.bindConstructorLayout=Pa;var he=class extends H{isCount(){throw new Error("ExternalLayout is abstract")}};h.ExternalLayout=he;var In=class extends he{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){It(e);let n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}};h.GreedyCount=In;var zt=class extends he{constructor(e,t=0,n){if(!(e instanceof H))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof ye||this.layout instanceof Ae}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}};h.OffsetLayout=zt;var ye=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return V(e).readUIntLE(t,this.span)}encode(e,t,n=0){return V(t).writeUIntLE(e,n,this.span),this.span}};h.UInt=ye;var Ae=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return V(e).readUIntBE(t,this.span)}encode(e,t,n=0){return V(t).writeUIntBE(e,n,this.span),this.span}};h.UIntBE=Ae;var qe=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return V(e).readIntLE(t,this.span)}encode(e,t,n=0){return V(t).writeIntLE(e,n,this.span),this.span}};h.Int=qe;var Ze=class extends H{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return V(e).readIntBE(t,this.span)}encode(e,t,n=0){return V(t).writeIntBE(e,n,this.span),this.span}};h.IntBE=Ze;var Dr=Math.pow(2,32);function Kn(s){let e=Math.floor(s/Dr),t=s-e*Dr;return{hi32:e,lo32:t}}function $n(s,e){return s*Dr+e}var Nn=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=V(e),r=n.readUInt32LE(t),o=n.readUInt32LE(t+4);return $n(o,r)}encode(e,t,n=0){let r=Kn(e),o=V(t);return o.writeUInt32LE(r.lo32,n),o.writeUInt32LE(r.hi32,n+4),8}};h.NearUInt64=Nn;var Cn=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=V(e),r=n.readUInt32BE(t),o=n.readUInt32BE(t+4);return $n(r,o)}encode(e,t,n=0){let r=Kn(e),o=V(t);return o.writeUInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}};h.NearUInt64BE=Cn;var On=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=V(e),r=n.readUInt32LE(t),o=n.readInt32LE(t+4);return $n(o,r)}encode(e,t,n=0){let r=Kn(e),o=V(t);return o.writeUInt32LE(r.lo32,n),o.writeInt32LE(r.hi32,n+4),8}};h.NearInt64=On;var Tn=class extends H{constructor(e){super(8,e)}decode(e,t=0){let n=V(e),r=n.readInt32BE(t),o=n.readUInt32BE(t+4);return $n(r,o)}encode(e,t,n=0){let r=Kn(e),o=V(t);return o.writeInt32BE(r.hi32,n),o.writeUInt32BE(r.lo32,n+4),8}};h.NearInt64BE=Tn;var kn=class extends H{constructor(e){super(4,e)}decode(e,t=0){return V(e).readFloatLE(t)}encode(e,t,n=0){return V(t).writeFloatLE(e,n),4}};h.Float=kn;var vn=class extends H{constructor(e){super(4,e)}decode(e,t=0){return V(e).readFloatBE(t)}encode(e,t,n=0){return V(t).writeFloatBE(e,n),4}};h.FloatBE=vn;var Ln=class extends H{constructor(e){super(8,e)}decode(e,t=0){return V(e).readDoubleLE(t)}encode(e,t,n=0){return V(t).writeDoubleLE(e,n),8}};h.Double=Ln;var Pn=class extends H{constructor(e){super(8,e)}decode(e,t=0){return V(e).readDoubleBE(t)}encode(e,t,n=0){return V(t).writeDoubleBE(e,n),8}};h.DoubleBE=Pn;var Bn=class extends H{constructor(e,t,n){if(!(e instanceof H))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof he&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;!(t instanceof he)&&0<e.span&&(r=t*e.span),super(r,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,r=this.count;if(r instanceof he&&(r=r.decode(e,t)),0<this.elementLayout.span)n=r*this.elementLayout.span;else{let o=0;for(;o<r;)n+=this.elementLayout.getSpan(e,t+n),++o}return n}decode(e,t=0){let n=[],r=0,o=this.count;for(o instanceof he&&(o=o.decode(e,t));r<o;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return n}encode(e,t,n=0){let r=this.elementLayout,o=e.reduce((i,a)=>i+r.encode(a,t,n+i),0);return this.count instanceof he&&this.count.encode(e.length,t,n),o}};h.Sequence=Bn;var xn=class extends H{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((o,i)=>o&&i instanceof H,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(let o of e)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce((o,i)=>o+i.getSpan(),0)}catch{}super(r,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((r,o)=>{let i=o.getSpan(e,t);return t+=i,r+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){It(e);let n=this.makeDestinationObject();for(let r of this.fields)if(r.property!==void 0&&(n[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){let r=n,o=0,i=0;for(let a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){let f=e[a.property];f!==void 0&&(i=a.encode(f,t,n),0>c&&(c=a.getSpan(t,n)))}o=n,n+=c}return o+i-r}fromArray(e){let t=this.makeDestinationObject();for(let n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(let n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}};h.Structure=xn;var Ft=class{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}};h.UnionDiscriminator=Ft;var bt=class extends Ft{constructor(e,t){if(!(e instanceof he&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}};h.UnionLayoutDiscriminator=bt;var Wt=class extends H{constructor(e,t,n){let r;if(e instanceof ye||e instanceof Ae)r=new bt(new zt(e));else if(e instanceof he&&e.isCount())r=new bt(e);else if(e instanceof Ft)r=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof H))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let o=-1;t&&(o=t.span,0<=o&&(e instanceof ye||e instanceof Ae)&&(o+=r.layout.span)),super(o,n),this.discriminator=r,this.usesPrefixDiscriminator=e instanceof ye||e instanceof Ae,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;let n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;let t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(let t in this.registry){let n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n,r=this.discriminator,o=r.decode(e,t),i=this.registry[o];if(i===void 0){let a=this.defaultLayout,c=0;this.usesPrefixDiscriminator&&(c=r.layout.span),n=this.makeDestinationObject(),n[r.property]=o,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){let r=this.getSourceVariant(e);if(r===void 0){let o=this.discriminator,i=this.defaultLayout,a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(e[o.property],t,n),a+i.encode(e[i.property],t,n+a)}return r.encode(e,t,n)}addVariant(e,t,n){let r=new Un(this,e,t,n);return this.registry[e]=r,r}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}};h.Union=Wt;var Un=class extends H{constructor(e,t,n,r){if(!(e instanceof Wt))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&r===void 0&&(r=n,n=null),n){if(!(n instanceof H))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof r!="string")throw new TypeError("variant must have a String property")}let o=e.span;0>e.span&&(o=n?n.span:0,0<=o&&e.usesPrefixDiscriminator&&(o+=e.discriminator.layout.span)),super(o,r),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let r=0;return this.layout&&(r=this.layout.getSpan(e,t+n)),n+r}decode(e,t=0){let n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let o=r;if(this.layout&&(this.layout.encode(e[this.property],t,n+r),o+=this.layout.getSpan(t,n+r),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(e){if(this.layout)return this.layout.fromArray(e)}};h.VariantLayout=Un;function St(s){return 0>s&&(s+=4294967296),s}var Kt=class extends H{constructor(e,t,n){if(!(e instanceof ye||e instanceof Ae))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(o){return r=St(o),this},this._packedGetValue=function(){return r}}decode(e,t=0){let n=this.makeDestinationObject(),r=this.word.decode(e,t);this._packedSetValue(r);for(let o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(e));return n}encode(e,t,n=0){let r=this.word.decode(t,n);this._packedSetValue(r);for(let o of this.fields)if(o.property!==void 0){let i=e[o.property];i!==void 0&&o.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){let n=new $t(this,e,t);return this.fields.push(n),n}addBoolean(e){let t=new Dn(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}};h.BitStructure=Kt;var $t=class{constructor(e,t,n){if(!(e instanceof Kt))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");let r=8*e.span,o=e.fields.reduce((i,a)=>i+a.bits,0);if(t+o>r)throw new Error("bits too long for span remainder ("+(r-o)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=r-o-t),this.wordMask=St(this.valueMask<<this.start),this.property=n}decode(e,t){let n=this.container._packedGetValue();return St(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==St(e&this.valueMask))throw new TypeError(zr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let t=this.container._packedGetValue(),n=St(e<<this.start);this.container._packedSetValue(St(t&~this.wordMask)|n)}};h.BitField=$t;var Dn=class extends $t{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};h.Boolean=Dn;var Mn=class extends H{constructor(e,t){if(!(e instanceof he&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof he||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),V(e).slice(t,t+n)}encode(e,t,n){let r=this.length;if(this.length instanceof he&&(r=e.length),!(e instanceof Uint8Array&&r===e.length))throw new TypeError(zr("Blob.encode",this)+" requires (length "+r+") Uint8Array as src");if(n+r>t.length)throw new RangeError("encoding overruns Uint8Array");let o=V(e);return V(t).write(o.toString("hex"),n,r,"hex"),this.length instanceof he&&this.length.encode(r,t,n),r}};h.Blob=Mn;var zn=class extends H{constructor(e){super(-1,e)}getSpan(e,t=0){It(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){let n=this.getSpan(e,t);return V(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let r=Mr.Buffer.from(e,"utf8"),o=r.length;if(n+o>t.length)throw new RangeError("encoding overruns Buffer");let i=V(t);return r.copy(i,n),i[n+o]=0,o+1}};h.CString=zn;var Fn=class extends H{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return It(e),e.length-t}decode(e,t=0){let n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return V(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));let r=Mr.Buffer.from(e,"utf8"),o=r.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>t.length)throw new RangeError("encoding overruns Buffer");return r.copy(V(t),n),o}};h.UTF8=Fn;var Wn=class extends H{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}};h.Constant=Wn;h.greedy=(s,e)=>new In(s,e);h.offset=(s,e,t)=>new zt(s,e,t);h.u8=s=>new ye(1,s);h.u16=s=>new ye(2,s);h.u24=s=>new ye(3,s);h.u32=s=>new ye(4,s);h.u40=s=>new ye(5,s);h.u48=s=>new ye(6,s);h.nu64=s=>new Nn(s);h.u16be=s=>new Ae(2,s);h.u24be=s=>new Ae(3,s);h.u32be=s=>new Ae(4,s);h.u40be=s=>new Ae(5,s);h.u48be=s=>new Ae(6,s);h.nu64be=s=>new Cn(s);h.s8=s=>new qe(1,s);h.s16=s=>new qe(2,s);h.s24=s=>new qe(3,s);h.s32=s=>new qe(4,s);h.s40=s=>new qe(5,s);h.s48=s=>new qe(6,s);h.ns64=s=>new On(s);h.s16be=s=>new Ze(2,s);h.s24be=s=>new Ze(3,s);h.s32be=s=>new Ze(4,s);h.s40be=s=>new Ze(5,s);h.s48be=s=>new Ze(6,s);h.ns64be=s=>new Tn(s);h.f32=s=>new kn(s);h.f32be=s=>new vn(s);h.f64=s=>new Ln(s);h.f64be=s=>new Pn(s);h.struct=(s,e,t)=>new xn(s,e,t);h.bits=(s,e,t)=>new Kt(s,e,t);h.seq=(s,e,t)=>new Bn(s,e,t);h.union=(s,e,t)=>new Wt(s,e,t);h.unionLayoutDiscriminator=(s,e)=>new bt(s,e);h.blob=(s,e)=>new Mn(s,e);h.cstr=s=>new zn(s);h.utf8=(s,e)=>new Fn(s,e);h.constant=(s,e)=>new Wn(s,e)});var Ho=$e((Fp,Vo)=>{"use strict";var Hl=(Zs(),ks(Js)).v4,ql=function(s,e,t,n){if(typeof s!="string")throw new TypeError(s+" must be a string");n=n||{};let r=typeof n.version=="number"?n.version:2;if(r!==1&&r!==2)throw new TypeError(r+" must be 1 or 2");let o={method:s};if(r===2&&(o.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");o.params=e}if(typeof t>"u"){let i=typeof n.generator=="function"?n.generator:function(){return Hl()};o.id=i(o,n)}else r===2&&t===null?n.notificationIdNull&&(o.id=null):o.id=t;return o};Vo.exports=ql});var Go=$e((Wp,qo)=>{"use strict";var Gl=(Zs(),ks(Js)).v4,jl=Ho(),qt=function(s,e){if(!(this instanceof qt))return new qt(s,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Gl()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=s};qo.exports=qt;qt.prototype.request=function(s,e,t,n){let r=this,o=null,i=Array.isArray(s)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&s&&typeof s=="object"&&typeof e=="function")n=e,o=s;else{typeof t=="function"&&(n=t,t=void 0);let f=typeof n=="function";try{o=jl(s,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(d){if(f)return n(d);throw d}if(!f)return o}let c;try{c=JSON.stringify(o,this.options.replacer)}catch(f){return n(f)}return this.callServer(c,function(f,d){r._parseResponse(f,d,n)}),o};qt.prototype._parseResponse=function(s,e,t){if(s){t(s);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(r){return t(r)}if(t.length===3)if(Array.isArray(n)){let r=function(i){return typeof i.error<"u"},o=function(i){return!r(i)};return t(null,n.filter(r),n.filter(o))}else return t(null,n.error,n.result);t(null,n)}});var Pe=Ue(vs(),1);var Mt=Ls({connection:null}),at={state:Mt,subscribeKey(s,e){return xs(Mt,s,e)},subscribe(s){return Ps(Mt,()=>s(Mt))},setConnection(s){Mt.connection=Bs(s)}};var P=Ue(Or());var Me=BigInt(0),ge=BigInt(1),io=BigInt(2),na=BigInt(8),ra={zip215:!0};function sa(s){let e=$s(s);return zs(s,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function ao(s){let e=sa(s),{Fp:t,n,prehash:r,hash:o,randomBytes:i,nByteLength:a,h:c}=e,f=io<<BigInt(a*8)-ge,d=t.create,m=pn(e.n,e.nBitLength);function I(B,E){let k=t.sqr(B),L=t.sqr(E),z=t.add(t.mul(e.a,k),L),$=t.add(t.ONE,t.mul(e.d,t.mul(k,L)));return t.eql(z,$)}if(!I(e.Gx,e.Gy))throw new Error("bad curve params: generator point");let p=e.uvRatio||((B,E)=>{try{return{isValid:!0,value:t.sqrt(B*t.inv(E))}}catch{return{isValid:!1,value:Me}}}),y=e.adjustScalarBytes||(B=>B),g=e.domain||((B,E,k)=>{if(fn("phflag",k),E.length||k)throw new Error("Contexts/pre-hash are not supported");return B});function A(B,E,k=!1){let L=k?ge:Me;Et("coordinate "+B,E,L,f)}function C(B){if(!(B instanceof O))throw new Error("ExtendedPoint expected")}let x=br((B,E)=>{let{ex:k,ey:L,ez:z}=B,$=B.is0();E==null&&(E=$?na:t.inv(z));let ee=d(k*E),ie=d(L*E),J=d(z*E);if($)return{x:Me,y:ge};if(J!==ge)throw new Error("invZ was invalid");return{x:ee,y:ie}}),Q=br(B=>{let{a:E,d:k}=e;if(B.is0())throw new Error("bad point: ZERO");let{ex:L,ey:z,ez:$,et:ee}=B,ie=d(L*L),J=d(z*z),oe=d($*$),fe=d(oe*oe),me=d(ie*E),Be=d(oe*d(me+J)),xe=d(fe+d(k*d(ie*J)));if(Be!==xe)throw new Error("bad point: equation left != right (1)");let be=d(L*z),Xe=d($*ee);if(be!==Xe)throw new Error("bad point: equation left != right (2)");return!0});class O{constructor(E,k,L,z){A("x",E),A("y",k),A("z",L,!0),A("t",z),this.ex=E,this.ey=k,this.ez=L,this.et=z,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(E){if(E instanceof O)throw new Error("extended point not allowed");let{x:k,y:L}=E||{};return A("x",k),A("y",L),new O(k,L,ge,d(k*L))}static normalizeZ(E){let k=Ir(t,E.map(L=>L.ez));return E.map((L,z)=>L.toAffine(k[z])).map(O.fromAffine)}static msm(E,k){return Ks(O,m,E,k)}_setWindowSize(E){K.setWindowSize(this,E)}assertValidity(){Q(this)}equals(E){C(E);let{ex:k,ey:L,ez:z}=this,{ex:$,ey:ee,ez:ie}=E,J=d(k*ie),oe=d($*z),fe=d(L*ie),me=d(ee*z);return J===oe&&fe===me}is0(){return this.equals(O.ZERO)}negate(){return new O(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){let{a:E}=e,{ex:k,ey:L,ez:z}=this,$=d(k*k),ee=d(L*L),ie=d(io*d(z*z)),J=d(E*$),oe=k+L,fe=d(d(oe*oe)-$-ee),me=J+ee,Be=me-ie,xe=J-ee,be=d(fe*Be),Xe=d(me*xe),it=d(fe*xe),ln=d(Be*me);return new O(be,Xe,ln,it)}add(E){C(E);let{a:k,d:L}=e,{ex:z,ey:$,ez:ee,et:ie}=this,{ex:J,ey:oe,ez:fe,et:me}=E,Be=d(z*J),xe=d($*oe),be=d(ie*L*me),Xe=d(ee*fe),it=d((z+$)*(J+oe)-Be-xe),ln=Xe-be,Os=Xe+be,Ts=d(xe-k*Be),Zi=d(it*ln),Qi=d(Os*Ts),ea=d(it*Ts),ta=d(ln*Os);return new O(Zi,Qi,ta,ea)}subtract(E){return this.add(E.negate())}wNAF(E){return K.wNAFCached(this,E,O.normalizeZ)}multiply(E){let k=E;Et("scalar",k,ge,n);let{p:L,f:z}=this.wNAF(k);return O.normalizeZ([L,z])[0]}multiplyUnsafe(E,k=O.ZERO){let L=E;return Et("scalar",L,Me,n),L===Me?re:this.is0()||L===ge?this:K.wNAFCachedUnsafe(this,L,O.normalizeZ,k)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return K.unsafeLadder(this,n).is0()}toAffine(E){return x(this,E)}clearCofactor(){let{h:E}=e;return E===ge?this:this.multiplyUnsafe(E)}static fromHex(E,k=!1){let{d:L,a:z}=e,$=t.BYTES;E=De("pointHex",E,$),fn("zip215",k);let ee=E.slice(),ie=E[$-1];ee[$-1]=ie&-129;let J=hn(ee),oe=k?f:t.ORDER;Et("pointHex.y",J,Me,oe);let fe=d(J*J),me=d(fe-ge),Be=d(L*fe-z),{isValid:xe,value:be}=p(me,Be);if(!xe)throw new Error("Point.fromHex: invalid y coordinate");let Xe=(be&ge)===ge,it=(ie&128)!==0;if(!k&&be===Me&&it)throw new Error("Point.fromHex: x=0 and x_0=1");return it!==Xe&&(be=d(-be)),O.fromAffine({x:be,y:J})}static fromPrivateKey(E){let{scalar:k}=Cs(E);return ne.multiply(k)}toRawBytes(){let{x:E,y:k}=this.toAffine(),L=wr(k,t.BYTES);return L[L.length-1]|=E&ge?128:0,L}toHex(){return Ms(this.toRawBytes())}}O.BASE=new O(e.Gx,e.Gy,ge,d(e.Gx*e.Gy)),O.ZERO=new O(Me,ge,ge,Me);let{BASE:ne,ZERO:re}=O,K=Ws(O,a*8);function le(B){return Oe(B,n)}function Rt(B){return le(hn(B))}function Cs(B){let E=t.BYTES;B=De("private key",B,E);let k=De("hashed private key",o(B),2*E),L=y(k.slice(0,E)),z=k.slice(E,2*E),$=Rt(L);return{head:L,prefix:z,scalar:$}}function Ar(B){let{head:E,prefix:k,scalar:L}=Cs(B),z=ne.multiply(L),$=z.toRawBytes();return{head:E,prefix:k,scalar:L,point:z,pointBytes:$}}function ji(B){return Ar(B).pointBytes}function Rr(B=Uint8Array.of(),...E){let k=Sr(...E);return Rt(o(g(k,De("context",B),!!r)))}function Yi(B,E,k={}){B=De("message",B),r&&(B=r(B));let{prefix:L,scalar:z,pointBytes:$}=Ar(E),ee=Rr(k.context,L,B),ie=ne.multiply(ee).toRawBytes(),J=Rr(k.context,ie,$,B),oe=le(ee+J*z);Et("signature.s",oe,Me,n);let fe=Sr(ie,wr(oe,t.BYTES));return De("result",fe,t.BYTES*2)}let Xi=ra;function Ji(B,E,k,L=Xi){let{context:z,zip215:$}=L,ee=t.BYTES;B=De("signature",B,2*ee),E=De("message",E),k=De("publicKey",k,ee),$!==void 0&&fn("zip215",$),r&&(E=r(E));let ie=hn(B.slice(ee,2*ee)),J,oe,fe;try{J=O.fromHex(k,$),oe=O.fromHex(B.slice(0,ee),$),fe=ne.multiplyUnsafe(ie)}catch{return!1}if(!$&&J.isSmallOrder())return!1;let me=Rr(z,oe.toRawBytes(),J.toRawBytes(),E);return oe.add(J.multiplyUnsafe(me)).subtract(fe).clearCofactor().equals(O.ZERO)}return ne._setWindowSize(8),{CURVE:e,getPublicKey:ji,sign:Yi,verify:Ji,ExtendedPoint:O,utils:{getExtendedPublicKey:Ar,randomPrivateKey:()=>i(t.BYTES),precompute(B=8,E=O.BASE){return E._setWindowSize(B),E.multiply(BigInt(3)),E}}}}var vr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),co=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),Ep=BigInt(0),oa=BigInt(1),uo=BigInt(2),wp=BigInt(3),ia=BigInt(5),aa=BigInt(8);function ca(s){let e=BigInt(10),t=BigInt(20),n=BigInt(40),r=BigInt(80),o=vr,a=s*s%o*s%o,c=Te(a,uo,o)*a%o,f=Te(c,oa,o)*s%o,d=Te(f,ia,o)*f%o,m=Te(d,e,o)*d%o,I=Te(m,t,o)*m%o,p=Te(I,n,o)*I%o,y=Te(p,r,o)*p%o,g=Te(y,r,o)*p%o,A=Te(g,e,o)*d%o;return{pow_p_5_8:Te(A,uo,o)*s%o,b2:a}}function ua(s){return s[0]&=248,s[31]&=127,s[31]|=64,s}function da(s,e){let t=vr,n=Oe(e*e*e,t),r=Oe(n*n*e,t),o=ca(s*r).pow_p_5_8,i=Oe(s*n*o,t),a=Oe(e*i*i,t),c=i,f=Oe(i*co,t),d=a===s,m=a===Oe(-s,t),I=a===Oe(-s*co,t);return d&&(i=c),(m||I)&&(i=f),Fs(i,t)&&(i=Oe(-i,t)),{isValid:d||m,value:i}}var lo=pn(vr,void 0,!0),la={a:lo.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:lo,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:aa,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ds,randomBytes:Us,adjustScalarBytes:ua,uvRatio:da},ct=ao(la);var os=Ue(Ys()),ae=Ue(go());var Lt=Ue(Io()),u=Ue(Fr()),gi=Ue(Fr());var Ba=1,xa=2,Ua=3,Da=4,Ma=5,za=6,Fa=7,Wa=8,Ka=9,$a=10,Va=-32700,Ha=-32603,qa=-32602,Ga=-32601,ja=-32600,Ya=-32016,Xa=-32015,Ja=-32014,Za=-32013,Qa=-32012,ec=-32011,tc=-32010,nc=-32009,rc=-32008,sc=-32007,oc=-32006,ic=-32005,ac=-32004,cc=-32003,uc=-32002,dc=-32001,lc=28e5,fc=2800001,hc=2800002,pc=2800003,gc=2800004,_c=2800005,yc=2800006,mc=2800007,Ac=2800008,Rc=2800009,Ec=2800010,wc=323e4,Sc=32300001,bc=3230002,Ic=3230003,Nc=3230004,Cc=361e4,Oc=3610001,Tc=3610002,kc=3610003,vc=3610004,Lc=3610005,Pc=3610006,Bc=3610007,xc=3611e3,Uc=3704e3,Dc=3704001,Mc=3704002,zc=3704003,Fc=3704004,Wc=4128e3,Kc=4128001,$c=4128002,Vc=4615e3,Hc=4615001,qc=4615002,Gc=4615003,jc=4615004,Yc=4615005,Xc=4615006,Jc=4615007,Zc=4615008,Qc=4615009,eu=4615010,tu=4615011,nu=4615012,ru=4615013,su=4615014,ou=4615015,iu=4615016,au=4615017,cu=4615018,uu=4615019,du=4615020,lu=4615021,fu=4615022,hu=4615023,pu=4615024,gu=4615025,_u=4615026,yu=4615027,mu=4615028,Au=4615029,Ru=4615030,Eu=4615031,wu=4615032,Su=4615033,bu=4615034,Iu=4615035,Nu=4615036,Cu=4615037,Ou=4615038,Tu=4615039,ku=4615040,vu=4615041,Lu=4615042,Pu=4615043,Bu=4615044,xu=4615045,Uu=4615046,Du=4615047,Mu=4615048,zu=4615049,Fu=4615050,Wu=4615051,Ku=4615052,$u=4615053,Vu=4615054,Hu=5508e3,qu=5508001,Gu=5508002,ju=5508003,Yu=5508004,Xu=5508005,Ju=5508006,Zu=5508007,Qu=5508008,ed=5508009,td=5508010,nd=5508011,rd=5663e3,sd=5663001,od=5663002,id=5663003,ad=5663004,cd=5663005,ud=5663006,dd=5663007,ld=5663008,fd=5663009,hd=5663010,pd=5663011,gd=5663012,_d=5663013,yd=5663014,md=5663015,Ad=5663016,Rd=5663017,Ed=5663018,wd=5663019,Sd=705e4,bd=7050001,Id=7050002,Nd=7050003,Cd=7050004,Od=7050005,Td=7050006,kd=7050007,vd=7050008,Ld=7050009,Pd=7050010,Bd=7050011,xd=7050012,Ud=7050013,Dd=7050014,Md=7050015,zd=7050016,Fd=7050017,Wd=7050018,Kd=7050019,$d=7050020,Vd=7050021,Hd=7050022,qd=7050023,Gd=7050024,jd=7050025,Yd=7050026,Xd=7050027,Jd=7050028,Zd=7050029,Qd=7050030,el=7050031,tl=7050032,nl=7050033,rl=7050034,sl=7050035,ol=7050036,Wr=8078e3,Kr=8078001,No=8078002,Co=8078003,$r=8078004,Vr=8078005,Hr=8078006,il=8078007,al=8078008,cl=8078009,ul=8078010,qr=8078011,dl=8078012,Oo=8078013,To=8078014,ll=8078015,fl=8078016,hl=8078017,pl=8078018,gl=8078019,ko=8078020,vo=8078021,_l=8078022,yl=81e5,ml=8100001,Al=8100002,Rl=8100003,El=819e4,wl=8190001,Sl=8190002,bl=8190003,Il=8190004,Nl=99e5,Cl=9900001,Ol=9900002,Tl=9900003,kl=9900004;function Lo(s){return Array.isArray(s)?"%5B"+s.map(Lo).join("%2C%20")+"%5D":typeof s=="bigint"?`${s}n`:encodeURIComponent(String(s!=null&&Object.getPrototypeOf(s)===null?{...s}:s))}function vl([s,e]){return`${s}=${Lo(e)}`}function Ll(s){let e=Object.entries(s).map(vl).join("&");return btoa(e)}var vp={[wc]:"Account not found at address: $address",[Nc]:"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",[Ic]:"Expected decoded account at address: $address",[bc]:"Failed to decode account data at address: $address",[Sc]:"Accounts not found at addresses: $addresses",[Rc]:"Unable to find a viable program address bump seed.",[hc]:"$putativeAddress is not a base58-encoded address.",[lc]:"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",[pc]:"The `CryptoKey` must be an `Ed25519` public key.",[Ac]:"Invalid seeds; point must fall off the Ed25519 curve.",[gc]:"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",[yc]:"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",[mc]:"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",[_c]:"Expected program derived address bump to be in the range [0, 255], got: $bump.",[Ec]:"Program address cannot end with PDA marker.",[fc]:"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",[Da]:"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",[Ba]:"The network has progressed past the last block for which this transaction could have been committed.",[Wr]:"Codec [$codecDescription] cannot decode empty byte arrays.",[_l]:"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",[ko]:"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",[Vr]:"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",[Hr]:"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",[$r]:"Encoder and decoder must either both be fixed-size or variable-size.",[al]:"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",[No]:"Expected a fixed-size codec, got a variable-size one.",[Oo]:"Codec [$codecDescription] expected a positive byte length, got $bytesLength.",[Co]:"Expected a variable-size codec, got a fixed-size one.",[gl]:"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",[Kr]:"Codec [$codecDescription] expected $expected bytes, got $bytesLength.",[pl]:"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",[cl]:"Invalid discriminated union variant. Expected one of [$variants], got $value.",[ul]:"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",[ll]:"Invalid literal union variant. Expected one of [$variants], got $value.",[il]:"Expected [$codecDescription] to have $expected items, got $actual.",[dl]:"Invalid value $value for base $base with alphabet $alphabet.",[fl]:"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",[qr]:"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",[To]:"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",[vo]:"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",[hl]:"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",[xc]:"No random values implementation could be found.",[Qc]:"instruction requires an uninitialized account",[hu]:"instruction tries to borrow reference for an account which is already borrowed",[pu]:"instruction left account with an outstanding borrowed reference",[lu]:"program other than the account's owner changed the size of the account data",[Yc]:"account data too small for instruction",[fu]:"instruction expected an executable account",[Uu]:"An account does not have enough lamports to be rent-exempt",[Mu]:"Program arithmetic overflowed",[xu]:"Failed to serialize or deserialize account data: $encodedData",[Vu]:"Builtin programs must consume compute units",[wu]:"Cross-program invocation call depth too deep",[Ou]:"Computational budget exceeded",[_u]:"custom program error: #$code",[au]:"instruction contains duplicate accounts",[gu]:"instruction modifications of multiply-passed account differ",[Ru]:"executable accounts must be rent exempt",[mu]:"instruction changed executable accounts data",[Au]:"instruction changed the balance of an executable account",[cu]:"instruction changed executable bit of an account",[su]:"instruction modified data of an account it does not own",[ru]:"instruction spent from the balance of an account it does not own",[Hc]:"generic instruction error",[Fu]:"Provided owner is not allowed",[Pu]:"Account is immutable",[Bu]:"Incorrect authority provided",[Jc]:"incorrect program id for instruction",[Xc]:"insufficient funds for instruction",[jc]:"invalid account data for instruction",[Du]:"Invalid account owner",[qc]:"invalid program argument",[yu]:"program returned invalid error code",[Gc]:"invalid instruction data",[Cu]:"Failed to reallocate account data",[Nu]:"Provided seeds do not result in a valid address",[Wu]:"Accounts data allocations exceeded the maximum allowed per transaction",[Ku]:"Max accounts exceeded",[$u]:"Max instruction trace length exceeded",[Iu]:"Length of the seed is too long for address generation",[Su]:"An account required by the instruction is missing",[Zc]:"missing required signature for instruction",[nu]:"instruction illegally modified the program id of an account",[du]:"insufficient account keys for instruction",[Tu]:"Cross-program invocation with unauthorized signer or writable account",[ku]:"Failed to create program execution environment",[Lu]:"Program failed to compile",[vu]:"Program failed to complete",[iu]:"instruction modified data of a read-only account",[ou]:"instruction changed the balance of a read-only account",[bu]:"Cross-program invocation reentrancy not allowed for this instruction",[uu]:"instruction modified rent epoch of an account",[tu]:"sum of account balances before and after instruction do not match",[eu]:"instruction requires an initialized account",[Vc]:"",[Eu]:"Unsupported program id",[zu]:"Unsupported sysvar",[Wc]:"The instruction does not have any accounts.",[Kc]:"The instruction does not have any data.",[$c]:"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",[Ma]:"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",[xa]:"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",[Ol]:"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[kl]:"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",[Cl]:"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Nl]:"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Tl]:"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Ha]:"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",[qa]:"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",[ja]:"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",[Ga]:"JSON-RPC error: The method does not exist / is not available ($__serverMessage)",[Va]:"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",[Qa]:"$__serverMessage",[dc]:"$__serverMessage",[ac]:"$__serverMessage",[Ja]:"$__serverMessage",[tc]:"$__serverMessage",[nc]:"$__serverMessage",[Ya]:"Minimum context slot has not been reached",[ic]:"Node is unhealthy; behind by $numSlotsBehind slots",[rc]:"No snapshot",[uc]:"Transaction simulation failed",[sc]:"$__serverMessage",[ec]:"Transaction history is not available from this node",[oc]:"$__serverMessage",[Za]:"Transaction signature length mismatch",[cc]:"Transaction signature verification failure",[Xa]:"$__serverMessage",[Uc]:"Key pair bytes must be of length 64, got $byteLength.",[Dc]:"Expected private key bytes with length 32. Actual length: $actualLength.",[Mc]:"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",[Fc]:"The provided private key does not match the provided public key.",[zc]:"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",[za]:"Lamports value must be in the range [0, 2e64-1]",[Fa]:"`$value` cannot be parsed as a `BigInt`",[$a]:"$message",[Wa]:"`$value` cannot be parsed as a `Number`",[Ua]:"No nonce account could be found at address `$nonceAccountAddress`",[El]:"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",[Sl]:"WebSocket was closed before payload could be added to the send buffer",[bl]:"WebSocket connection closed",[Il]:"WebSocket failed to connect",[wl]:"Failed to obtain a subscription id from the server",[Rl]:"Could not find an API plan for RPC method: `$method`",[yl]:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",[Al]:"HTTP error ($statusCode): $message",[ml]:"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",[Hu]:"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",[qu]:"The provided value does not implement the `KeyPairSigner` interface",[ju]:"The provided value does not implement the `MessageModifyingSigner` interface",[Yu]:"The provided value does not implement the `MessagePartialSigner` interface",[Gu]:"The provided value does not implement any of the `MessageSigner` interfaces",[Ju]:"The provided value does not implement the `TransactionModifyingSigner` interface",[Zu]:"The provided value does not implement the `TransactionPartialSigner` interface",[Qu]:"The provided value does not implement the `TransactionSendingSigner` interface",[Xu]:"The provided value does not implement any of the `TransactionSigner` interfaces",[ed]:"More than one `TransactionSendingSigner` was identified.",[td]:"No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",[nd]:"Wallet account signers do not support signing multiple messages/transactions in a single operation",[Bc]:"Cannot export a non-extractable key.",[Oc]:"No digest implementation could be found.",[Cc]:"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",[Tc]:`This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,[kc]:"No signature verification implementation could be found.",[vc]:"No key generation implementation could be found.",[Lc]:"No signing implementation could be found.",[Pc]:"No key export implementation could be found.",[Ka]:"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",[zd]:"Transaction processing left an account with an outstanding borrowed reference",[bd]:"Account in use",[Id]:"Account loaded twice",[Nd]:"Attempt to debit an account but found no record of a prior credit.",[qd]:"Transaction loads an address table account that doesn't exist",[kd]:"This transaction has already been processed",[vd]:"Blockhash not found",[Ld]:"Loader call chain is too deep",[Md]:"Transactions are currently disabled due to cluster maintenance",[Qd]:"Transaction contains a duplicate instruction ($index) that is not allowed",[Od]:"Insufficient funds for fee",[el]:"Transaction results in an account ($accountIndex) with insufficient funds for rent",[Td]:"This account may not be used to pay transaction fees",[Bd]:"Transaction contains an invalid account reference",[jd]:"Transaction loads an address table account with invalid data",[Yd]:"Transaction address table lookup uses an invalid index",[Gd]:"Transaction loads an address table account with an invalid owner",[nl]:"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",[Ud]:"This program may not be used for executing instructions",[Xd]:"Transaction leaves an account with a lower balance than rent-exempt minimum",[Kd]:"Transaction loads a writable account that cannot be written",[tl]:"Transaction exceeded max loaded accounts data size cap",[Pd]:"Transaction requires a fee but has no signature present",[Cd]:"Attempt to load a program that does not exist",[sl]:"Execution of the program referenced by account at index $accountIndex is temporarily restricted.",[rl]:"ResanitizationNeeded",[Dd]:"Transaction failed to sanitize accounts offsets correctly",[xd]:"Transaction did not pass signature verification",[Hd]:"Transaction locked too many accounts",[ol]:"Sum of account balances before and after transaction do not match",[Sd]:"The transaction failed with the error `$errorName`",[Wd]:"Transaction version is unsupported",[Vd]:"Transaction would exceed account data limit within the block",[Zd]:"Transaction would exceed total account data limit",[$d]:"Transaction would exceed max account limit within the block",[Fd]:"Transaction would exceed max Block Cost Limit",[Jd]:"Transaction would exceed max Vote Cost Limit",[md]:"Attempted to sign a transaction with an address that is not a signer for it",[hd]:"Transaction is missing an address at index: $index.",[Ad]:"Transaction has no expected signers therefore it cannot be encoded",[od]:"Transaction does not have a blockhash lifetime",[id]:"Transaction is not a durable nonce transaction",[cd]:"Contents of these address lookup tables unknown: $lookupTableAddresses",[ud]:"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",[ld]:"No fee payer set in CompiledTransaction",[dd]:"Could not find program address at index $index",[Ed]:"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",[wd]:"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",[pd]:"Transaction is missing a fee payer.",[gd]:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",[yd]:"Transaction first instruction is not advance nonce account instruction.",[_d]:"Transaction with no instructions cannot be durable nonce transaction.",[rd]:"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",[sd]:"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",[Rd]:"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",[fd]:"Transaction is missing signatures for addresses: $addresses.",[ad]:"Transaction version must be in the range [0, 127]. `$actualVersion` given"};function Pl(s,e={}){{let t=`Solana error #${s}; Decode this error by running \`npx @solana/errors decode -- ${s}`;return Object.keys(e).length&&(t+=` '${Ll(e)}'`),`${t}\``}}var Qe=class extends Error{cause=this.cause;context;constructor(...[s,e]){let t,n;if(e){let{cause:o,...i}=e;o&&(n={cause:o}),Object.keys(i).length>0&&(t=i)}let r=Pl(s,t);super(r,n),this.context={__code:s,...t},this.name="SolanaError"}};function Bl(s,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(s)}function Po(s){return Object.freeze({...s,encode:e=>{let t=new Uint8Array(Bl(e,s));return s.write(e,t,0),t}})}function Bo(s){return Object.freeze({...s,decode:(e,t=0)=>s.read(e,t)[0]})}function Nt(s){return"fixedSize"in s&&typeof s.fixedSize=="number"}function xo(s,e){if(Nt(s)!==Nt(e))throw new Qe($r);if(Nt(s)&&Nt(e)&&s.fixedSize!==e.fixedSize)throw new Qe(Vr,{decoderFixedSize:e.fixedSize,encoderFixedSize:s.fixedSize});if(!Nt(s)&&!Nt(e)&&s.maxSize!==e.maxSize)throw new Qe(Hr,{decoderMaxSize:e.maxSize,encoderMaxSize:s.maxSize});return{...e,...s,decode:e.decode,encode:s.encode,read:e.read,write:s.write}}function Uo(s,e,t=0){if(e.length-t<=0)throw new Qe(Wr,{codecDescription:s})}function Do(s,e,t,n=0){let r=t.length-n;if(r<e)throw new Qe(Kr,{bytesLength:r,codecDescription:s,expected:e})}function xl(s,e,t,n){if(n<e||n>t)throw new Qe(qr,{codecDescription:s,max:t,min:e,value:n})}function Mo(s){return s?.endian!==1}function Ul(s){return Po({fixedSize:s.size,write(e,t,n){s.range&&xl(s.name,s.range[0],s.range[1],e);let r=new ArrayBuffer(s.size);return s.set(new DataView(r),e,Mo(s.config)),t.set(new Uint8Array(r),n),n+s.size}})}function Dl(s){return Bo({fixedSize:s.size,read(e,t=0){Uo(s.name,e,t),Do(s.name,s.size,e,t);let n=new DataView(Ml(e,t,s.size));return[s.get(n,Mo(s.config)),t+s.size]}})}function Ml(s,e,t){let n=s.byteOffset+(e??0),r=t??s.byteLength;return s.buffer.slice(n,n+r)}var Gr=(s={})=>Ul({config:s,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),zl=(s={})=>Dl({config:s,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),zo=(s={})=>xo(Gr(s),zl(s));var jr=class extends TypeError{constructor(e,t){let n,{message:r,explanation:o,...i}=e,{path:a}=e,c=a.length===0?r:`At path: ${a.join(".")} -- ${r}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}};function Fl(s){return Vt(s)&&typeof s[Symbol.iterator]=="function"}function Vt(s){return typeof s=="object"&&s!=null}function Vn(s){return Vt(s)&&!Array.isArray(s)}function ke(s){return typeof s=="symbol"?s.toString():typeof s=="string"?JSON.stringify(s):`${s}`}function Wl(s){let{done:e,value:t}=s.next();return e?void 0:t}function Kl(s,e,t,n){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});let{path:r,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${ke(n)}\``}=s;return{value:n,type:i,refinement:a,key:r[r.length-1],path:r,branch:o,...s,message:c}}function*Fo(s,e,t,n){Fl(s)||(s=[s]);for(let r of s){let o=Kl(r,e,t,n);o&&(yield o)}}function*Yr(s,e,t={}){let{path:n=[],branch:r=[s],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:r,mask:i};o&&(s=e.coercer(s,a));let c="valid";for(let f of e.validator(s,a))f.explanation=t.message,c="not_valid",yield[f,void 0];for(let[f,d,m]of e.entries(s,a)){let I=Yr(d,m,{path:f===void 0?n:[...n,f],branch:f===void 0?r:[...r,d],coerce:o,mask:i,message:t.message});for(let p of I)p[0]?(c=p[0].refinement!=null?"not_refined":"not_valid",yield[p[0],void 0]):o&&(d=p[1],f===void 0?s=d:s instanceof Map?s.set(f,d):s instanceof Set?s.add(d):Vt(s)&&(d!==void 0||f in s)&&(s[f]=d))}if(c!=="not_valid")for(let f of e.refiner(s,a))f.explanation=t.message,c="not_refined",yield[f,void 0];c==="valid"&&(yield[void 0,s])}var Ne=class{constructor(e){let{type:t,schema:n,validator:r,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,r?this.validator=(c,f)=>{let d=r(c,f);return Fo(d,f,this,c)}:this.validator=()=>[],o?this.refiner=(c,f)=>{let d=o(c,f);return Fo(d,f,this,c)}:this.refiner=()=>[]}assert(e,t){return Wo(e,this,t)}create(e,t){return w(e,this,t)}is(e){return Ko(e,this)}mask(e,t){return $l(e,this,t)}validate(e,t={}){return Ht(e,this,t)}};function Wo(s,e,t){let n=Ht(s,e,{message:t});if(n[0])throw n[0]}function w(s,e,t){let n=Ht(s,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function $l(s,e,t){let n=Ht(s,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Ko(s,e){return!Ht(s,e)[0]}function Ht(s,e,t={}){let n=Yr(s,e,t),r=Wl(n);return r[0]?[new jr(r[0],function*(){for(let i of n)i[0]&&(yield i[0])}),void 0]:[void 0,r[1]]}function lt(s,e){return new Ne({type:s,schema:null,validator:e})}function $o(){return lt("any",()=>!0)}function S(s){return new Ne({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(let[t,n]of e.entries())yield[t,n,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${ke(e)}`}})}function ve(){return lt("boolean",s=>typeof s=="boolean")}function Hn(s){return lt("instance",e=>e instanceof s||`Expected a \`${s.name}\` instance, but received: ${ke(e)}`)}function Z(s){let e=ke(s),t=typeof s;return new Ne({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?s:null,validator(n){return n===s||`Expected the literal \`${e}\`, but received: ${ke(n)}`}})}function Vl(){return lt("never",()=>!1)}function b(s){return new Ne({...s,validator:(e,t)=>e===null||s.validator(e,t),refiner:(e,t)=>e===null||s.refiner(e,t)})}function l(){return lt("number",s=>typeof s=="number"&&!isNaN(s)||`Expected a number, but received: ${ke(s)}`)}function v(s){return new Ne({...s,validator:(e,t)=>e===void 0||s.validator(e,t),refiner:(e,t)=>e===void 0||s.refiner(e,t)})}function Xr(s,e){return new Ne({type:"record",schema:null,*entries(t){if(Vt(t))for(let n in t){let r=t[n];yield[n,n,s],yield[n,r,e]}},validator(t){return Vn(t)||`Expected an object, but received: ${ke(t)}`},coercer(t){return Vn(t)?{...t}:t}})}function R(){return lt("string",s=>typeof s=="string"||`Expected a string, but received: ${ke(s)}`)}function qn(s){let e=Vl();return new Ne({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){let n=Math.max(s.length,t.length);for(let r=0;r<n;r++)yield[r,t[r],s[r]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${ke(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function _(s){let e=Object.keys(s);return new Ne({type:"type",schema:s,*entries(t){if(Vt(t))for(let n of e)yield[n,t[n],s[n]]},validator(t){return Vn(t)||`Expected an object, but received: ${ke(t)}`},coercer(t){return Vn(t)?{...t}:t}})}function pe(s){let e=s.map(t=>t.type).join(" | ");return new Ne({type:"union",schema:null,coercer(t,n){for(let r of s){let[o,i]=r.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){let r=[];for(let o of s){let[...i]=Yr(t,o,n),[a]=i;if(a[0])for(let[c]of i)c&&r.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${ke(t)}`,...r]}})}function ft(){return lt("unknown",()=>!0)}function Ct(s,e,t){return new Ne({...s,coercer:(n,r)=>Ko(n,e)?s.coercer(t(n,r),r):s.coercer(n,r)})}var _i=Ue(Go());var jo=Ue(Or(),1);var Yl=class extends kr.default{socket;constructor(s,e,t){super(),this.socket=new window.WebSocket(s,t),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=n=>this.emit("message",n.data),this.socket.onerror=n=>this.emit("error",n),this.socket.onclose=n=>{this.emit("close",n.code,n.reason)}}send(s,e,t){let n=t||e;try{this.socket.send(s),n()}catch(r){n(r)}}close(s,e){this.socket.close(s,e)}addEventListener(s,e,t){this.socket.addEventListener(s,e,t)}};function Yo(s,e){return new Yl(s,e)}var Xl=class{encode(s){return JSON.stringify(s)}decode(s){return JSON.parse(s)}},Xo=class extends kr.default{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(s,e="ws://localhost:8080",{autoconnect:t=!0,reconnect:n=!0,reconnect_interval:r=1e3,max_reconnects:o=5,...i}={},a,c){super(),this.webSocketFactory=s,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=t,this.ready=!1,this.reconnect=n,this.reconnect_timer_id=void 0,this.reconnect_interval=r,this.max_reconnects=o,this.rest_options=i,this.current_reconnects=0,this.generate_request_id=a||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),c?this.dataPack=c:this.dataPack=new Xl,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(s,e,t,n){return!n&&typeof t=="object"&&(n=t,t=null),new Promise((r,o)=>{if(!this.ready)return o(new Error("socket not ready"));let i=this.generate_request_id(s,e),a={jsonrpc:"2.0",method:s,params:e||void 0,id:i};this.socket.send(this.dataPack.encode(a),n,c=>{if(c)return o(c);this.queue[i]={promise:[r,o]},t&&(this.queue[i].timeout=setTimeout(()=>{delete this.queue[i],o(new Error("reply timeout"))},t))})})}async login(s){let e=await this.call("rpc.login",s);if(!e)throw new Error("authentication failed");return e}async listMethods(){return await this.call("__listMethods")}notify(s,e){return new Promise((t,n)=>{if(!this.ready)return n(new Error("socket not ready"));let r={jsonrpc:"2.0",method:s,params:e};this.socket.send(this.dataPack.encode(r),o=>{if(o)return n(o);t()})})}async subscribe(s){typeof s=="string"&&(s=[s]);let e=await this.call("rpc.on",s);if(typeof s=="string"&&e[s]!=="ok")throw new Error("Failed subscribing to an event '"+s+"' with: "+e[s]);return e}async unsubscribe(s){typeof s=="string"&&(s=[s]);let e=await this.call("rpc.off",s);if(typeof s=="string"&&e[s]!=="ok")throw new Error("Failed unsubscribing from an event with: "+e);return e}close(s,e){this.socket.close(s||1e3,e)}setAutoReconnect(s){this.reconnect=s}setReconnectInterval(s){this.reconnect_interval=s}setMaxReconnects(s){this.max_reconnects=s}_connect(s,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(s,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:t})=>{t instanceof ArrayBuffer&&(t=jo.Buffer.from(t).toString());try{t=this.dataPack.decode(t)}catch{return}if(t.notification&&this.listeners(t.notification).length){if(!Object.keys(t.params).length)return this.emit(t.notification);let n=[t.notification];if(t.params.constructor===Object)n.push(t.params);else for(let r=0;r<t.params.length;r++)n.push(t.params[r]);return Promise.resolve().then(()=>{this.emit.apply(this,n)})}if(!this.queue[t.id])return t.method?Promise.resolve().then(()=>{this.emit(t.method,t?.params)}):void 0;"error"in t=="result"in t&&this.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[t.id].timeout&&clearTimeout(this.queue[t.id].timeout),t.error?this.queue[t.id].promise[1](t.error):this.queue[t.id].promise[0](t.result),delete this.queue[t.id]}),this.socket.addEventListener("error",t=>this.emit("error",t)),this.socket.addEventListener("close",({code:t,reason:n})=>{this.ready&&setTimeout(()=>this.emit("close",t,n),0),this.ready=!1,this.socket=void 0,t!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(s,e),this.reconnect_interval)))})}};var eg=ct.utils.randomPrivateKey,Jo=()=>{let s=ct.utils.randomPrivateKey(),e=is(s),t=new Uint8Array(64);return t.set(s),t.set(e,32),{publicKey:e,secretKey:t}},is=ct.getPublicKey;function Zo(s){try{return ct.ExtendedPoint.fromHex(s),!0}catch{return!1}}var As=(s,e)=>ct.sign(s,e.slice(0,32)),Jl=ct.verify,F=s=>P.Buffer.isBuffer(s)?s:s instanceof Uint8Array?P.Buffer.from(s.buffer,s.byteOffset,s.byteLength):P.Buffer.from(s),as=class{constructor(e){Object.assign(this,e)}encode(){return P.Buffer.from((0,Lt.serialize)(Yn,this))}static decode(e){return(0,Lt.deserialize)(Yn,this,e)}static decodeUnchecked(e){return(0,Lt.deserializeUnchecked)(Yn,this,e)}};var Yn=new Map,yi,Zl=32,nt=32;function Ql(s){return s._bn!==void 0}var Qo=1,N=class s extends as{constructor(e){if(super({}),this._bn=void 0,Ql(e))this._bn=e._bn;else{if(typeof e=="string"){let t=ae.default.decode(e);if(t.length!=nt)throw new Error("Invalid public key input");this._bn=new os.default(t)}else this._bn=new os.default(e);if(this._bn.byteLength()>nt)throw new Error("Invalid public key input")}}static unique(){let e=new s(Qo);return Qo+=1,new s(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ae.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){let e=this._bn.toArrayLike(P.Buffer);if(e.length===nt)return e;let t=P.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){let r=P.Buffer.concat([e.toBuffer(),P.Buffer.from(t),n.toBuffer()]),o=Nr(r);return new s(o)}static createProgramAddressSync(e,t){let n=P.Buffer.alloc(0);e.forEach(function(o){if(o.length>Zl)throw new TypeError("Max seed length exceeded");n=P.Buffer.concat([n,F(o)])}),n=P.Buffer.concat([n,t.toBuffer(),P.Buffer.from("ProgramDerivedAddress")]);let r=Nr(n);if(Zo(r))throw new Error("Invalid seeds, address must fall off the curve");return new s(r)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,r;for(;n!=0;){try{let o=e.concat(P.Buffer.from([n]));r=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){let t=new s(e);return Zo(t.toBytes())}};yi=N;N.default=new yi("11111111111111111111111111111111");Yn.set(N,{kind:"struct",fields:[["_bn","u256"]]});var tg=new N("BPFLoader1111111111111111111111111111111111"),gt=1232,Rs=127,Xn=64,Jn=class extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}};Object.defineProperty(Jn.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});var Zn=class extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}};Object.defineProperty(Zn.prototype,"name",{value:"TransactionExpiredTimeoutError"});var pt=class extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}};Object.defineProperty(pt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});var Tt=class{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){let e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(let t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");let n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});let r=o=>{let i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:r(o.programId),accountKeyIndexes:o.keys.map(i=>r(i.pubkey)),data:o.data}))}},M=(s="publicKey")=>u.blob(32,s),ef=(s="signature")=>u.blob(64,s),Ot=(s="string")=>{let e=u.struct([u.u32("length"),u.u32("lengthPadding"),u.blob(u.offset(u.u32(),-8),"chars")],s),t=e.decode.bind(e),n=e.encode.bind(e),r=e;return r.decode=(o,i)=>t(o,i).chars.toString(),r.encode=(o,i,a)=>{let c={chars:P.Buffer.from(o,"utf8")};return n(c,i,a)},r.alloc=o=>u.u32().span+u.u32().span+P.Buffer.from(o,"utf8").length,r},tf=(s="authorized")=>u.struct([M("staker"),M("withdrawer")],s),nf=(s="lockup")=>u.struct([u.ns64("unixTimestamp"),u.ns64("epoch"),M("custodian")],s),rf=(s="voteInit")=>u.struct([M("nodePubkey"),M("authorizedVoter"),M("authorizedWithdrawer"),u.u8("commission")],s),sf=(s="voteAuthorizeWithSeedArgs")=>u.struct([u.u32("voteAuthorizationType"),M("currentAuthorityDerivedKeyOwnerPubkey"),Ot("currentAuthorityDerivedKeySeed"),M("newAuthorized")],s);function mi(s,e){let t=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){let o=e[r.property];if(Array.isArray(o))return o.length*t(r.elementLayout)}else if("fields"in r)return mi({layout:r},e[r.property]);return 0},n=0;return s.layout.fields.forEach(r=>{n+=t(r)}),n}function Re(s){let e=0,t=0;for(;;){let n=s.shift();if(e|=(n&127)<<t*7,t+=1,(n&128)===0)break}return e}function Ee(s,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){s.push(n);break}else n|=128,s.push(n)}}function q(s,e){if(!s)throw new Error(e||"Assertion failed")}var Qn=class s{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){let n=new Map,r=i=>{let a=i.toBase58(),c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=r(t);o.isSigner=!0,o.isWritable=!0;for(let i of e){r(i.programId).isInvoked=!0;for(let a of i.keys){let c=r(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new s(t,n)}getMessageComponents(){let e=[...this.keyMetaMap.entries()];q(e.length<=256,"Max static account keys length exceeded");let t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),r=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{q(t.length>0,"Expected at least one writable signer key");let[c]=t[0];q(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}let a=[...t.map(([c])=>new N(c)),...n.map(([c])=>new N(c)),...r.map(([c])=>new N(c)),...o.map(([c])=>new N(c))];return[i,a]}extractTableLookup(e){let[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[r,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){let n=new Array,r=new Array;for(let[o,i]of this.keyMetaMap.entries())if(t(i)){let a=new N(o),c=e.findIndex(f=>f.equals(a));c>=0&&(q(c<256,"Max lookup table index exceeded"),n.push(c),r.push(a),this.keyMetaMap.delete(o))}return[n,r]}},Ai="Reached end of buffer unexpectedly";function je(s){if(s.length===0)throw new Error(Ai);return s.shift()}function we(s,...e){let[t]=e;if(e.length===2?t+(e[1]??0)>s.length:t>=s.length)throw new Error(Ai);return s.splice(...e)}var rt=class s{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new N(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ae.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Tt(this.staticAccountKeys)}static compile(e){let t=Qn.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),i=new Tt(r).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:ae.default.encode(a.data)}));return new s({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){let n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{let n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){let e=this.accountKeys.length,t=[];Ee(t,e);let n=this.instructions.map(m=>{let{accounts:I,programIdIndex:p}=m,y=Array.from(ae.default.decode(m.data)),g=[];Ee(g,I.length);let A=[];return Ee(A,y.length),{programIdIndex:p,keyIndicesCount:P.Buffer.from(g),keyIndices:I,dataLength:P.Buffer.from(A),data:y}}),r=[];Ee(r,n.length);let o=P.Buffer.alloc(gt);P.Buffer.from(r).copy(o);let i=r.length;n.forEach(m=>{let p=u.struct([u.u8("programIdIndex"),u.blob(m.keyIndicesCount.length,"keyIndicesCount"),u.seq(u.u8("keyIndex"),m.keyIndices.length,"keyIndices"),u.blob(m.dataLength.length,"dataLength"),u.seq(u.u8("userdatum"),m.data.length,"data")]).encode(m,o,i);i+=p}),o=o.slice(0,i);let a=u.struct([u.blob(1,"numRequiredSignatures"),u.blob(1,"numReadonlySignedAccounts"),u.blob(1,"numReadonlyUnsignedAccounts"),u.blob(t.length,"keyCount"),u.seq(M("key"),e,"keys"),M("recentBlockhash")]),c={numRequiredSignatures:P.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:P.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:P.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:P.Buffer.from(t),keys:this.accountKeys.map(m=>F(m.toBytes())),recentBlockhash:ae.default.decode(this.recentBlockhash)},f=P.Buffer.alloc(2048),d=a.encode(c,f);return o.copy(f,d),f.slice(0,d+o.length)}static from(e){let t=[...e],n=je(t);if(n!==(n&Rs))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let r=je(t),o=je(t),i=Re(t),a=[];for(let I=0;I<i;I++){let p=we(t,0,nt);a.push(new N(P.Buffer.from(p)))}let c=we(t,0,nt),f=Re(t),d=[];for(let I=0;I<f;I++){let p=je(t),y=Re(t),g=we(t,0,y),A=Re(t),C=we(t,0,A),x=ae.default.encode(P.Buffer.from(C));d.push({programIdIndex:p,accounts:g,data:x})}let m={header:{numRequiredSignatures:n,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:o},recentBlockhash:ae.default.encode(P.Buffer.from(c)),accountKeys:a,instructions:d};return new s(m)}},er=class s{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(let t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Tt(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){let r=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return r<o}else if(e>=this.header.numRequiredSignatures){let r=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return r<i}else{let r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){let t={writable:[],readonly:[]};for(let n of this.addressTableLookups){let r=e.find(o=>o.key.equals(n.accountKey));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(let o of n.writableIndexes)if(o<r.state.addresses.length)t.writable.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(let o of n.readonlyIndexes)if(o<r.state.addresses.length)t.readonly.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){let t=Qn.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(let d of o){let m=t.extractTableLookup(d);if(m!==void 0){let[I,{writable:p,readonly:y}]=m;n.push(I),r.writable.push(...p),r.readonly.push(...y)}}let[i,a]=t.getMessageComponents(),f=new Tt(a,r).compileInstructions(e.instructions);return new s({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:f,addressTableLookups:n})}serialize(){let e=Array();Ee(e,this.staticAccountKeys.length);let t=this.serializeInstructions(),n=Array();Ee(n,this.compiledInstructions.length);let r=this.serializeAddressTableLookups(),o=Array();Ee(o,this.addressTableLookups.length);let i=u.struct([u.u8("prefix"),u.struct([u.u8("numRequiredSignatures"),u.u8("numReadonlySignedAccounts"),u.u8("numReadonlyUnsignedAccounts")],"header"),u.blob(e.length,"staticAccountKeysLength"),u.seq(M(),this.staticAccountKeys.length,"staticAccountKeys"),M("recentBlockhash"),u.blob(n.length,"instructionsLength"),u.blob(t.length,"serializedInstructions"),u.blob(o.length,"addressTableLookupsLength"),u.blob(r.length,"serializedAddressTableLookups")]),a=new Uint8Array(gt),f=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:ae.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:r},a);return a.slice(0,f)}serializeInstructions(){let e=0,t=new Uint8Array(gt);for(let n of this.compiledInstructions){let r=Array();Ee(r,n.accountKeyIndexes.length);let o=Array();Ee(o,n.data.length);let i=u.struct([u.u8("programIdIndex"),u.blob(r.length,"encodedAccountKeyIndexesLength"),u.seq(u.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),u.blob(o.length,"encodedDataLength"),u.blob(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0,t=new Uint8Array(gt);for(let n of this.addressTableLookups){let r=Array();Ee(r,n.writableIndexes.length);let o=Array();Ee(o,n.readonlyIndexes.length);let i=u.struct([M("accountKey"),u.blob(r.length,"encodedWritableIndexesLength"),u.seq(u.u8(),n.writableIndexes.length,"writableIndexes"),u.blob(o.length,"encodedReadonlyIndexesLength"),u.seq(u.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e],n=je(t),r=n&Rs;q(n!==r,"Expected versioned message but received legacy message");let o=r;q(o===0,`Expected versioned message with version 0 but found version ${o}`);let i={numRequiredSignatures:je(t),numReadonlySignedAccounts:je(t),numReadonlyUnsignedAccounts:je(t)},a=[],c=Re(t);for(let y=0;y<c;y++)a.push(new N(we(t,0,nt)));let f=ae.default.encode(we(t,0,nt)),d=Re(t),m=[];for(let y=0;y<d;y++){let g=je(t),A=Re(t),C=we(t,0,A),x=Re(t),Q=new Uint8Array(we(t,0,x));m.push({programIdIndex:g,accountKeyIndexes:C,data:Q})}let I=Re(t),p=[];for(let y=0;y<I;y++){let g=new N(we(t,0,nt)),A=Re(t),C=we(t,0,A),x=Re(t),Q=we(t,0,x);p.push({accountKey:g,writableIndexes:C,readonlyIndexes:Q})}return new s({header:i,staticAccountKeys:a,recentBlockhash:f,compiledInstructions:m,addressTableLookups:p})}},Ri={deserializeMessageVersion(s){let e=s[0],t=e&Rs;return t===e?"legacy":t},deserialize:s=>{let e=Ri.deserializeMessageVersion(s);if(e==="legacy")return rt.from(s);if(e===0)return er.deserialize(s);throw new Error(`Transaction message version ${e} deserialization is not supported`)}},et=function(s){return s[s.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",s[s.PROCESSED=1]="PROCESSED",s[s.TIMED_OUT=2]="TIMED_OUT",s[s.NONCE_INVALID=3]="NONCE_INVALID",s}({}),of=P.Buffer.alloc(Xn).fill(0),j=class{constructor(e){this.keys=void 0,this.programId=void 0,this.data=P.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}},D=class s{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){let{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){let{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{let{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new j(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let g=0;g<t.length;g++)if(t[g].programId===void 0)throw new Error(`Transaction instruction index ${g} has undefined program id`);let r=[],o=[];t.forEach(g=>{g.keys.forEach(C=>{o.push({...C})});let A=g.programId.toString();r.includes(A)||r.push(A)}),r.forEach(g=>{o.push({pubkey:new N(g),isSigner:!1,isWritable:!1})});let i=[];o.forEach(g=>{let A=g.pubkey.toString(),C=i.findIndex(x=>x.pubkey.toString()===A);C>-1?(i[C].isWritable=i[C].isWritable||g.isWritable,i[C].isSigner=i[C].isSigner||g.isSigner):i.push(g)}),i.sort(function(g,A){if(g.isSigner!==A.isSigner)return g.isSigner?-1:1;if(g.isWritable!==A.isWritable)return g.isWritable?-1:1;let C={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return g.pubkey.toBase58().localeCompare(A.pubkey.toBase58(),"en",C)});let a=i.findIndex(g=>g.pubkey.equals(n));if(a>-1){let[g]=i.splice(a,1);g.isSigner=!0,g.isWritable=!0,i.unshift(g)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(let g of this.signatures){let A=i.findIndex(C=>C.pubkey.equals(g.publicKey));if(A>-1)i[A].isSigner||(i[A].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${g.publicKey.toString()}`)}let c=0,f=0,d=0,m=[],I=[];i.forEach(({pubkey:g,isSigner:A,isWritable:C})=>{A?(m.push(g.toString()),c+=1,C||(f+=1)):(I.push(g.toString()),C||(d+=1))});let p=m.concat(I),y=t.map(g=>{let{data:A,programId:C}=g;return{programIdIndex:p.indexOf(C.toString()),accounts:g.keys.map(x=>p.indexOf(x.pubkey.toString())),data:ae.default.encode(A)}});return y.forEach(g=>{q(g.programIdIndex>=0),g.accounts.forEach(A=>q(A>=0))}),new rt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:f,numReadonlyUnsignedAccounts:d},accountKeys:p,recentBlockhash:e,instructions:y})}_compile(){let e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,o)=>t[o].equals(r.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");let t=new Set;this.signatures=e.filter(n=>{let r=n.toString();return t.has(r)?!1:(t.add(r),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));let r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}let r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){let n=e.serialize();t.forEach(r=>{let o=As(n,r.secretKey);this._addSignature(r.publicKey,F(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){q(t.length===64);let n=this.signatures.findIndex(r=>e.equals(r.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=P.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){let n={};for(let{signature:r,publicKey:o}of this.signatures)r===null?t&&(n.missing||=[]).push(o):Jl(r,e,o.toBytes())||(n.invalid||=[]).push(o);return n.invalid||n.missing?n:void 0}serialize(e){let{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n){let o=this._getMessageSignednessErrors(r,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(r)}_serialize(e){let{signatures:t}=this,n=[];Ee(n,t.length);let r=n.length+t.length*64+e.length,o=P.Buffer.alloc(r);return q(t.length<256),P.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(q(i.length===64,"signature has invalid length"),P.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),q(o.length<=gt,`Transaction too large: ${o.length} > ${gt}`),o}get keys(){return q(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return q(this.instructions.length===1),this.instructions[0].programId}get data(){return q(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e],n=Re(t),r=[];for(let o=0;o<n;o++){let i=we(t,0,Xn);r.push(ae.default.encode(P.Buffer.from(i)))}return s.populate(rt.from(t),r)}static populate(e,t=[]){let n=new s;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((r,o)=>{let i={signature:r==ae.default.encode(of)?null:ae.default.decode(r),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(r=>{let o=r.accounts.map(i=>{let a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new j({keys:o,programId:e.accountKeys[r.programIdIndex],data:ae.default.decode(r.data)}))}),n._message=e,n._json=n.toJSON(),n}};var Le=class s{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)q(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{let n=[];for(let r=0;r<e.header.numRequiredSignatures;r++)n.push(new Uint8Array(Xn));this.signatures=n}this.message=e}serialize(){let e=this.message.serialize(),t=Array();Ee(t,this.signatures.length);let n=u.struct([u.blob(t.length,"encodedSignaturesLength"),u.seq(ef(),this.signatures.length,"signatures"),u.blob(e.length,"serializedMessage")]),r=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,o)}static deserialize(e){let t=[...e],n=[],r=Re(t);for(let i=0;i<r;i++)n.push(new Uint8Array(we(t,0,Xn)));let o=Ri.deserialize(new Uint8Array(t));return new s(o,n)}sign(e){let t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(let r of e){let o=n.findIndex(i=>i.equals(r.publicKey));q(o>=0,`Cannot sign with non signer key ${r.publicKey.toBase58()}`),this.signatures[o]=As(t,r.secretKey)}}addSignature(e,t){q(t.byteLength===64,"Signature must be 64 bytes long");let r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));q(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}},af=160,cf=64,uf=af/cf,Ei=1e3/uf,Ge=new N("SysvarC1ock11111111111111111111111111111111"),ng=new N("SysvarEpochSchedu1e111111111111111111111111"),rg=new N("Sysvar1nstructions1111111111111111111111111"),Jr=new N("SysvarRecentB1ockHashes11111111111111111111"),Xt=new N("SysvarRent111111111111111111111111111111111"),sg=new N("SysvarRewards111111111111111111111111111111"),og=new N("SysvarS1otHashes111111111111111111111111111"),ig=new N("SysvarS1otHistory11111111111111111111111111"),Zr=new N("SysvarStakeHistory1111111111111111111111111"),Jt=class extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:r}){let o=r?`Logs: 
${JSON.stringify(r.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=r||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(r=>{if(r&&r.meta&&r.meta.logMessages){let o=r.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}};var T=class extends Error{constructor({code:e,message:t,data:n},r){super(r!=null?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}};async function ei(s,e,t,n){let r=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await s.sendTransaction(e,t,r),i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await s.confirmTransaction({abortSignal:n?.abortSignal,signature:o,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){let{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await s.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else n?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await s.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw o!=null?new Jt({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(i)})`);return o}function ht(s){return new Promise(e=>setTimeout(e,s))}function W(s,e){let t=s.layout.span>=0?s.layout.span:mi(s,e),n=P.Buffer.alloc(t),r=Object.assign({instruction:s.index},e);return s.layout.encode(r,n),n}var df=u.nu64("lamportsPerSignature"),wi=u.struct([u.u32("version"),u.u32("state"),M("authorizedPubkey"),M("nonce"),u.struct([df],"feeCalculator")]),ti=wi.span,cs=class s{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){let t=wi.decode(F(e),0);return new s({authorizedPubkey:new N(t.authorizedPubkey),nonce:new N(t.nonce).toString(),feeCalculator:t.feeCalculator})}};function kt(s){let e=(0,gi.blob)(8,s),t=e.decode.bind(e),n=e.encode.bind(e),r=e,o=zo();return r.decode=(i,a)=>{let c=t(i,a);return o.decode(c)},r.encode=(i,a,c)=>{let f=o.encode(i);return n(f,a,c)},r}var Ce=Object.freeze({Create:{index:0,layout:u.struct([u.u32("instruction"),u.ns64("lamports"),u.ns64("space"),M("programId")])},Assign:{index:1,layout:u.struct([u.u32("instruction"),M("programId")])},Transfer:{index:2,layout:u.struct([u.u32("instruction"),kt("lamports")])},CreateWithSeed:{index:3,layout:u.struct([u.u32("instruction"),M("base"),Ot("seed"),u.ns64("lamports"),u.ns64("space"),M("programId")])},AdvanceNonceAccount:{index:4,layout:u.struct([u.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:u.struct([u.u32("instruction"),M("authorized")])},AuthorizeNonceAccount:{index:7,layout:u.struct([u.u32("instruction"),M("authorized")])},Allocate:{index:8,layout:u.struct([u.u32("instruction"),u.ns64("space")])},AllocateWithSeed:{index:9,layout:u.struct([u.u32("instruction"),M("base"),Ot("seed"),u.ns64("space"),M("programId")])},AssignWithSeed:{index:10,layout:u.struct([u.u32("instruction"),M("base"),Ot("seed"),M("programId")])},TransferWithSeed:{index:11,layout:u.struct([u.u32("instruction"),kt("lamports"),Ot("seed"),M("programId")])},UpgradeNonceAccount:{index:12,layout:u.struct([u.u32("instruction")])}}),de=class s{constructor(){}static createAccount(e){let t=Ce.Create,n=W(t,{lamports:e.lamports,space:e.space,programId:F(e.programId.toBuffer())});return new j({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){let r=Ce.TransferWithSeed;t=W(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:F(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{let r=Ce.Transfer;t=W(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new j({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){let r=Ce.AssignWithSeed;t=W(r,{base:F(e.basePubkey.toBuffer()),seed:e.seed,programId:F(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let r=Ce.Assign;t=W(r,{programId:F(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new j({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){let t=Ce.CreateWithSeed,n=W(t,{base:F(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:F(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new j({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){let t=new D;"basePubkey"in e&&"seed"in e?t.add(s.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:ti,programId:this.programId})):t.add(s.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:ti,programId:this.programId}));let n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){let t=Ce.InitializeNonceAccount,n=W(t,{authorized:F(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Jr,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new j(r)}static nonceAdvance(e){let t=Ce.AdvanceNonceAccount,n=W(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Jr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new j(r)}static nonceWithdraw(e){let t=Ce.WithdrawNonceAccount,n=W(t,{lamports:e.lamports});return new j({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Jr,isSigner:!1,isWritable:!1},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){let t=Ce.AuthorizeNonceAccount,n=W(t,{authorized:F(e.newAuthorizedPubkey.toBuffer())});return new j({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){let r=Ce.AllocateWithSeed;t=W(r,{base:F(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:F(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let r=Ce.Allocate;t=W(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new j({keys:n,programId:this.programId,data:t})}};de.programId=new N("11111111111111111111111111111111");var lf=gt-300,us=class s{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/s.chunkSize)+1+1)}static async load(e,t,n,r,o){{let m=await e.getMinimumBalanceForRentExemption(o.length),I=await e.getAccountInfo(n.publicKey,"confirmed"),p=null;if(I!==null){if(I.executable)return console.error("Program load failed, account is already executable"),!1;I.data.length!==o.length&&(p=p||new D,p.add(de.allocate({accountPubkey:n.publicKey,space:o.length}))),I.owner.equals(r)||(p=p||new D,p.add(de.assign({accountPubkey:n.publicKey,programId:r}))),I.lamports<m&&(p=p||new D,p.add(de.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:m-I.lamports})))}else p=new D().add(de.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:m>0?m:1,space:o.length,programId:r}));p!==null&&await ei(e,p,[t,n],{commitment:"confirmed"})}let i=u.struct([u.u32("instruction"),u.u32("offset"),u.u32("bytesLength"),u.u32("bytesLengthPadding"),u.seq(u.u8("byte"),u.offset(u.u32(),-8),"bytes")]),a=s.chunkSize,c=0,f=o,d=[];for(;f.length>0;){let m=f.slice(0,a),I=P.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:m,bytesLength:0,bytesLengthPadding:0},I);let p=new D().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:r,data:I});d.push(ei(e,p,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await ht(1e3/4),c+=a,f=f.slice(a)}await Promise.all(d);{let m=u.struct([u.u32("instruction")]),I=P.Buffer.alloc(m.span);m.encode({instruction:1},I);let p=new D().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1}],programId:r,data:I}),y="processed",g=await e.sendTransaction(p,[t,n],{preflightCommitment:y}),{context:A,value:C}=await e.confirmTransaction({signature:g,lastValidBlockHeight:p.lastValidBlockHeight,blockhash:p.recentBlockhash},y);if(C.err)throw new Error(`Transaction ${g} failed (${JSON.stringify(C)})`);for(;;){try{if(await e.getSlot({commitment:y})>A.slot)break}catch{}await new Promise(x=>setTimeout(x,Math.round(Ei/2)))}}return!0}};us.chunkSize=lf;var ag=new N("BPFLoader2111111111111111111111111111111111");function ff(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var Qr,ni;function hf(){if(ni)return Qr;ni=1;var s=Object.prototype.toString,e=Object.keys||function(n){var r=[];for(var o in n)r.push(o);return r};function t(n,r){var o,i,a,c,f,d,m;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),r);if(m=s.call(n),m==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(m==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)f=c[o],d=t(n[f],!1),d!==void 0&&(a&&(a+=","),a+=JSON.stringify(f)+":"+d),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return r?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return Qr=function(n){var r=t(n,!1);if(r!==void 0)return""+r},Qr}var pf=hf(),ri=ff(pf),Gt=32;function es(s){let e=0;for(;s>1;)s/=2,e++;return e}function gf(s){return s===0?1:(s--,s|=s>>1,s|=s>>2,s|=s>>4,s|=s>>8,s|=s>>16,s|=s>>32,s+1)}var ds=class{constructor(e,t,n,r,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){let t=es(gf(e+Gt+1))-es(Gt)-1,n=this.getSlotsInEpoch(t),r=e-(n-Gt);return[t,r]}else{let t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[r,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Gt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+es(Gt)):this.slotsPerEpoch}},_f=globalThis.fetch,ls=class extends Xo{constructor(e,t,n){let r=o=>{let i=Yo(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){let t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){let t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}};function yf(s,e){let t;try{t=s.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==s.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${s.index}`);return t}var si=56,tr=class{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){let e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){let t=yf(mf,e),n=e.length-si;q(n>=0,"lookup table is invalid"),q(n%32===0,"lookup table is invalid");let r=n/32,{addresses:o}=u.struct([u.seq(M(),r,"addresses")]).decode(e.slice(si));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new N(t.authority[0]):void 0,addresses:o.map(i=>new N(i))}}},mf={index:1,layout:u.struct([u.u32("typeIndex"),kt("deactivationSlot"),u.nu64("lastExtendedSlot"),u.u8("lastExtendedStartIndex"),u.u8(),u.seq(M(),u.offset(u.u8(),-1),"authority")])},Af=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Rf(s){let e=s.match(Af);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${s}\``);let[t,n,r,o]=e,i=s.startsWith("https:")?"wss:":"ws:",a=r==null?null:parseInt(r.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}var te=Ct(Hn(N),R(),s=>new N(s)),Si=qn([R(),Z("base64")]),Es=Ct(Hn(P.Buffer),Si,s=>P.Buffer.from(s[0],"base64")),Ef=30*1e3;function wf(s){if(/^https?:/.test(s)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return s}function X(s){let e,t;if(typeof s=="string")e=s;else if(s){let{commitment:n,...r}=s;e=n,t=r}return{commitment:e,config:t}}function oi(s){return s.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function bi(s){return pe([_({jsonrpc:Z("2.0"),id:R(),result:s}),_({jsonrpc:Z("2.0"),id:R(),error:_({code:ft(),message:R(),data:v($o())})})])}var Sf=bi(ft());function U(s){return Ct(bi(s),Sf,e=>"error"in e?e:{...e,result:w(e.result,s)})}function se(s){return U(_({context:_({slot:l()}),value:s}))}function or(s){return _({context:_({slot:l()}),value:s})}function ts(s,e){return s===0?new er({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new N(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ae.default.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new rt(e)}var bf=_({foundation:l(),foundationTerm:l(),initial:l(),taper:l(),terminal:l()}),If=U(S(b(_({epoch:l(),effectiveSlot:l(),amount:l(),postBalance:l(),commission:v(b(l()))})))),Nf=S(_({slot:l(),prioritizationFee:l()})),Cf=_({total:l(),validator:l(),foundation:l(),epoch:l()}),Of=_({epoch:l(),slotIndex:l(),slotsInEpoch:l(),absoluteSlot:l(),blockHeight:v(l()),transactionCount:v(l())}),Tf=_({slotsPerEpoch:l(),leaderScheduleSlotOffset:l(),warmup:ve(),firstNormalEpoch:l(),firstNormalSlot:l()}),kf=Xr(R(),S(l())),_t=b(pe([_({}),R()])),vf=_({err:_t}),Lf=Z("receivedSignature"),Pf=_({"solana-core":R(),"feature-set":v(l())}),Bf=_({program:R(),programId:te,parsed:ft()}),xf=_({programId:te,accounts:S(te),data:R()}),ii=se(_({err:b(pe([_({}),R()])),logs:b(S(R())),accounts:v(b(S(b(_({executable:ve(),owner:R(),lamports:l(),data:S(R()),rentEpoch:v(l())}))))),unitsConsumed:v(l()),returnData:v(b(_({programId:R(),data:qn([R(),Z("base64")])}))),innerInstructions:v(b(S(_({index:l(),instructions:S(pe([Bf,xf]))}))))})),Uf=se(_({byIdentity:Xr(R(),S(l())),range:_({firstSlot:l(),lastSlot:l()})}));function Df(s,e,t,n,r,o){let i=t||_f,a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(d,m)=>{let I=await new Promise((p,y)=>{try{n(d,m,(g,A)=>p([g,A]))}catch(g){y(g)}});return await i(...I)}),new _i.default(async(d,m)=>{let I={method:"POST",body:d,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Dh)};try{let p=5,y,g=500;for(;c?y=await c(s,I):y=await i(s,I),!(y.status!==429||r===!0||(p-=1,p===0));)console.error(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${g}ms delay...`),await ht(g),g*=2;let A=await y.text();y.ok?m(null,A):m(new Error(`${y.status} ${y.statusText}: ${A}`))}catch(p){p instanceof Error&&m(p)}},{})}function Mf(s){return(e,t)=>new Promise((n,r)=>{s.request(e,t,(o,i)=>{if(o){r(o);return}n(i)})})}function zf(s){return e=>new Promise((t,n)=>{e.length===0&&t([]);let r=e.map(o=>s.request(o.methodName,o.args));s.request(r,(o,i)=>{if(o){n(o);return}t(i)})})}var Ff=U(bf),Wf=U(Cf),Kf=U(Nf),$f=U(Of),Vf=U(Tf),Hf=U(kf),qf=U(l()),Gf=se(_({total:l(),circulating:l(),nonCirculating:l(),nonCirculatingAccounts:S(te)})),fs=_({amount:R(),uiAmount:b(l()),decimals:l(),uiAmountString:v(R())}),jf=se(S(_({address:te,amount:R(),uiAmount:b(l()),decimals:l(),uiAmountString:v(R())}))),Yf=se(S(_({pubkey:te,account:_({executable:ve(),owner:te,lamports:l(),data:Es,rentEpoch:l()})}))),hs=_({program:R(),parsed:ft(),space:l()}),Xf=se(S(_({pubkey:te,account:_({executable:ve(),owner:te,lamports:l(),data:hs,rentEpoch:l()})}))),Jf=se(S(_({lamports:l(),address:te}))),Zt=_({executable:ve(),owner:te,lamports:l(),data:Es,rentEpoch:l()}),Zf=_({pubkey:te,account:Zt}),Qf=Ct(pe([Hn(P.Buffer),hs]),pe([Si,hs]),s=>Array.isArray(s)?w(s,Es):s),ps=_({executable:ve(),owner:te,lamports:l(),data:Qf,rentEpoch:l()}),eh=_({pubkey:te,account:ps}),th=_({state:pe([Z("active"),Z("inactive"),Z("activating"),Z("deactivating")]),active:l(),inactive:l()}),nh=U(S(_({signature:R(),slot:l(),err:_t,memo:b(R()),blockTime:v(b(l()))}))),rh=U(S(_({signature:R(),slot:l(),err:_t,memo:b(R()),blockTime:v(b(l()))}))),sh=_({subscription:l(),result:or(Zt)}),oh=_({pubkey:te,account:Zt}),ih=_({subscription:l(),result:or(oh)}),ah=_({parent:l(),slot:l(),root:l()}),ch=_({subscription:l(),result:ah}),uh=pe([_({type:pe([Z("firstShredReceived"),Z("completed"),Z("optimisticConfirmation"),Z("root")]),slot:l(),timestamp:l()}),_({type:Z("createdBank"),parent:l(),slot:l(),timestamp:l()}),_({type:Z("frozen"),slot:l(),timestamp:l(),stats:_({numTransactionEntries:l(),numSuccessfulTransactions:l(),numFailedTransactions:l(),maxTransactionsPerEntry:l()})}),_({type:Z("dead"),slot:l(),timestamp:l(),err:R()})]),dh=_({subscription:l(),result:uh}),lh=_({subscription:l(),result:or(pe([vf,Lf]))}),fh=_({subscription:l(),result:l()}),hh=_({pubkey:R(),gossip:b(R()),tpu:b(R()),rpc:b(R()),version:b(R())}),ai=_({votePubkey:R(),nodePubkey:R(),activatedStake:l(),epochVoteAccount:ve(),epochCredits:S(qn([l(),l(),l()])),commission:l(),lastVote:l(),rootSlot:b(l())}),ph=U(_({current:S(ai),delinquent:S(ai)})),gh=pe([Z("processed"),Z("confirmed"),Z("finalized")]),_h=_({slot:l(),confirmations:b(l()),err:_t,confirmationStatus:v(gh)}),yh=se(S(b(_h))),mh=U(l()),Ii=_({accountKey:te,writableIndexes:S(l()),readonlyIndexes:S(l())}),ws=_({signatures:S(R()),message:_({accountKeys:S(R()),header:_({numRequiredSignatures:l(),numReadonlySignedAccounts:l(),numReadonlyUnsignedAccounts:l()}),instructions:S(_({accounts:S(l()),data:R(),programIdIndex:l()})),recentBlockhash:R(),addressTableLookups:v(S(Ii))})}),Ni=_({pubkey:te,signer:ve(),writable:ve(),source:v(pe([Z("transaction"),Z("lookupTable")]))}),Ci=_({accountKeys:S(Ni),signatures:S(R())}),Oi=_({parsed:ft(),program:R(),programId:te}),Ti=_({accounts:S(te),data:R(),programId:te}),Ah=pe([Ti,Oi]),Rh=pe([_({parsed:ft(),program:R(),programId:R()}),_({accounts:S(R()),data:R(),programId:R()})]),ki=Ct(Ah,Rh,s=>"accounts"in s?w(s,Ti):w(s,Oi)),vi=_({signatures:S(R()),message:_({accountKeys:S(Ni),instructions:S(ki),recentBlockhash:R(),addressTableLookups:v(b(S(Ii)))})}),nr=_({accountIndex:l(),mint:R(),owner:v(R()),programId:v(R()),uiTokenAmount:fs}),Li=_({writable:S(te),readonly:S(te)}),ir=_({err:_t,fee:l(),innerInstructions:v(b(S(_({index:l(),instructions:S(_({accounts:S(l()),data:R(),programIdIndex:l()}))})))),preBalances:S(l()),postBalances:S(l()),logMessages:v(b(S(R()))),preTokenBalances:v(b(S(nr))),postTokenBalances:v(b(S(nr))),loadedAddresses:v(Li),computeUnitsConsumed:v(l())}),Ss=_({err:_t,fee:l(),innerInstructions:v(b(S(_({index:l(),instructions:S(ki)})))),preBalances:S(l()),postBalances:S(l()),logMessages:v(b(S(R()))),preTokenBalances:v(b(S(nr))),postTokenBalances:v(b(S(nr))),loadedAddresses:v(Li),computeUnitsConsumed:v(l())}),Pt=pe([Z(0),Z("legacy")]),yt=_({pubkey:R(),lamports:l(),postBalance:b(l()),rewardType:b(R()),commission:v(b(l()))}),Eh=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),transactions:S(_({transaction:ws,meta:b(ir),version:v(Pt)})),rewards:v(S(yt)),blockTime:b(l()),blockHeight:b(l())}))),wh=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),rewards:v(S(yt)),blockTime:b(l()),blockHeight:b(l())}))),Sh=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),transactions:S(_({transaction:Ci,meta:b(ir),version:v(Pt)})),rewards:v(S(yt)),blockTime:b(l()),blockHeight:b(l())}))),bh=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),transactions:S(_({transaction:vi,meta:b(Ss),version:v(Pt)})),rewards:v(S(yt)),blockTime:b(l()),blockHeight:b(l())}))),Ih=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),transactions:S(_({transaction:Ci,meta:b(Ss),version:v(Pt)})),rewards:v(S(yt)),blockTime:b(l()),blockHeight:b(l())}))),Nh=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),rewards:v(S(yt)),blockTime:b(l()),blockHeight:b(l())}))),Ch=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),transactions:S(_({transaction:ws,meta:b(ir)})),rewards:v(S(yt)),blockTime:b(l())}))),ci=U(b(_({blockhash:R(),previousBlockhash:R(),parentSlot:l(),signatures:S(R()),blockTime:b(l())}))),ns=U(b(_({slot:l(),meta:b(ir),blockTime:v(b(l())),transaction:ws,version:v(Pt)}))),Gn=U(b(_({slot:l(),transaction:vi,meta:b(Ss),blockTime:v(b(l())),version:v(Pt)}))),Oh=se(_({blockhash:R(),lastValidBlockHeight:l()})),Th=se(ve()),kh=_({slot:l(),numTransactions:l(),numSlots:l(),samplePeriodSecs:l()}),vh=U(S(kh)),Lh=se(b(_({feeCalculator:_({lamportsPerSignature:l()})}))),Ph=U(R()),Bh=U(R()),xh=_({err:_t,logs:S(R()),signature:R()}),Uh=_({result:or(xh),subscription:l()}),Dh={"solana-client":"js/1.0.0-maintenance"},st=class{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{let f={};return async d=>{let{commitment:m,config:I}=X(d),p=this._buildArgs([],m,void 0,I),y=ri(p);return f[y]=f[y]??(async()=>{try{let g=await this._rpcRequest("getBlockHeight",p),A=w(g,U(l()));if("error"in A)throw new T(A.error,"failed to get block height information");return A.result}finally{delete f[y]}})(),await f[y]}})();let n,r,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=wf(e),this._rpcWsEndpoint=n||Rf(e),this._rpcClient=Df(e,r,o,i,a,c),this._rpcRequest=Mf(this._rpcClient),this._rpcBatchRequest=zf(this._rpcClient),this._rpcWebSocket=new ls(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgs([e.toBase58()],n,void 0,r),i=await this._rpcRequest("getBalance",o),a=w(i,se(l()));if("error"in a)throw new T(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){let t=await this._rpcRequest("getBlockTime",[e]),n=w(t,U(b(l())));if("error"in n)throw new T(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){let e=await this._rpcRequest("minimumLedgerSlot",[]),t=w(e,U(l()));if("error"in t)throw new T(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){let e=await this._rpcRequest("getFirstAvailableBlock",[]),t=w(e,qf);if("error"in t)throw new T(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};let n=await this._rpcRequest("getSupply",[t]),r=w(n,Gf);if("error"in r)throw new T(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){let n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenSupply",n),o=w(r,se(fs));if("error"in o)throw new T(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){let n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenAccountBalance",n),o=w(r,se(fs));if("error"in o)throw new T(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){let{commitment:r,config:o}=X(n),i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});let a=this._buildArgs(i,r,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),f=w(c,Yf);if("error"in f)throw new T(f.error,`failed to get token accounts owned by account ${e.toBase58()}`);return f.result}async getParsedTokenAccountsByOwner(e,t,n){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});let o=this._buildArgs(r,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=w(i,Xf);if("error"in a)throw new T(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){let t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],r=await this._rpcRequest("getLargestAccounts",n),o=w(r,Jf);if("error"in o)throw new T(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){let n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenLargestAccounts",n),o=w(r,jf);if("error"in o)throw new T(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgs([e.toBase58()],n,"base64",r),i=await this._rpcRequest("getAccountInfo",o),a=w(i,se(b(Zt)));if("error"in a)throw new T(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getAccountInfo",o),a=w(i,se(b(ps)));if("error"in a)throw new T(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){let{commitment:n,config:r}=X(t),o=e.map(f=>f.toBase58()),i=this._buildArgs([o],n,"jsonParsed",r),a=await this._rpcRequest("getMultipleAccounts",i),c=w(a,se(S(b(ps))));if("error"in c)throw new T(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){let{commitment:n,config:r}=X(t),o=e.map(f=>f.toBase58()),i=this._buildArgs([o],n,"base64",r),a=await this._rpcRequest("getMultipleAccounts",i),c=w(a,se(S(b(Zt))));if("error"in c)throw new T(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){let{commitment:r,config:o}=X(t),i=this._buildArgs([e.toBase58()],r,void 0,{...o,epoch:n??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=w(a,U(th));if("error"in c)throw new T(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){let{commitment:n,config:r}=X(t),{encoding:o,...i}=r||{},a=this._buildArgs([e.toBase58()],n,o||"base64",{...i,...i.filters?{filters:oi(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),f=S(Zf),d=i.withContext===!0?w(c,se(f)):w(c,U(f));if("error"in d)throw new T(d.error,`failed to get accounts owned by program ${e.toBase58()}`);return d.result}async getParsedProgramAccounts(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getProgramAccounts",o),a=w(i,U(S(eh)));if("error"in a)throw new T(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let n;if(typeof e=="string")n=e;else{let o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let r;try{r=ae.default.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return q(r.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,o=!1,i=new Promise((c,f)=>{try{n=this.onSignature(t,(m,I)=>{n=void 0;let p={context:I,value:m};c({__type:et.PROCESSED,response:p})},e);let d=new Promise(m=>{n==null?m():r=this._onSubscriptionStateChange(n,I=>{I==="subscribed"&&m()})});(async()=>{if(await d,o)return;let m=await this.getSignatureStatus(t);if(o||m==null)return;let{context:I,value:p}=m;if(p!=null)if(p?.err)f(p.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(p.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(p.confirmationStatus==="processed"||p.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:et.PROCESSED,response:{context:I,value:p}})}})()}catch(d){f(d)}});return{abortConfirmation:()=>{r&&(r(),r=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let o=!1,i=new Promise(m=>{let I=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let p=await I();if(!o){for(;p<=n;)if(await ht(1e3),o||(p=await I(),o))return;m({__type:et.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),f=this.getCancellationPromise(t),d;try{let m=await Promise.race([f,c,i]);if(m.__type===et.PROCESSED)d=m.response;else throw new Jn(r)}finally{o=!0,a()}return d}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:o,signature:i}}){let a=!1,c=new Promise(p=>{let y=o,g=null,A=async()=>{try{let{context:C,value:x}=await this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return g=C.slot,x?.nonce}catch{return y}};(async()=>{if(y=await A(),!a)for(;;){if(o!==y){p({__type:et.NONCE_INVALID,slotInWhichNonceDidAdvance:g});return}if(await ht(2e3),a||(y=await A(),a))return}})()}),{abortConfirmation:f,confirmationPromise:d}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),m=this.getCancellationPromise(t),I;try{let p=await Promise.race([m,d,c]);if(p.__type===et.PROCESSED)I=p.response;else{let y;for(;;){let g=await this.getSignatureStatus(i);if(g==null)break;if(g.context.slot<(p.slotInWhichNonceDidAdvance??n)){await ht(400);continue}y=g;break}if(y?.value){let g=e||"finalized",{confirmationStatus:A}=y.value;switch(g){case"processed":case"recent":if(A!=="processed"&&A!=="confirmed"&&A!=="finalized")throw new pt(i);break;case"confirmed":case"single":case"singleGossip":if(A!=="confirmed"&&A!=="finalized")throw new pt(i);break;case"finalized":case"max":case"root":if(A!=="finalized")throw new pt(i);break;default:}I={context:y.context,value:{err:y.value.err}}}else throw new pt(i)}}finally{a=!0,f()}return I}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n,r=new Promise(c=>{let f=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{f=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:et.TIMED_OUT,timeoutMs:f}),f)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t}),a;try{let c=await Promise.race([i,r]);if(c.__type===et.PROCESSED)a=c.response;else throw new Zn(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){let e=await this._rpcRequest("getClusterNodes",[]),t=w(e,U(S(hh)));if("error"in t)throw new T(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){let t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),r=w(n,ph);if("error"in r)throw new T(r.error,"failed to get vote accounts");return r.result}async getSlot(e){let{commitment:t,config:n}=X(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",r),i=w(o,U(l()));if("error"in i)throw new T(i.error,"failed to get slot");return i.result}async getSlotLeader(e){let{commitment:t,config:n}=X(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",r),i=w(o,U(R()));if("error"in i)throw new T(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){let n=[e,t],r=await this._rpcRequest("getSlotLeaders",n),o=w(r,U(S(te)));if("error"in o)throw new T(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){let{context:n,value:r}=await this.getSignatureStatuses([e],t);q(r.length===1);let o=r[0];return{context:n,value:o}}async getSignatureStatuses(e,t){let n=[e];t&&n.push(t);let r=await this._rpcRequest("getSignatureStatuses",n),o=w(r,yh);if("error"in o)throw new T(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){let{commitment:t,config:n}=X(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",r),i=w(o,U(l()));if("error"in i)throw new T(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){let t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),r=w(n,Ff);if("error"in r)throw new T(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,n){let{commitment:r,config:o}=X(n),i=this._buildArgs([e.map(f=>f.toBase58())],r,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=w(a,If);if("error"in c)throw new T(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){let e=await this._rpcRequest("getInflationRate",[]),t=w(e,Wf);if("error"in t)throw new T(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){let{commitment:t,config:n}=X(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",r),i=w(o,$f);if("error"in i)throw new T(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){let e=await this._rpcRequest("getEpochSchedule",[]),t=w(e,Vf);if("error"in t)throw new T(t.error,"failed to get epoch schedule");let n=t.result;return new ds(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){let e=await this._rpcRequest("getLeaderSchedule",[]),t=w(e,Hf);if("error"in t)throw new T(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){let n=this._buildArgs([e],t),r=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=w(r,mh);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){let{context:t,value:{blockhash:n}}=await this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:n,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(e){let t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=w(t,vh);if("error"in n)throw new T(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){let n=this._buildArgs([e],t),r=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=w(r,Lh);if("error"in o)throw new T(o.error,"failed to get fee calculator");let{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){let n=F(e.serialize()).toString("base64"),r=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",r),i=w(o,se(b(l())));if("error"in i)throw new T(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){let t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=t?.length?[t]:[],r=await this._rpcRequest("getRecentPrioritizationFees",n),o=w(r,Kf);if("error"in o)throw new T(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){let{commitment:t,config:n}=X(e),r=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",r),i=w(o,Oh);if("error"in i)throw new T(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgs([e],n,void 0,r),i=await this._rpcRequest("isBlockhashValid",o),a=w(i,Th);if("error"in a)throw new T(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){let e=await this._rpcRequest("getVersion",[]),t=w(e,U(Pf));if("error"in t)throw new T(t.error,"failed to get version");return t.result}async getGenesisHash(){let e=await this._rpcRequest("getGenesisHash",[]),t=w(e,U(R()));if("error"in t)throw new T(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getBlock",o);try{switch(r?.transactionDetails){case"accounts":{let a=w(i,Sh);if("error"in a)throw a.error;return a.result}case"none":{let a=w(i,wh);if("error"in a)throw a.error;return a.result}default:{let a=w(i,Eh);if("error"in a)throw a.error;let{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:f,meta:d,version:m})=>({meta:d,transaction:{...f,message:ts(m,f.message)},version:m}))}:null}}}catch(a){throw new T(a,"failed to get confirmed block")}}async getParsedBlock(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getBlock",o);try{switch(r?.transactionDetails){case"accounts":{let a=w(i,Ih);if("error"in a)throw a.error;return a.result}case"none":{let a=w(i,Nh);if("error"in a)throw a.error;return a.result}default:{let a=w(i,bh);if("error"in a)throw a.error;return a.result}}}catch(a){throw new T(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){let{commitment:a,...c}=e;n=a,t=c}let r=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",r),i=w(o,Uf);if("error"in i)throw new T(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getTransaction",o),a=w(i,ns);if("error"in a)throw new T(a.error,"failed to get transaction");let c=a.result;return c&&{...c,transaction:{...c.transaction,message:ts(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){let{commitment:n,config:r}=X(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getTransaction",o),a=w(i,Gn);if("error"in a)throw new T(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){let{commitment:n,config:r}=X(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",r)}));return(await this._rpcBatchRequest(o)).map(c=>{let f=w(c,Gn);if("error"in f)throw new T(f.error,"failed to get transactions");return f.result})}async getTransactions(e,t){let{commitment:n,config:r}=X(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,r)}));return(await this._rpcBatchRequest(o)).map(c=>{let f=w(c,ns);if("error"in f)throw new T(f.error,"failed to get transactions");let d=f.result;return d&&{...d,transaction:{...d.transaction,message:ts(d.version,d.transaction.message)}}})}async getConfirmedBlock(e,t){let n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getBlock",n),o=w(r,Ch);if("error"in o)throw new T(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");let a={...i,transactions:i.transactions.map(({transaction:c,meta:f})=>{let d=new rt(c.message);return{meta:f,transaction:{...c,message:d}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:f})=>({meta:f,transaction:D.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){let r=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",r),i=w(o,U(S(l())));if("error"in i)throw new T(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),o=w(r,ci);if("error"in o)throw new T(o.error,"failed to get block");let i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),o=w(r,ci);if("error"in o)throw new T(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){let n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getTransaction",n),o=w(r,ns);if("error"in o)throw new T(o.error,"failed to get transaction");let i=o.result;if(!i)return i;let a=new rt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:D.populate(a,c)}}async getParsedConfirmedTransaction(e,t){let n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=await this._rpcRequest("getTransaction",n),o=w(r,Gn);if("error"in o)throw new T(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){let n=e.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{let a=w(i,Gn);if("error"in a)throw new T(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let r={},o=await this.getFirstAvailableBlock();for(;!("until"in r)&&(t--,!(t<=0||t<o));)try{let c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(r.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in r)&&(n++,!(n>i));)try{let c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(r.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,r)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){let r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",r),i=w(o,nh);if("error"in i)throw new T(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){let r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",r),i=w(o,rh);if("error"in i)throw new T(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){let{context:n,value:r}=await this.getAccountInfoAndContext(e,t),o=null;return r!==null&&(o=new tr({key:e,state:tr.deserialize(r.data)})),{context:n,value:o}}async getNonceAndContext(e,t){let{context:n,value:r}=await this.getAccountInfoAndContext(e,t),o=null;return r!==null&&(o=cs.fromAccountData(r.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){let n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=w(n,Ph);if("error"in r)throw new T(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await ht(100);let n=Date.now()-this._blockhashInfo.lastFetch>=Ef;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{let e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){let o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await ht(Ei/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){let{commitment:t,config:n}=X(e),r=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",r),i=w(o,se(l()));if("error"in i)throw new T(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){let g=e.serialize(),A=P.Buffer.from(g).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");let C=t||{};C.encoding="base64","commitment"in C||(C.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(C.innerInstructions=t.innerInstructions);let x=[A,C],Q=await this._rpcRequest("simulateTransaction",x),O=w(Q,ii);if("error"in O)throw new Error("failed to simulate transaction: "+O.error.message);return O.result}let r;if(e instanceof D){let y=e;r=new D,r.feePayer=y.feePayer,r.instructions=e.instructions,r.nonceInfo=y.nonceInfo,r.signatures=y.signatures}else r=D.populate(e),r._message=r._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");let o=t;if(r.nonceInfo&&o)r.sign(...o);else{let y=this._disableBlockhashCaching;for(;;){let g=await this._blockhashWithExpiryBlockHeight(y);if(r.lastValidBlockHeight=g.lastValidBlockHeight,r.recentBlockhash=g.blockhash,!o)break;if(r.sign(...o),!r.signature)throw new Error("!signature");let A=r.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(A)&&!this._blockhashInfo.transactionSignatures.includes(A)){this._blockhashInfo.simulatedSignatures.push(A);break}else y=!0}}let i=r._compile(),a=i.serialize(),f=r._serialize(a).toString("base64"),d={encoding:"base64",commitment:this.commitment};if(n){let y=(Array.isArray(n)?n:i.nonProgramIds()).map(g=>g.toBase58());d.accounts={encoding:"base64",addresses:y}}o&&(d.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(d.innerInstructions=t.innerInstructions);let m=[f,d],I=await this._rpcRequest("simulateTransaction",m),p=w(I,ii);if("error"in p){let y;if("data"in p.error&&(y=p.error.data.logs,y&&Array.isArray(y))){let g=`
    `,A=g+y.join(g);console.error(p.error.message,A)}throw new Jt({action:"simulate",signature:"",transactionMessage:p.error.message,logs:y})}return p.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");let i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");let r=t;if(e.nonceInfo)e.sign(...r);else{let i=this._disableBlockhashCaching;for(;;){let a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");let c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}let o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){let n=F(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){let n={encoding:"base64"},r=t&&t.skipPreflight,o=r===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),o&&(n.preflightCommitment=o);let i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=w(a,Bh);if("error"in c){let f;throw"data"in c.error&&(f=c.error.data.logs),new Jt({action:r?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:f})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){let n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){let r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){let n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};let r=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return r.add(t),()=>{r.delete(t),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}let e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{let r=this._subscriptionsByHash[n];if(r!==void 0)switch(r.state){case"pending":case"unsubscribed":if(r.callbacks.size===0){delete this._subscriptionsByHash[n],r.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{let{args:o,method:i}=r;try{this._setSubscription(n,{...r,state:"subscribing"});let a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...r,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=r.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":r.callbacks.size===0&&await(async()=>{let{serverSubscriptionId:o,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...r,state:"unsubscribing"}),this._setSubscription(n,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...r,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){let n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(r=>{try{r(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){let{result:t,subscription:n}=w(e,sh);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){let n=this._nextClientSubscriptionId++,r=ri([e.method,t]),o=this._subscriptionsByHash[r];return o===void 0?this._subscriptionsByHash[r]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];let i=this._subscriptionsByHash[r];q(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){let{commitment:r,config:o}=X(n),i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){let{result:t,subscription:n}=w(e,ih);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){let{commitment:o,config:i}=X(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(r?{filters:oi(r)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){let r=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){let{result:t,subscription:n}=w(e,Uh);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){let{result:t,subscription:n}=w(e,ch);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){let{result:t,subscription:n}=w(e,dh);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){let n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,r){let o=t||this._commitment;if(o||n||r){let i={};n&&(i.encoding=n),o&&(i.commitment=o),r&&(i=Object.assign(i,r)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){let o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){let{result:t,subscription:n}=w(e,lh);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){let r=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return o}onSignatureWithOptions(e,t,n){let{commitment:r,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],r,void 0,o),a=this._makeSubscription({callback:(c,f)=>{t(c,f);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){let{result:t,subscription:n}=w(e,fh);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}},gs=class s{constructor(e){this._keypair=void 0,this._keypair=e??Jo()}static generate(){return new s(Jo())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");let n=e.slice(32,64);if(!t||!t.skipValidation){let r=e.slice(0,32),o=is(r);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new s({publicKey:n,secretKey:e})}static fromSeed(e){let t=is(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new s({publicKey:t,secretKey:n})}get publicKey(){return new N(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}},jt=Object.freeze({CreateLookupTable:{index:0,layout:u.struct([u.u32("instruction"),kt("recentSlot"),u.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:u.struct([u.u32("instruction")])},ExtendLookupTable:{index:2,layout:u.struct([u.u32("instruction"),kt(),u.seq(M(),u.offset(u.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:u.struct([u.u32("instruction")])},CloseLookupTable:{index:4,layout:u.struct([u.u32("instruction")])}});var _s=class{constructor(){}static createLookupTable(e){let[t,n]=N.findProgramAddressSync([e.authority.toBuffer(),Gr().encode(e.recentSlot)],this.programId),r=jt.CreateLookupTable,o=W(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:de.programId,isSigner:!1,isWritable:!1}];return[new j({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){let t=jt.FreezeLookupTable,n=W(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new j({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){let t=jt.ExtendLookupTable,n=W(t,{addresses:e.addresses.map(o=>o.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:de.programId,isSigner:!1,isWritable:!1}),new j({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){let t=jt.DeactivateLookupTable,n=W(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new j({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){let t=jt.CloseLookupTable,n=W(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new j({programId:this.programId,keys:r,data:n})}};_s.programId=new N("AddressLookupTab1e1111111111111111111111111");var jn=Object.freeze({RequestUnits:{index:0,layout:u.struct([u.u8("instruction"),u.u32("units"),u.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:u.struct([u.u8("instruction"),u.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:u.struct([u.u8("instruction"),u.u32("units")])},SetComputeUnitPrice:{index:3,layout:u.struct([u.u8("instruction"),kt("microLamports")])}}),vt=class{constructor(){}static requestUnits(e){let t=jn.RequestUnits,n=W(t,e);return new j({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){let t=jn.RequestHeapFrame,n=W(t,e);return new j({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){let t=jn.SetComputeUnitLimit,n=W(t,e);return new j({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){let t=jn.SetComputeUnitPrice,n=W(t,{microLamports:BigInt(e.microLamports)});return new j({keys:[],programId:this.programId,data:n})}};vt.programId=new N("ComputeBudget111111111111111111111111111111");var ui=64,di=32,li=64,fi=u.struct([u.u8("numSignatures"),u.u8("padding"),u.u16("signatureOffset"),u.u16("signatureInstructionIndex"),u.u16("publicKeyOffset"),u.u16("publicKeyInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u16("messageInstructionIndex")]),ys=class s{constructor(){}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:r,instructionIndex:o}=e;q(t.length===di,`Public Key must be ${di} bytes but received ${t.length} bytes`),q(r.length===li,`Signature must be ${li} bytes but received ${r.length} bytes`);let i=fi.span,a=i+t.length,c=a+r.length,f=1,d=P.Buffer.alloc(c+n.length),m=o??65535;return fi.encode({numSignatures:f,padding:0,signatureOffset:a,signatureInstructionIndex:m,publicKeyOffset:i,publicKeyInstructionIndex:m,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:m},d),d.fill(t,i),d.fill(r,a),d.fill(n,c),new j({keys:[],programId:s.programId,data:d})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:r}=e;q(t.length===ui,`Private key must be ${ui} bytes but received ${t.length} bytes`);try{let o=gs.fromSecretKey(t),i=o.publicKey.toBytes(),a=As(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};ys.programId=new N("Ed25519SigVerify111111111111111111111111111");var Mh=(s,e)=>{let t=gn.sign(s,e);return[t.toCompactRawBytes(),t.recovery]};gn.utils.isValidPrivateKey;var zh=gn.getPublicKey,hi=32,rs=20,pi=64,Fh=11,ss=u.struct([u.u8("numSignatures"),u.u16("signatureOffset"),u.u8("signatureInstructionIndex"),u.u16("ethAddressOffset"),u.u8("ethAddressInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u8("messageInstructionIndex"),u.blob(20,"ethAddress"),u.blob(64,"signature"),u.u8("recoveryId")]),ms=class s{constructor(){}static publicKeyToEthAddress(e){q(e.length===pi,`Public key must be ${pi} bytes but received ${e.length} bytes`);try{return P.Buffer.from(Er(F(e))).slice(-rs)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:r,recoveryId:o,instructionIndex:i}=e;return s.createInstructionWithEthAddress({ethAddress:s.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){let{ethAddress:t,message:n,signature:r,recoveryId:o,instructionIndex:i=0}=e,a;typeof t=="string"?t.startsWith("0x")?a=P.Buffer.from(t.substr(2),"hex"):a=P.Buffer.from(t,"hex"):a=t,q(a.length===rs,`Address must be ${rs} bytes but received ${a.length} bytes`);let c=1+Fh,f=c,d=c+a.length,m=d+r.length+1,I=1,p=P.Buffer.alloc(ss.span+n.length);return ss.encode({numSignatures:I,signatureOffset:d,signatureInstructionIndex:i,ethAddressOffset:f,ethAddressInstructionIndex:i,messageDataOffset:m,messageDataSize:n.length,messageInstructionIndex:i,signature:F(r),ethAddress:F(a),recoveryId:o},p),p.fill(F(n),ss.span),new j({keys:[],programId:s.programId,data:p})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:r}=e;q(t.length===hi,`Private key must be ${hi} bytes but received ${t.length} bytes`);try{let o=F(t),i=zh(o,!1).slice(1),a=P.Buffer.from(Er(F(n))),[c,f]=Mh(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:f,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};ms.programId=new N("KeccakSecp256k11111111111111111111111111111");var Pi,Wh=new N("StakeConfig11111111111111111111111111111111");var Qt=class{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}};Pi=Qt;Qt.default=new Pi(0,0,N.default);var tt=Object.freeze({Initialize:{index:0,layout:u.struct([u.u32("instruction"),tf(),nf()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),M("newAuthorized"),u.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:u.struct([u.u32("instruction")])},Split:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Withdraw:{index:4,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Deactivate:{index:5,layout:u.struct([u.u32("instruction")])},Merge:{index:7,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:u.struct([u.u32("instruction"),M("newAuthorized"),u.u32("stakeAuthorizationType"),Ot("authoritySeed"),M("authorityOwner")])}}),cg=Object.freeze({Staker:{index:0},Withdrawer:{index:1}}),rr=class{constructor(){}static initialize(e){let{stakePubkey:t,authorized:n,lockup:r}=e,o=r||Qt.default,i=tt.Initialize,a=W(i,{authorized:{staker:F(n.staker.toBuffer()),withdrawer:F(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:F(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new j(c)}static createAccountWithSeed(e){let t=new D;t.add(de.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static createAccount(e){let t=new D;t.add(de.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static delegate(e){let{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,o=tt.Delegate,i=W(o);return new D().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:Zr,isSigner:!1,isWritable:!1},{pubkey:Wh,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){let{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:o,custodianPubkey:i}=e,a=tt.Authorize,c=W(a,{newAuthorized:F(r.toBuffer()),stakeAuthorizationType:o.index}),f=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ge,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&f.push({pubkey:i,isSigner:!0,isWritable:!1}),new D().add({keys:f,programId:this.programId,data:c})}static authorizeWithSeed(e){let{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,f=tt.AuthorizeWithSeed,d=W(f,{newAuthorized:F(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:r,authorityOwner:F(o.toBuffer())}),m=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:Ge,isSigner:!1,isWritable:!1}];return c&&m.push({pubkey:c,isSigner:!0,isWritable:!1}),new D().add({keys:m,programId:this.programId,data:d})}static splitInstruction(e){let{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:o}=e,i=tt.Split,a=W(i,{lamports:o});return new j({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){let n=new D;return n.add(de.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){let{stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,f=new D;return f.add(de.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&f.add(de.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),f.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,lamports:c}))}static merge(e){let{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,o=tt.Merge,i=W(o);return new D().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:Zr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){let{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:o,custodianPubkey:i}=e,a=tt.Withdraw,c=W(a,{lamports:o}),f=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:Zr,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&f.push({pubkey:i,isSigner:!0,isWritable:!1}),new D().add({keys:f,programId:this.programId,data:c})}static deactivate(e){let{stakePubkey:t,authorizedPubkey:n}=e,r=tt.Deactivate,o=W(r);return new D().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}};rr.programId=new N("Stake11111111111111111111111111111111111111");rr.space=200;var Yt=Object.freeze({InitializeAccount:{index:0,layout:u.struct([u.u32("instruction"),rf()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),M("newAuthorized"),u.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:u.struct([u.u32("instruction"),sf()])}}),ug=Object.freeze({Voter:{index:0},Withdrawer:{index:1}}),sr=class s{constructor(){}static initializeAccount(e){let{votePubkey:t,nodePubkey:n,voteInit:r}=e,o=Yt.InitializeAccount,i=W(o,{voteInit:{nodePubkey:F(r.nodePubkey.toBuffer()),authorizedVoter:F(r.authorizedVoter.toBuffer()),authorizedWithdrawer:F(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Xt,isSigner:!1,isWritable:!1},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new j(a)}static createAccount(e){let t=new D;return t.add(de.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){let{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:o}=e,i=Yt.Authorize,a=W(i,{newAuthorized:F(r.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new D().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){let{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=Yt.AuthorizeWithSeed,f=W(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:F(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:F(o.toBuffer()),voteAuthorizationType:i.index}}),d=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:Ge,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new D().add({keys:d,programId:this.programId,data:f})}static withdraw(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:o}=e,i=Yt.Withdraw,a=W(i,{lamports:r}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new D().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return s.withdraw(e)}static updateValidatorIdentity(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:r}=e,o=Yt.UpdateValidatorIdentity,i=W(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new D().add({keys:a,programId:this.programId,data:i})}};sr.programId=new N("Vote111111111111111111111111111111111111111");sr.space=3762;var dg=new N("Va1idator1nfo111111111111111111111111111111"),lg=_({name:R(),website:v(R()),details:v(R()),iconUrl:v(R()),keybaseUsername:v(R())});var fg=new N("Vote111111111111111111111111111111111111111"),hg=u.struct([M("nodePubkey"),M("authorizedWithdrawer"),u.u8("commission"),u.nu64(),u.seq(u.struct([u.nu64("slot"),u.u32("confirmationCount")]),u.offset(u.u32(),-8),"votes"),u.u8("rootSlotValid"),u.nu64("rootSlot"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),M("authorizedVoter")]),u.offset(u.u32(),-8),"authorizedVoters"),u.struct([u.seq(u.struct([M("authorizedPubkey"),u.nu64("epochOfLastAuthorizedSwitch"),u.nu64("targetEpoch")]),32,"buf"),u.nu64("idx"),u.u8("isEmpty")],"priorVoters"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),u.nu64("credits"),u.nu64("prevCredits")]),u.offset(u.u32(),-8),"epochCredits"),u.struct([u.nu64("slot"),u.nu64("timestamp")],"lastTimestamp")]);var Bi=1e9;var Se={UNIVERSAL_PROVIDER_RELAY_URL:"wss://relay.walletconnect.org",HASH_PREFIX:"SPL Name Service",ROOT_DOMAIN_ACCOUNT:new N("58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx"),NAME_PROGRAM_ID:new N("namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"),REVERSE_LOOKUP_CLASS:new N("33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z"),DEFAULT_CHAIN:{id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",chainNamespace:Y.CHAIN.SOLANA,nativeCurrency:{name:"Solana",decimals:9,symbol:"SOL"},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},rpcUrls:{default:{http:[`${Y.BLOCKCHAIN_API_RPC_URL}/v1`]}}},CHAIN_IDS:{Mainnet:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",Devnet:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",Testnet:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",Deprecated_Mainnet:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",Deprecated_Devnet:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"},LAMPORTS_PER_SOL:1e9};function Ye(s){return{formatters:void 0,fees:void 0,serializers:void 0,...s}}var mt=Ye({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"});var en=Ye({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"});var xi=Ye({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"});var Ug=Ye({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}}),Dg=Ye({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0});var Kh={solana:["solana_signMessage","solana_signTransaction","solana_requestAccounts","solana_getAccounts","solana_signAllTransactions","solana_signAndSendTransaction"],eip155:["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_showCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"],bip122:["sendTransfer","signMessage","signPsbt","getAccountAddresses"]},tn={getMethodsByChainNamespace(s){return Kh[s]||[]},createDefaultNamespace(s){return{methods:this.getMethodsByChainNamespace(s),events:["accountsChanged","chainChanged"],chains:[],rpcMap:{}}},applyNamespaceOverrides(s,e){if(!e)return{...s};let t={...s},n=new Set;if(e.methods&&Object.keys(e.methods).forEach(r=>n.add(r)),e.chains&&Object.keys(e.chains).forEach(r=>n.add(r)),e.events&&Object.keys(e.events).forEach(r=>n.add(r)),e.rpcMap&&Object.keys(e.rpcMap).forEach(r=>{let[o]=r.split(":");o&&n.add(o)}),n.forEach(r=>{t[r]||(t[r]=this.createDefaultNamespace(r))}),e.methods&&Object.entries(e.methods).forEach(([r,o])=>{t[r]&&(t[r].methods=o)}),e.chains&&Object.entries(e.chains).forEach(([r,o])=>{t[r]&&(t[r].chains=o)}),e.events&&Object.entries(e.events).forEach(([r,o])=>{t[r]&&(t[r].events=o)}),e.rpcMap){let r=new Set;Object.entries(e.rpcMap).forEach(([o,i])=>{let[a,c]=o.split(":");!a||!c||!t[a]||(t[a].rpcMap||(t[a].rpcMap={}),r.has(a)||(t[a].rpcMap={},r.add(a)),t[a].rpcMap[c]=i)})}return t},createNamespaces(s,e){let t=s.reduce((n,r)=>{let{id:o,chainNamespace:i,rpcUrls:a}=r,c=a.default.http[0];n[i]||(n[i]=this.createDefaultNamespace(i));let f=`${i}:${o}`,d=n[i];switch(d.chains.push(f),f){case mt.caipNetworkId:d.chains.push(mt.deprecatedCaipNetworkId);break;case en.caipNetworkId:d.chains.push(en.deprecatedCaipNetworkId);break;default:}return d?.rpcMap&&c&&(d.rpcMap[o]=c),n},{});return this.applyNamespaceOverrides(t,e)},resolveReownName:async s=>{let e=await ro.resolveName(s);return(Object.values(e?.addresses)||[])[0]?.address||!1},getChainsFromNamespaces(s={}){return Object.values(s).flatMap(e=>{let t=e.chains||[],n=e.accounts.map(r=>{let[o,i]=r.split(":");return`${o}:${i}`});return Array.from(new Set([...t,...n]))})},isSessionEventData(s){return typeof s=="object"&&s!==null&&"id"in s&&"topic"in s&&"params"in s&&typeof s.params=="object"&&s.params!==null&&"chainId"in s.params&&"event"in s.params&&typeof s.params.event=="object"&&s.params.event!==null},isOriginAllowed(s,e,t){for(let n of[...e,...t])if(n.includes("*")){let o=`^${n.replace(/[.*+?^${}()|[\]\\]/gu,"\\$&").replace(/\\\*/gu,".*")}$`;if(new RegExp(o,"u").test(s))return!0}else try{if(new URL(n).origin===s)return!0}catch{if(n===s)return!0}return!1}};var At=class{constructor({provider:e,namespace:t}){this.id=Y.CONNECTOR_ID.WALLET_CONNECT,this.name=Ie.ConnectorNamesMap[Y.CONNECTOR_ID.WALLET_CONNECT],this.type="WALLET_CONNECT",this.imageId=Ie.ConnectorImageIds[Y.CONNECTOR_ID.WALLET_CONNECT],this.getCaipNetworks=Ve.getCaipNetworks.bind(Ve),this.caipNetworks=this.getCaipNetworks(),this.provider=e,this.chain=t}get chains(){return this.getCaipNetworks()}async connectWalletConnect(){if(!await this.authenticate()){let t=this.getCaipNetworks(),n=to.state.universalProviderConfigOverride,r=tn.createNamespaces(t,n);await this.provider.connect({optionalNamespaces:r})}return{clientId:await this.provider.client.core.crypto.getClientId(),session:this.provider.session}}async disconnect(){await this.provider.disconnect()}async authenticate(){let e=this.chains.map(t=>t.caipNetworkId);return so.universalProviderAuthenticate({universalProvider:this.provider,chains:e,methods:$h})}},$h=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_getCallsStatus","wallet_sendCalls","wallet_getCapabilities","wallet_grantPermissions","wallet_revokePermissions","wallet_getAssets"];var Bt=class{constructor(e){this.availableConnectors=[],this.eventListeners=new Map,this.getCaipNetworks=t=>Ve.getCaipNetworks(t),e&&this.construct(e)}construct(e){this.projectId=e.projectId,this.namespace=e.namespace,this.adapterType=e.adapterType}get connectors(){return this.availableConnectors}get networks(){return this.getCaipNetworks(this.namespace)}setAuthProvider(e){this.addConnector({id:Y.CONNECTOR_ID.AUTH,type:"AUTH",name:Y.CONNECTOR_NAMES.AUTH,provider:e,imageId:Ie.ConnectorImageIds[Y.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}addConnector(...e){let t=new Set;this.availableConnectors=[...e,...this.availableConnectors].filter(n=>t.has(n.id)?!1:(t.add(n.id),!0)),this.emit("connectors",this.availableConnectors)}setStatus(e,t){Dt.setStatus(e,t)}on(e,t){this.eventListeners.has(e)||this.eventListeners.set(e,new Set),this.eventListeners.get(e)?.add(t)}off(e,t){let n=this.eventListeners.get(e);n&&n.delete(t)}removeAllEventListeners(){this.eventListeners.forEach(e=>{e.clear()})}emit(e,t){let n=this.eventListeners.get(e);n&&n.forEach(r=>r(t))}async connectWalletConnect(e){return{clientId:(await this.getWalletConnectConnector().connectWalletConnect()).clientId}}async switchNetwork(e){let{caipNetwork:t,providerType:n}=e;if(!e.provider)return;let r="provider"in e.provider?e.provider.provider:e.provider;if(n==="WALLET_CONNECT"){r.setDefaultChain(t.caipNetworkId);return}if(r&&n==="AUTH"){let o=r,i=Dt.state.preferredAccountTypes?.[t.chainNamespace];await o.switchNetwork(t.caipNetworkId);let a=await o.getUser({chainId:t.caipNetworkId,preferredAccountType:i});this.emit("switchNetwork",a)}}getWalletConnectConnector(){let e=this.connectors.find(t=>t instanceof At);if(!e)throw new Error("WalletConnectConnector not found");return e}};var xt=class extends Error{constructor(e,t){super(e),this.error=t}};var ar=class extends xt{constructor(){super(...arguments),this.name="WalletAccountError"}};var cr=class extends xt{constructor(){super(...arguments),this.name="WalletSendTransactionError"}},nn=class extends xt{constructor(){super(...arguments),this.name="WalletSignTransactionError"}},ur=class extends xt{constructor(){super(...arguments),this.name="WalletSignMessageError"}};function We(s){return"version"in s}var dr="solana:signAndSendTransaction";var Ui="solana:signMessage";var rn="solana:signTransaction";var lr="standard:connect";var Di="standard:disconnect";var fr="standard:events";function Mi(s){return lr in s.features&&fr in s.features&&(dr in s.features||rn in s.features)}function zi(s){if(typeof s=="string")return`solana:${s}`}var Ke=class{constructor(){this.listeners={accountsChanged:[],chainChanged:[],connect:[],disconnect:[],pendingTransaction:[],auth_rpcRequest:[],auth_rpcSuccess:[],auth_rpcError:[]}}on(e,t){this.listeners[e].push(t)}removeListener(e,t){this.listeners[e]=this.listeners[e].filter(n=>n!==t)}emit(e,t){this.listeners[e].forEach(n=>n(t))}};var hr=class extends Ke{constructor(e){super(),this.id=Y.CONNECTOR_ID.AUTH,this.name=Y.CONNECTOR_NAMES.AUTH,this.type="AUTH",this.chain=Y.CHAIN.SOLANA,this.provider=e.w3mFrameProvider,this.requestedChains=e.chains,this.getActiveChain=e.getActiveChain}get publicKey(){let e=this.provider.user?.address;return e?new N(e):void 0}get chains(){let e=this.provider.getAvailableChainIds();return this.requestedChains.filter(t=>e.includes(t.caipNetworkId))}async connect(e={}){let t=e.chainId||this.getActiveChain()?.id,n=Dt.state.preferredAccountTypes?.solana;if(await this.provider.connect({chainId:zi(t),socialUri:e.socialUri,preferredAccountType:n}),!this.publicKey)throw new Error("Failed to connect to the wallet");return this.emit("connect",this.publicKey),this.publicKey.toBase58()}async disconnect(){await this.provider.disconnect(),this.emit("disconnect",void 0)}async signMessage(e){if(!this.publicKey)throw new Error("Wallet not connected");let t=await this.provider.request({method:"solana_signMessage",params:{message:ce.encode(e),pubkey:this.publicKey.toBase58()}});return ce.decode(t.signature)}async signTransaction(e){let t=await this.provider.request({method:"solana_signTransaction",params:{transaction:this.serializeTransaction(e)}}),n=ce.decode(t.transaction);return We(e)?Le.deserialize(n):D.from(n)}async signAndSendTransaction(e,t){let n=this.serializeTransaction(e);return(await this.provider.request({method:"solana_signAndSendTransaction",params:{transaction:n,options:t}})).signature}async sendTransaction(e,t,n){let r=await this.signTransaction(e);return await t.sendRawTransaction(r.serialize(),n)}async signAllTransactions(e){return(await this.provider.request({method:"solana_signAllTransactions",params:{transactions:e.map(n=>this.serializeTransaction(n))}})).transactions.map((n,r)=>{let o=e[r];if(!o)throw new Error("Invalid solana_signAllTransactions response");let i=ce.decode(n);return We(o)?Le.deserialize(i):D.from(i)})}async request(e){return this.provider.request({method:e.method,params:e.params})}async getAccounts(){return this.publicKey?Promise.resolve([{namespace:this.chain,address:this.publicKey.toBase58(),type:"eoa"}]):Promise.resolve([])}serializeTransaction(e){return ce.encode(new Uint8Array(e.serialize({verifySignatures:!1})))}};var pr=class extends Ke{constructor(e){super(),this.name="Coinbase Wallet",this.id=Ie.ConnectorExplorerIds[Y.CONNECTOR_ID.COINBASE_SDK]||this.name,this.explorerId=Ie.ConnectorExplorerIds[Y.CONNECTOR_ID.COINBASE_SDK],this.type="ANNOUNCED",this.imageUrl="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",this.chain=Y.CHAIN.SOLANA,this.provider=this,this.coinbase=e.provider,this.requestedChains=e.chains}get chains(){return this.requestedChains.filter(e=>e.id===mt.id)}get publicKey(){return this.coinbase.publicKey}get imageId(){return Ie.ConnectorImageIds[Y.CONNECTOR_ID.COINBASE]}async connect(){try{await this.coinbase.connect();let e=this.getAccount(!0);return this.coinbase.emit("connect",this.coinbase.publicKey),this.emit("connect",e),e.toBase58()}catch(e){throw this.coinbase.emit("error",e),e}}async disconnect(){await this.coinbase.disconnect(),this.coinbase.emit("disconnect",void 0),this.emit("disconnect",void 0)}async signMessage(e){return(await this.coinbase.signMessage(e)).signature}async signTransaction(e){return this.coinbase.signTransaction(e)}async signAndSendTransaction(e,t){return(await this.coinbase.signAndSendTransaction(e,t)).signature}async sendTransaction(e,t,n){let r=await this.signTransaction(e);return await t.sendRawTransaction(r.serialize(),n)}async signAllTransactions(e){return await this.coinbase.signAllTransactions(e)}async request(e){return Promise.reject(new Error('The "request" method is not supported on Coinbase Wallet'))}async getAccounts(){let e=this.getAccount();return e?Promise.resolve([{namespace:this.chain,address:e.toBase58(),type:"eoa"}]):Promise.resolve([])}getAccount(e){let t=this.coinbase.publicKey;if(e&&!t)throw new Error("Not connected");return t}};var sn=class extends Error{constructor(e){super(`The wallet does not support the "${e}" feature`)}},on=class extends Error{constructor(e){super(`The method "${e}" is not supported by the wallet`)}};var an=class extends At{constructor({provider:e,chains:t,getActiveChain:n}){super({caipNetworks:t,namespace:"solana",provider:e}),this.eventEmitter=new Ke,this.emit=this.eventEmitter.emit.bind(this.eventEmitter),this.on=this.eventEmitter.on.bind(this.eventEmitter),this.removeListener=this.eventEmitter.removeListener.bind(this.eventEmitter),this.getActiveChain=n}get session(){return this.provider.session}get chains(){return this.sessionChains.map(e=>{let t=e;return t===Se.CHAIN_IDS.Deprecated_Mainnet?t=Se.CHAIN_IDS.Mainnet:t===Se.CHAIN_IDS.Deprecated_Devnet&&(t=Se.CHAIN_IDS.Devnet),this.caipNetworks.find(n=>n.caipNetworkId===t)}).filter(Boolean)}get publicKey(){let e=this.getAccount(!1);if(e)return new N(e.publicKey)}async connect(){await super.connectWalletConnect();let e=this.getAccount(!0);return this.emit("connect",new N(e.publicKey)),e.address}async disconnect(){await super.disconnect(),this.emit("disconnect",void 0)}async signMessage(e){this.checkIfMethodIsSupported("solana_signMessage");let t=await this.internalRequest("solana_signMessage",{message:ce.encode(e),pubkey:this.getAccount(!0).address});return ce.decode(t.signature)}async signTransaction(e){this.checkIfMethodIsSupported("solana_signTransaction");let t=this.serializeTransaction(e),n=await this.internalRequest("solana_signTransaction",{transaction:t,pubkey:this.getAccount(!0).address,...this.getRawRPCParams(e)});if("signature"in n){let o=ce.decode(n.signature);return e.addSignature(new N(this.getAccount(!0).publicKey),Buffer.from(o)),e}let r=Buffer.from(n.transaction,"base64");return We(e)?Le.deserialize(new Uint8Array(r)):D.from(r)}async signAndSendTransaction(e,t){this.checkIfMethodIsSupported("solana_signAndSendTransaction");let n=this.serializeTransaction(e),r=await this.internalRequest("solana_signAndSendTransaction",{transaction:n,pubkey:this.getAccount(!0).address,sendOptions:t});return this.emit("pendingTransaction",void 0),r.signature}async sendTransaction(e,t,n){let r=await this.signTransaction(e),o=await t.sendRawTransaction(r.serialize(),n);return this.emit("pendingTransaction",void 0),o}async signAllTransactions(e){try{return this.checkIfMethodIsSupported("solana_signAllTransactions"),(await this.internalRequest("solana_signAllTransactions",{transactions:e.map(n=>this.serializeTransaction(n))})).transactions.map((n,r)=>{let o=e[r];if(!o)throw new Error("Invalid transactions response");let i=Buffer.from(n,"base64");return We(o)?Le.deserialize(new Uint8Array(i)):(this.emit("pendingTransaction",void 0),D.from(i))})}catch(t){if(t instanceof on){let n=[];for(let r of e)n.push(await this.signTransaction(r));return n}throw t}}request(e){return this.internalRequest(e.method,e.params)}async getAccounts(){let e=this.session?.namespaces.solana?.accounts||[];return Promise.resolve(e.map(t=>({namespace:this.chain,address:Qs.parseCaipAddress(t).address,type:"eoa"})))}internalRequest(e,t){let r=this.chains.find(o=>this.getActiveChain()?.id===o.id)?.caipNetworkId;switch(r){case Se.CHAIN_IDS.Mainnet:this.sessionChains.includes(Se.CHAIN_IDS.Mainnet)||(r=Se.CHAIN_IDS.Deprecated_Mainnet);break;case Se.CHAIN_IDS.Devnet:this.sessionChains.includes(Se.CHAIN_IDS.Devnet)||(r=Se.CHAIN_IDS.Deprecated_Devnet);break;default:break}return this.provider?.request({method:e,params:t},r)}get sessionChains(){return tn.getChainsFromNamespaces(this.session?.namespaces)}serializeTransaction(e){return Buffer.from(new Uint8Array(e.serialize({verifySignatures:!1}))).toString("base64")}getAccount(e){let t=this.session?.namespaces.solana?.accounts[0];if(!t){if(e)throw new Error("Account not found");return}let n=t.split(":")[2];if(!n){if(e)throw new Error("Address not found");return}return{address:n,publicKey:ce.decode(n)}}getRawRPCParams(e){return We(e)?{}:{feePayer:e.feePayer?.toBase58()??"",instructions:e.instructions.map(t=>({data:ce.encode(new Uint8Array(t.data)),keys:t.keys.map(n=>({isWritable:n.isWritable,isSigner:n.isSigner,pubkey:n.pubkey.toBase58()})),programId:t.programId.toBase58()})),recentBlockhash:e.recentBlockhash??""}}checkIfMethodIsSupported(e){if(!this.session?.namespaces.solana?.methods.includes(e))throw new on(e)}};var Fi={UNIT_PRICE_MICRO_LAMPORTS:2e7,UNIT_LIMIT:500};async function bs({provider:s,to:e,value:t,connection:n}){if(!s.publicKey)throw Error("No public key found");let r=new N(e),o=Math.floor(t*Bi),{blockhash:i,lastValidBlockHeight:a}=await n.getLatestBlockhash(),c=[vt.setComputeUnitPrice({microLamports:Fi.UNIT_PRICE_MICRO_LAMPORTS}),vt.setComputeUnitLimit({units:Fi.UNIT_LIMIT}),de.transfer({fromPubkey:s.publicKey,toPubkey:r,lamports:o})];return new D({feePayer:s.publicKey,blockhash:i,lastValidBlockHeight:a}).add(...c)}var Hh=function(s,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?s!==e||!n:!e.has(s))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(s):n?n.value:e.get(s)},qh=function(s,e,t,n,r){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!r)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?s!==e||!r:!e.has(s))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?r.call(s,t):r?r.value=t:e.set(s,t),t},gr,cn,_r=new Set;function Gh(s){un=void 0,_r.add(s)}function jh(s){un=void 0,_r.delete(s)}var Ut={};function $i(){if(cn||(cn=Object.freeze({register:Wi,get:Yh,on:Xh}),typeof window>"u"))return cn;let s=Object.freeze({register:Wi});try{window.addEventListener("wallet-standard:register-wallet",({detail:e})=>e(s))}catch(e){console.error(`wallet-standard:register-wallet event listener could not be added
`,e)}try{window.dispatchEvent(new Is(s))}catch(e){console.error(`wallet-standard:app-ready event could not be dispatched
`,e)}return cn}function Wi(...s){return s=s.filter(e=>!_r.has(e)),s.length?(s.forEach(e=>Gh(e)),Ut.register?.forEach(e=>Ki(()=>e(...s))),function(){s.forEach(t=>jh(t)),Ut.unregister?.forEach(t=>Ki(()=>t(...s)))}):()=>{}}var un;function Yh(){return un||(un=[..._r]),un}function Xh(s,e){return Ut[s]?.push(e)||(Ut[s]=[e]),function(){Ut[s]=Ut[s]?.filter(n=>e!==n)}}function Ki(s){try{s()}catch(e){console.error(e)}}var Is=class extends Event{get detail(){return Hh(this,gr,"f")}get type(){return"wallet-standard:app-ready"}constructor(e){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),gr.set(this,void 0),qh(this,gr,e,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}};gr=new WeakMap;function Vi(s){switch(s){case"processed":case"confirmed":case"finalized":case void 0:return s;case"recent":return"processed";case"single":case"singleGossip":return"confirmed";case"max":case"root":return"finalized";default:return}}var Ns={"solana:mainnet":mt,"solana:testnet":xi,"solana:devnet":en};var yr=class extends Ke{constructor({wallet:e,getActiveChain:t,requestedChains:n}){super(),this.chain=Y.CHAIN.SOLANA,this.provider=this,this.wallet=e,this.getActiveChain=t,this.requestedChains=n,this.bindEvents()}get id(){let e=this.name;return Ie.ConnectorExplorerIds[e]||e}get name(){return this.wallet.name==="Trust"?"Trust Wallet":this.wallet.name}get type(){return"ANNOUNCED"}get explorerId(){return Ie.ConnectorExplorerIds[this.name]}get publicKey(){let e=this.getAccount(!1);if(e)return new N(e.publicKey)}get imageUrl(){return this.wallet.icon}get chains(){return this.wallet.chains.map(e=>this.requestedChains.find(t=>t.id===e||t.id===Ns[e]?.id)).filter(Boolean)}async connect(){await this.getWalletFeature(lr).connect();let t=this.getAccount(!0),n=new N(t.publicKey);return this.emit("connect",n),t.address}async disconnect(){await this.getWalletFeature(Di).disconnect(),this.emit("disconnect",void 0)}async signMessage(e){let t=this.getWalletFeature(Ui),n=this.getAccount(!0),[r]=await t.signMessage({message:e,account:n});if(!r)throw new ur("Empty result");return r.signature}async signTransaction(e){let t=this.getWalletFeature(rn),n=this.getAccount(!0),r=this.serializeTransaction(e),[o]=await t.signTransaction({account:n,transaction:new Uint8Array(r),chain:this.getActiveChainName()});if(!o)throw new nn("Empty result");return this.emit("pendingTransaction",void 0),We(e)?Le.deserialize(o.signedTransaction):D.from(o.signedTransaction)}async signAndSendTransaction(e,t){let n=this.getWalletFeature(dr),r=this.getAccount(!0),[o]=await n.signAndSendTransaction({account:r,transaction:new Uint8Array(this.serializeTransaction(e)),options:{...t,preflightCommitment:Vi(t?.preflightCommitment)},chain:this.getActiveChainName()});if(!o)throw new cr("Empty result");return this.emit("pendingTransaction",void 0),ce.encode(o.signature)}async sendTransaction(e,t,n){let r=await this.signTransaction(e);return await t.sendRawTransaction(r.serialize(),n)}async signAllTransactions(e){let t=this.getWalletFeature(rn),n=this.getAccount(!0),r=this.getActiveChainName();return(await t.signTransaction(...e.map(i=>({transaction:new Uint8Array(this.serializeTransaction(i)),account:n,chain:r})))).map(({signedTransaction:i},a)=>{let c=e[a];if(!c)throw new nn("Invalid transaction signature response");return this.emit("pendingTransaction",void 0),We(c)?Le.deserialize(i):D.from(i)})}async request(e){return Promise.reject(new sn("request"))}async getAccounts(){return Promise.resolve(this.wallet.accounts.map(e=>({namespace:this.chain,address:e.address,type:"eoa"})))}serializeTransaction(e){return e.serialize({verifySignatures:!1})}getAccount(e){let t=this.wallet.accounts[0];if(e&&!t)throw new ar;return t}getWalletFeature(e){if(!(e in this.wallet.features))throw new sn(e);return this.wallet.features[e]}getActiveChainName(){let e=Object.entries(Ns).find(([,t])=>t.id===this.getActiveChain()?.id);if(!e)throw new Error("Invalid chain id");return e[0]}bindEvents(){this.getWalletFeature(fr).on("change",t=>{if(t.accounts){let n=t.accounts[0];n&&this.emit("accountsChanged",new N(n.publicKey))}})}};var{get:Jh,on:Hi}=$i(),ot=[];function Gi(s,e,t){let n=[Hi("register",(...r)=>{ot=[...ot,...qi(r,s,e)],t(...ot)}),Hi("unregister",(...r)=>{ot=ot.filter(o=>r.some(i=>i.name===o.wallet.name)),t(...ot)})];return ot=qi(Jh(),s,e),t(...ot),()=>n.forEach(r=>r())}function qi(s,e,t){return s.filter(Mi).map(n=>new yr({wallet:n,requestedChains:e,getActiveChain:t}))}var dn=class extends Bt{constructor(e={}){super({adapterType:Y.ADAPTER_TYPES.SOLANA,namespace:Y.CHAIN.SOLANA}),this.balancePromises={},this.providerHandlers=null,this.connectionSettings=e.connectionSettings||"confirmed",this.wallets=e.wallets}construct(e){super.construct(e);let t=_n.getActiveCaipNetworkId(),r=(e.networks?.find(o=>o.caipNetworkId===t)||e.networks?.[0])?.rpcUrls.default.http[0];r&&at.setConnection(new st(r,this.connectionSettings))}setAuthProvider(e){this.addConnector(new hr({w3mFrameProvider:e,getActiveChain:()=>Ve.getCaipNetworkByNamespace(this.namespace),chains:this.getCaipNetworks()}))}syncConnectors(e,t){e.projectId||no.open(oo.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,"error");let n=()=>t.getCaipNetwork(this.namespace);eo.isClient()&&"coinbaseSolana"in window&&this.addConnector(new pr({provider:window.coinbaseSolana,chains:this.getCaipNetworks(),getActiveChain:n})),Gi(this.getCaipNetworks(),n,this.addConnector.bind(this))}async writeContract(){return Promise.resolve({hash:""})}async getCapabilities(){return Promise.resolve({})}async grantPermissions(){return Promise.resolve({})}async revokePermissions(){return Promise.resolve("0x")}async walletGetAssets(e){return Promise.resolve({})}async getAccounts(e){let t=this.connectors.find(n=>n.id===e.id);return t?{accounts:await t.getAccounts()}:{accounts:[]}}async signMessage(e){let t=e.provider;if(!t)throw new Error("connectionControllerClient:signMessage - provider is undefined");let n=await t.signMessage(new TextEncoder().encode(e.message));return{signature:ce.encode(n)}}async estimateGas(e){let t=at.state.connection;if(!t||!e.provider)throw new Error("Connection is not set");let r=await(await bs({provider:e.provider,connection:t,to:"11111111111111111111111111111111",value:1})).getEstimatedFee(t);return{gas:BigInt(r||0)}}async sendTransaction(e){let t=at.state.connection;if(!t||!e.provider)throw new Error("Connection is not set");let n=e.provider,r=await bs({provider:n,connection:t,to:e.to,value:Number.isNaN(Number(e.value))?0:Number(e.value)}),o=await n.sendTransaction(r,t);return await new Promise(i=>{let a=setInterval(async()=>{(await t.getSignatureStatus(o))?.value&&(clearInterval(a),i())},1e3)}),{hash:o}}parseUnits(){return 0n}formatUnits(){return""}async connect(e){let t=this.connectors.find(o=>o.id===e.id);if(!t)throw new Error("Provider not found");let n=e.rpcUrl||this.getCaipNetworks()?.find(o=>o.id===e.chainId)?.rpcUrls.default.http[0];if(!n)throw new Error(`RPC URL not found for chainId: ${e.chainId}`);let r=await t.connect({chainId:e.chainId,socialUri:e.socialUri});return this.listenProviderEvents(t),at.setConnection(new st(n,this.connectionSettings)),this.emit("accountChanged",{address:r,chainId:e.chainId}),{id:t.id,address:r,chainId:e.chainId,provider:t,type:t.type}}async getBalance(e){let t=e.address,n=this.getCaipNetworks()?.find(c=>c.id===e.chainId);if(!t)return Promise.resolve({balance:"0.00",symbol:"SOL"});let r=new st(n?.rpcUrls?.default?.http?.[0],this.connectionSettings),o=`${n?.caipNetworkId}:${e.address}`,i=this.balancePromises[o];if(i)return i;let a=_n.getNativeBalanceCacheForCaipAddress(o);return a?{balance:a.balance,symbol:a.symbol}:(this.balancePromises[o]=new Promise(async c=>{try{let d=(await r.getBalance(new N(t))/Se.LAMPORTS_PER_SOL).toString();if(_n.updateNativeBalanceCache({caipAddress:o,balance:d,symbol:e.caipNetwork?.nativeCurrency.symbol||"SOL",timestamp:Date.now()}),!e.caipNetwork)throw new Error("caipNetwork is required");c({balance:d,symbol:e.caipNetwork?.nativeCurrency.symbol})}catch{c({balance:"0.00",symbol:"SOL"})}}).finally(()=>{delete this.balancePromises[o]}),this.balancePromises[o]||{balance:"0.00",symbol:"SOL"})}async switchNetwork(e){await super.switchNetwork(e);let{caipNetwork:t}=e;t?.rpcUrls?.default?.http?.[0]&&at.setConnection(new st(t.rpcUrls.default.http[0],this.connectionSettings))}listenProviderEvents(e){let t=()=>{this.removeProviderListeners(e),this.emit("disconnect")},n=r=>{let o=r.toBase58();o&&this.emit("accountChanged",{address:o})};e.on("disconnect",t),e.on("accountsChanged",n),e.on("connect",n),e.on("pendingTransaction",()=>{this.emit("pendingTransactions")}),this.providerHandlers={disconnect:t,accountsChanged:n}}removeProviderListeners(e){this.providerHandlers&&(e.removeListener("disconnect",this.providerHandlers.disconnect),e.removeListener("accountsChanged",this.providerHandlers.accountsChanged),e.removeListener("connect",this.providerHandlers.accountsChanged),this.providerHandlers=null)}setUniversalProvider(e){this.addConnector(new an({provider:e,chains:this.getCaipNetworks(),getActiveChain:()=>Ve.getCaipNetworkByNamespace(this.namespace)}))}async connectWalletConnect(e){let t=await super.connectWalletConnect(e),n=this.getCaipNetworks()?.find(o=>o.id===e)?.rpcUrls.default.http[0],r=new st(n,this.connectionSettings);return at.setConnection(r),t}async disconnect(e){if(!e.provider||!e.providerType)throw new Error("Provider or providerType not provided");await e.provider.disconnect()}async syncConnection(e){return this.connect({...e,type:""})}getWalletConnectProvider(e){return new an({provider:e.provider,chains:e.caipNetworks,getActiveChain:()=>Ve.getCaipNetworkByNamespace(this.namespace)})}};var mr=Ue(vs(),1);var Zh=new Gs,Qh=new dn,ep="939345e3a30974b284f27b6a7918736f",tp={name:"Intear Wallet",description:"Intear Wallet",url:"https://wallet.intear.tech",icons:["/favicon.svg"]};qs({adapters:[Qh],networks:[Vs],projectId:ep,metadata:tp,features:{analytics:!1,socials:!1,onramp:!1,swaps:!1,receive:!1,send:!1,email:!1},themeMode:"dark"});function np({children:s}){return Pe.default.createElement(js,{client:Zh},s)}function rp({messageToSign:s,onSignature:e}){let t=Cr({namespace:"solana"}),{open:n,close:r}=Tr(),{walletProvider:o}=Hs("solana"),[i,a]=(0,Pe.useState)(!1);return(0,mr.useEffect)(()=>{let c=async()=>{if(t.isConnected&&s&&o)try{let f=new TextEncoder().encode(s),d=await o.signMessage(f);e(d,s,t.address||null),o.disconnect(),r(),a(!1)}catch(f){console.error("Signing error:",f),e(null,s,null),o.disconnect(),r(),a(!1)}};if(t.isConnected&&s&&!i&&(a(!0),c()),!t.isConnected&&s){n({view:"Connect"});let f=!1,d=setInterval(()=>{let m=document.getElementsByTagName("w3m-modal")[0];m&&m.className==="open"?f=!0:f&&(clearInterval(d),e(null,s,null),o.disconnect(),r())},50);return()=>clearInterval(d)}},[t.isConnected,s,o,e,n,i]),Pe.default.createElement(Pe.default.Fragment,null)}function sp({onConnection:s}){let e=Cr({namespace:"solana"}),{open:t,close:n}=Tr();return(0,mr.useEffect)(()=>{if(e.isConnected&&e.address){let r=e.address;s(r),n()}},[e.isConnected,e.address,s,n]),(0,mr.useEffect)(()=>{if(!e.isConnected){t({view:"Connect"});let r=!1,o=setInterval(()=>{let i=document.getElementsByTagName("w3m-modal")[0];i&&i.className==="open"?r=!0:r&&(clearInterval(o),s(null))},50);return()=>clearInterval(o)}},[e.isConnected,s,t]),Pe.default.createElement(Pe.default.Fragment,null)}function op({messageToSign:s,onSignature:e,needsSignIn:t,onConnection:n}){return Pe.default.createElement(np,null,s&&Pe.default.createElement(rp,{messageToSign:s,onSignature:e}),t&&Pe.default.createElement(sp,{onConnection:n}))}export{op as default};
/*! Bundled license information:

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
