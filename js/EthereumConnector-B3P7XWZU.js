import{a as ae,b as ce,c as de,e as ue,f as Te,g as pe,i as me,j as Pe,k as He,l as Ge,m as z}from"./chunk-MAV5EFVZ.js";import{a as ke,b as Oe,c as le,d as V,e as Re,f as fe,g as Se,h as E,i as We,j as ge,k as Qe,l as $,m as he,n as Ce,o as Ue,p as _e,q as Me,r as Ke,s as Fe,t as Le,u as De,w as qe,x as Be}from"./chunk-BJGTEFIT.js";import"./chunk-HG3QHOOL.js";import"./chunk-3LXE7Q4X.js";import"./chunk-7O2PPVEZ.js";import"./chunk-6N5K4EEA.js";import"./chunk-6YRCTRZB.js";import"./chunk-GYTDKIFP.js";import"./chunk-237QXMMD.js";import{b as F,d as T,f as L}from"./chunk-FS4YWWYV.js";import{G as P,I as se,b as v,c as M,k as Q,l as oe,m as Ne,p as k}from"./chunk-UDTBWQKV.js";import{d as Ie,h as Ee}from"./chunk-ETAVA44A.js";import"./chunk-KIG3ADHQ.js";import"./chunk-JK5MJGFP.js";import{F as be}from"./chunk-COAJKL54.js";import"./chunk-65GJ65H6.js";import{a as W}from"./chunk-E3J3KTZS.js";import"./chunk-H6T4G3YK.js";import"./chunk-JBYAY2RL.js";import"./chunk-PIVQIF3J.js";import"./chunk-FILZKAK2.js";import{C as G,Q as Ae,qa as j,s as ie,va as K}from"./chunk-OZZRRPYE.js";import"./chunk-FXML5DPA.js";import"./chunk-6OI5GZ4U.js";import"./chunk-YRGGSJIG.js";import"./chunk-5RP2GFJC.js";import{f as S,h as a,j as c,n as d}from"./chunk-KGCAX4NX.js";a();d();c();var b=S(W(),1);a();d();c();a();d();c();var D=S(W(),1);a();d();c();var J=S(W(),1);function je(s){let{children:e,config:n,initialState:t,reconnectOnMount:r=!0}=s,{onMount:o}=Be(n,{initialState:t,reconnectOnMount:r});n._internal.ssr||o();let m=(0,J.useRef)(!0);return(0,J.useEffect)(()=>{if(m.current&&n._internal.ssr)return o(),()=>{m.current=!1}},[]),e}var q=(0,D.createContext)(void 0);function Y(s){let{children:e,config:n}=s,t={value:n};return(0,D.createElement)(je,s,(0,D.createElement)(q.Provider,t,e))}a();d();c();a();d();c();a();d();c();var Ve="2.15.4";var $e=()=>`wagmi@${Ve}`;var X=class extends ke{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/react"}get version(){return $e()}};a();d();c();var Z=class extends X{constructor(){super("`useConfig` must be used within `WagmiProvider`.",{docsPath:"/api/WagmiProvider"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiProviderNotFoundError"})}};a();d();c();var ze=S(W(),1);function U(s={}){let e=s.config??(0,ze.useContext)(q);if(!e)throw new Z;return e}a();d();c();a();d();c();function we(s){return{mutationFn(e){return V(s,e)},mutationKey:["disconnect"]}}a();d();c();function ye(s){return{mutationFn(e){return $(s,e)},mutationKey:["signMessage"]}}a();d();c();var Je=S(W(),1);function Ye(s={}){let e=U(s);return(0,Je.useSyncExternalStore)(n=>_e(e,{onChange:n}),()=>E(e),()=>E(e))}a();d();c();function ee(s={}){let{mutation:e}=s,n=U(s),t=we(n),{mutate:r,mutateAsync:o,...m}=z({...e,...t});return{...m,connectors:Ye({config:n}).map(l=>l.connector),disconnect:r,disconnectAsync:o}}a();d();c();function xe(s={}){let{mutation:e}=s,n=U(s),t=ye(n),{mutate:r,mutateAsync:o,...m}=z({...e,...t});return{...m,signMessage:r,signMessageAsync:o}}a();d();c();a();d();c();a();d();c();a();d();c();a();d();c();a();d();c();a();d();c();a();d();c();a();d();c();a();d();c();function Xe(s){let e=[],n,t;function r(l){return M.parseEvmChainId(l)||1}function o(){return n||(n=ce.getInstance({projectId:s.options.projectId,chainId:P.getActiveCaipNetwork()?.caipNetworkId,enableLogger:s.options.enableAuthLogger,onTimeout:l=>{l==="iframe_load_failed"?k.open(T.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):l==="iframe_request_timeout"?k.open(T.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):l==="unverified_domain"&&k.open(T.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")},abortController:T.EmbeddedWalletAbortController})),n}async function m(l={}){let i=o(),f=l.chainId;if(l.isReconnecting){let I=M.parseEvmChainId(i.getLastUsedChainId()||""),N=s.chains?.[0].id;if(f=I||N,!f)throw new Error("ChainId not found in provider")}let x=se.state.preferredAccountTypes?.eip155,{address:u,chainId:p,accounts:g}=await i.connect({chainId:f,preferredAccountType:x,socialUri:l.socialUri});e=g?.map(I=>I.address)||[u];let h=r(p);return{accounts:e,account:u,chainId:h,chain:{id:h,unsuported:!1}}}return l=>({id:v.CONNECTOR_ID.AUTH,name:v.CONNECTOR_NAMES.AUTH,type:"AUTH",chain:v.CHAIN.EVM,async connect(i={}){if(t)return t;t||(t=new Promise(x=>{x(m(i))}));let f=await t;return t=void 0,f},async disconnect(){await(await this.getProvider()).disconnect()},getAccounts(){return e?.length?(l.emitter.emit("change",{accounts:e}),Promise.resolve(e)):Promise.resolve([])},async getProvider(){return this.provider||(this.provider=ce.getInstance({projectId:s.options.projectId,chainId:P.getActiveCaipNetwork()?.caipNetworkId,enableLogger:s.options.enableAuthLogger,abortController:T.EmbeddedWalletAbortController,onTimeout:i=>{i==="iframe_load_failed"?k.open(T.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):i==="iframe_request_timeout"?k.open(T.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):i==="unverified_domain"&&k.open(T.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")}})),Promise.resolve(this.provider)},async getChainId(){let i=await this.getProvider(),{chainId:f}=await i.getChainId();return r(f)},async isAuthorized(){let i=await this.getProvider();return Promise.resolve(i.getLoginEmailUsed())},async switchChain({chainId:i}){try{let f=l.chains.find(g=>g.id===i);if(!f)throw new K(new Error("chain not found on connector."));let x=await this.getProvider(),u=se.state.preferredAccountTypes?.eip155,p=await x.connect({chainId:i,preferredAccountType:u});return e=p?.accounts?.map(g=>g.address)||[p.address],l.emitter.emit("change",{chainId:Number(i),accounts:e}),f}catch(f){throw f instanceof Error?new K(f):f}},onAccountsChanged(i){i.length===0?this.onDisconnect():l.emitter.emit("change",{accounts:i.map(G)})},onChainChanged(i){let f=Number(i);l.emitter.emit("change",{chainId:f})},async onDisconnect(i){await(await this.getProvider()).disconnect()}})}a();d();c();te.type="walletConnect";function te(s,e){let n=s.isNewChainsStale??!0,t,r,o,m,l,i,f;return x=>({id:"walletConnect",name:"WalletConnect",type:te.type,async setup(){let u=await this.getProvider().catch(()=>null);u&&(m||(m=this.onConnect.bind(this),u.on("connect",m)),i||(i=this.onSessionDelete.bind(this),u.on("session_delete",i)))},async connect({...u}={}){try{let p=P.getCaipNetworks(),g=await this.getProvider();if(!g)throw new he;l||(l=this.onDisplayUri,g.on("display_uri",l));let h=await this.isChainsStale();g.session&&h&&await g.disconnect();let I=Ne.state.universalProviderConfigOverride;if(!g.session||h){let re=ue.createNamespaces(p,I);await g.connect({optionalNamespaces:re,..."pairingTopic"in u?{pairingTopic:u.pairingTopic}:{}}),this.setRequestedChainsIds(p.map(rt=>Number(rt.id)))}let N=await this.getAccounts(),A=await this.getChainId(),_=g.session?.namespaces?.eip155?.chains,ne=_?.some(re=>Number(re.split(":")[1])===A),R=1;ne?R=A:_?.[0]&&(R=Number(_[0].split(":")[1])),l&&(g.removeListener("display_uri",l),l=void 0),m&&(g.removeListener("connect",m),m=void 0),r||(r=this.onAccountsChanged.bind(this),g.on("accountsChanged",r)),o||(o=this.onChainChanged.bind(this),g.on("chainChanged",o)),f||(f=this.onDisconnect.bind(this),g.on("disconnect",f)),i||(i=this.onSessionDelete.bind(this),g.on("session_delete",i));let nt=I?.defaultChain;return g.setDefaultChain(nt??`eip155:${R}`),{accounts:N,chainId:R}}catch(p){throw/(user rejected|connection request reset)/i.test(p?.message)?new j(p):p}},async disconnect(){let u=await this.getProvider();try{await u?.disconnect()}catch(p){if(!/No matching key/i.test(p.message))throw p}finally{o&&(u?.removeListener("chainChanged",o),o=void 0),f&&(u?.removeListener("disconnect",f),f=void 0),m||(m=this.onConnect.bind(this),u?.on("connect",m)),r&&(u?.removeListener("accountsChanged",r),r=void 0),i&&(u?.removeListener("session_delete",i),i=void 0),this.setRequestedChainsIds([])}},async getAccounts(){let u=await this.getProvider();return u?.session?.namespaces?u?.session?.namespaces[v.CHAIN.EVM]?.accounts?.map(h=>h.split(":")[2])??[]:[]},async getProvider({chainId:u}={}){t||(t=await e.getUniversalProvider(),t?.events.setMaxListeners(Number.POSITIVE_INFINITY));let p=Q.getActiveNamespace(),g=e.getCaipNetwork()?.id;if(u&&g!==u&&p){let h=Q.getStoredActiveCaipNetworkId(),N=e.getCaipNetworks(p)?.find(A=>A.id===h);N&&N.chainNamespace===v.CHAIN.EVM&&await this.switchChain?.({chainId:Number(N.id)})}return t},async getChainId(){let u=e.getCaipNetwork(v.CHAIN.EVM)?.id;if(u)return u;let g=(await this.getProvider()).session?.namespaces[v.CHAIN.EVM]?.chains?.[0];return P.getCaipNetworks().find(I=>I.id===g)?.id},async isAuthorized(){try{let[u,p]=await Promise.all([this.getAccounts(),this.getProvider()]);return u.length?await this.isChainsStale()&&p.session?(await p.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:u,chainId:p}){let g=await this.getProvider();if(!g)throw new he;let h=P.getCaipNetworks().find(I=>I.id===p);if(!h)throw new K(new Oe);try{await g.request({method:"wallet_switchEthereumChain",params:[{chainId:ie(p)}]}),h?.caipNetworkId&&g.setDefaultChain(h?.caipNetworkId),x.emitter.emit("change",{chainId:Number(p)});let I=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...I,p]),{...h,id:h.id}}catch(I){let N=I;if(/(?:user rejected)/iu.test(N.message))throw new j(N);try{let A;u?.blockExplorerUrls?A=u.blockExplorerUrls:A=h.blockExplorers?.default.url?[h.blockExplorers?.default.url]:[];let _=h.rpcUrls?.chainDefault?.http||[],ne={blockExplorerUrls:A,chainId:ie(p),chainName:h.name,iconUrls:u?.iconUrls,nativeCurrency:h.nativeCurrency,rpcUrls:_};await g.request({method:"wallet_addEthereumChain",params:[ne]});let R=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...R,p]),{...h,id:h.id}}catch(A){throw new j(A)}}},onAccountsChanged(u){u.length===0?this.onDisconnect():x.emitter.emit("change",{accounts:u.map(p=>G(p))})},onChainChanged(u){let p=Number(u);x.emitter.emit("change",{chainId:p})},onConnect(u){this.setRequestedChainsIds(P.getCaipNetworks().map(p=>Number(p.id)))},async onDisconnect(u){this.setRequestedChainsIds([]),x.emitter.emit("disconnect");let p=await this.getProvider();r&&(p.removeListener("accountsChanged",r),r=void 0),o&&(p.removeListener("chainChanged",o),o=void 0),f&&(p.removeListener("disconnect",f),f=void 0),i&&(p.removeListener("session_delete",i),i=void 0),m||(m=this.onConnect.bind(this),p.on("connect",m))},onDisplayUri(u){x.emitter.emit("message",{type:"display_uri",data:u})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){return t?.session?.namespaces?t?.session?.namespaces[v.CHAIN.EVM]?.accounts?.map(g=>Number.parseInt(g.split(":")[1]??""))??[]:[]},async getRequestedChainsIds(){let u=await x.storage?.getItem(this.requestedChainsStorageKey)??[];return[...new Set(u)]},async isChainsStale(){if(!n)return!1;let u=x.chains.map(h=>h.id),p=this.getNamespaceChainsIds();if(p.length&&!p.some(h=>u.includes(h)))return!1;let g=await this.getRequestedChainsIds();return!u.every(h=>g.includes(Number(h)))},async setRequestedChainsIds(u){await x.storage?.setItem(this.requestedChainsStorageKey,u)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}a();d();c();var B=Ie({pendingTransactions:0}),ve={state:B,subscribeKey(s,e){return Ee(B,s,e)},increase(s){B[s]+=1},decrease(s){B[s]-=1},reset(s){B[s]=0}};a();d();c();function Ze(s){try{return JSON.parse(s)}catch{throw new Error("Error parsing wallet capabilities")}}var ot={enable:!1,pollingInterval:3e4},H=class extends pe{constructor(e){let n=L.extendCaipNetworks(e.networks,{projectId:e.projectId,customNetworkImageUrls:{},customRpcUrls:e.customRpcUrls});super(),this.balancePromises={},this.namespace=v.CHAIN.EVM,this.adapterType=v.ADAPTER_TYPES.WAGMI,this.projectId=e.projectId,this.pendingTransactionsFilter={...ot,...e.pendingTransactionsFilter??{}},this.createConfig({...e,networks:n})}construct(e){this.setupWatchers()}async getAccounts(e){let n=this.getWagmiConnector(e.id);if(!n)return{accounts:[]};if(n.id===v.CONNECTOR_ID.AUTH){let o=await n.getProvider();if(!o?.user)return{accounts:[]};let{address:m,accounts:l}=o.user;return Promise.resolve({accounts:(l||[{address:m,type:"eoa"}]).map(i=>oe.createAccount("eip155",i.address,i.type))})}let{addresses:t,address:r}=fe(this.wagmiConfig);return Promise.resolve({accounts:[...new Set(t||[r])].map(o=>oe.createAccount("eip155",o||"","eoa"))})}getWagmiConnector(e){return this.wagmiConfig.connectors.find(n=>n.id===e)}createConfig(e){this.wagmiChains=e.networks.filter(r=>r.chainNamespace===v.CHAIN.EVM);let n={},t=[...e.connectors??[]];this.wagmiChains.forEach(r=>{let o=e.transports?.[r.id],m=L.getCaipNetworkId(r);o?n[r.id]=L.extendWagmiTransports(r,e.projectId,o):n[r.id]=L.getViemTransport(r,e.projectId,e.customRpcUrls?.[m])}),this.wagmiConfig=qe({...e,chains:this.wagmiChains,connectors:t,transports:n})}setupWatchPendingTransactions(){if(!this.pendingTransactionsFilter.enable||this.unwatchPendingTransactions)return;this.unwatchPendingTransactions=Ke(this.wagmiConfig,{pollingInterval:this.pendingTransactionsFilter.pollingInterval,onError:()=>{},onTransactions:()=>{this.emit("pendingTransactions"),ve.increase("pendingTransactions")}});let e=ve.subscribeKey("pendingTransactions",n=>{n>=v.LIMITS.PENDING_TRANSACTIONS&&(this.unwatchPendingTransactions?.(),e())})}setupWatchers(){Ue(this.wagmiConfig,{onChange:(e,n)=>{e.status==="disconnected"&&n.address&&this.emit("disconnect"),e.status==="connected"&&((e.address!==n?.address||n.status!=="connected")&&(this.setupWatchPendingTransactions(),this.emit("accountChanged",{address:e.address,chainId:e.chainId})),e.chainId!==n?.chainId&&this.emit("switchNetwork",{address:e.address,chainId:e.chainId}))}})}async addThirdPartyConnectors(e){let n=[];if(e.enableCoinbase!==!1)try{let{coinbaseWallet:t}=await import("./exports-KUKUBWSB.js");t&&n.push(t({version:"4",appName:e.metadata?.name??"Unknown",appLogoUrl:e.metadata?.icons[0]??"Unknown",preference:e.coinbasePreference??"all"}))}catch(t){console.error("Failed to import Coinbase Wallet SDK:",t)}n.forEach(t=>{let r=this.wagmiConfig._internal.connectors.setup(t);this.wagmiConfig._internal.connectors.setState(o=>[...o,r])})}addWagmiConnectors(e,n){let t=[];e.enableWalletConnect!==!1&&t.push(te(e,n)),e.enableInjected!==!1&&t.push(De({shimDisconnect:!0}));let r=n?.remoteFeatures?.email??!0,o=Array.isArray(n?.remoteFeatures?.socials)&&n?.remoteFeatures?.socials?.length>0;(r||o)&&t.push(Xe({chains:this.wagmiChains,options:{projectId:e.projectId,enableAuthLogger:e.enableAuthLogger}})),t.forEach(m=>{let l=this.wagmiConfig._internal.connectors.setup(m);this.wagmiConfig._internal.connectors.setState(i=>[...i,l])})}async signMessage(e){try{return{signature:await $(this.wagmiConfig,{message:e.message,account:e.address})}}catch{throw new Error("WagmiAdapter:signMessage - Sign message failed")}}async sendTransaction(e){let{chainId:n,address:t}=fe(this.wagmiConfig),r={account:t,to:e.to,value:Number.isNaN(Number(e.value))?BigInt(0):BigInt(e.value),gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,data:e.data,chainId:n,type:"legacy",parameters:["nonce"]};await We(this.wagmiConfig,r);let o=await Qe(this.wagmiConfig,r);return await Fe(this.wagmiConfig,{hash:o,timeout:25e3}),{hash:o}}async writeContract(e){let{caipNetwork:n,...t}=e,r=Number(M.caipNetworkIdToNumber(n.caipNetworkId));return{hash:await Le(this.wagmiConfig,{chain:this.wagmiChains?.[r],chainId:r,address:t.tokenAddress,account:t.fromAddress,abi:t.abi,functionName:t.method,args:t.args,__mode:"prepared"})}}async estimateGas(e){try{return{gas:await Re(this.wagmiConfig,{account:e.address,to:e.to,data:e.data,type:"legacy"})}}catch{throw new Error("WagmiAdapter:estimateGas - error estimating gas")}}parseUnits(e){return be(e.value,e.decimals)}formatUnits(e){return Ae(e.value,e.decimals)}async addWagmiConnector(e,n){if(e.id===v.CONNECTOR_ID.AUTH||e.id===v.CONNECTOR_ID.WALLET_CONNECT)return;let t=await e.getProvider().catch(()=>{});this.addConnector({id:e.id,explorerId:F.ConnectorExplorerIds[e.id],imageUrl:n?.connectorImages?.[e.id]??e.icon,name:F.ConnectorNamesMap[e.id]??e.name,imageId:F.ConnectorImageIds[e.id],type:F.ConnectorTypesMap[e.type]??"EXTERNAL",info:e.id===v.CONNECTOR_ID.INJECTED?void 0:{rdns:e.id},provider:t,chain:this.namespace,chains:[]})}async syncConnectors(e,n){Me(this.wagmiConfig,{onChange:t=>{t.forEach(r=>this.addWagmiConnector(r,e))}}),await Promise.all(this.wagmiConfig.connectors.map(t=>this.addWagmiConnector(t,e))),this.addWagmiConnectors(e,n),await this.addThirdPartyConnectors(e)}async syncConnection(e){let{id:n}=e,r=E(this.wagmiConfig).find(l=>l.connector.id===n),m=await this.getWagmiConnector(n)?.getProvider();return{chainId:Number(r?.chainId),address:r?.accounts[0],provider:m,type:r?.connector.type?.toUpperCase(),id:r?.connector.id}}async connectWalletConnect(e){let n=this.getWalletConnectConnector();await n.authenticate();let t=this.getWagmiConnector("walletConnect");if(!t)throw new Error("UniversalAdapter:connectWalletConnect - connector not found");let r=await le(this.wagmiConfig,{connector:t,chainId:e?Number(e):void 0});return r.chainId!==Number(e)&&await Ce(this.wagmiConfig,{chainId:r.chainId}),{clientId:await n.provider.client.core.crypto.getClientId()}}async connect(e){let{id:n,provider:t,type:r,info:o,chainId:m,socialUri:l}=e,i=this.getWagmiConnector(n);if(!i)throw new Error("connectionControllerClient:connectExternal - connector is undefined");if(t&&o&&i.id===v.CONNECTOR_ID.EIP6963&&i.setEip6963Wallet?.({provider:t,info:o}),i.uid===this.wagmiConfig?.state?.current){let x=this.wagmiConfig.state?.connections?.get(i.uid);if(x)return{address:x?.accounts[0],chainId:x?.chainId,provider:t,type:r,id:n}}let f=await le(this.wagmiConfig,{connector:i,chainId:m?Number(m):void 0,socialUri:l});return{address:f.accounts[0],chainId:f.chainId,provider:t,type:r,id:n}}async reconnect(e){let{id:n}=e,t=this.getWagmiConnector(n);if(!t)throw new Error("connectionControllerClient:connectExternal - connector is undefined");await ge(this.wagmiConfig,{connectors:[t]})}async getBalance(e){let n=e.address,t=this.getCaipNetworks().find(r=>r.id===e.chainId);if(!n)return Promise.resolve({balance:"0.00",symbol:"ETH"});if(t&&this.wagmiConfig){let r=`${t.caipNetworkId}:${e.address}`,o=this.balancePromises[r];if(o)return o;let m=Q.getNativeBalanceCacheForCaipAddress(r);return m?{balance:m.balance,symbol:m.symbol}:(this.balancePromises[r]=new Promise(async l=>{try{let i=Number(e.chainId),f=await Se(this.wagmiConfig,{address:e.address,chainId:i,token:e.tokens?.[t.caipNetworkId]?.address});Q.updateNativeBalanceCache({caipAddress:r,balance:f.formatted,symbol:f.symbol,timestamp:Date.now()}),l({balance:f.formatted,symbol:f.symbol})}catch(i){console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance",i),l({balance:"0.00",symbol:"ETH"})}}).finally(()=>{delete this.balancePromises[r]}),this.balancePromises[r]||{balance:"0.00",symbol:"ETH"})}return{balance:"",symbol:""}}getWalletConnectProvider(){return this.getWagmiConnector("walletConnect")?.provider}async disconnect(){let e=E(this.wagmiConfig);await Promise.allSettled(e.map(async n=>{let t=this.getWagmiConnector(n.connector.id);t&&await V(this.wagmiConfig,{connector:t})})),this.wagmiConfig.state.connections.clear()}async switchNetwork(e){await Ce(this.wagmiConfig,{chainId:e.caipNetwork.id}),await super.switchNetwork(e)}async getCapabilities(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");let t=E(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:getCapabilities - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:getCapabilities - provider is undefined");let m=o.session?.sessionProperties?.capabilities;if(m){let i=Ze(m)[e];if(i)return i}return await o.request({method:"wallet_getCapabilities",params:[e]})}async grantPermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");let t=E(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:grantPermissions - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:grantPermissions - provider is undefined");return o.request({method:"wallet_grantPermissions",params:e})}async revokePermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");let t=E(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:revokePermissions - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:revokePermissions - provider is undefined");return o.request({method:"wallet_revokePermissions",params:e})}async walletGetAssets(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");let t=E(this.wagmiConfig)[0],r=t?this.getWagmiConnector(t.connector.id):null;if(!r)throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");let o=await r.getProvider();if(!o)throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");return o.request({method:"wallet_getAssets",params:[e]})}setUniversalProvider(e){e.on("connect",()=>{let n=E(this.wagmiConfig),t=this.getWagmiConnector("walletConnect");t&&!n.find(r=>r.connector.id===t.id)&&ge(this.wagmiConfig,{connectors:[t]})}),this.addConnector(new Te({provider:e,caipNetworks:this.getCaipNetworks(),namespace:"eip155"}))}};var O=S(W(),1);var it=new He,et="939345e3a30974b284f27b6a7918736f",st={name:"Intear Wallet",description:"Intear Wallet",url:"https://wallet.intear.tech",icons:["/favicon.svg"]},tt=new H({networks:[de],projectId:et,ssr:!1});Pe({adapters:[tt],networks:[de],projectId:et,metadata:st,features:{analytics:!1,socials:!1,onramp:!1,swaps:!1,receive:!1,send:!1,email:!1},themeMode:"dark"});function at({children:s}){return b.default.createElement(Y,{config:tt.wagmiConfig},b.default.createElement(Ge,{client:it},s))}function ct({messageToSign:s,onSignature:e}){let n=ae({namespace:"eip155"}),{open:t,close:r}=me(),{disconnect:o}=ee(),{signMessage:m,data:l,error:i}=xe();return(0,O.useEffect)(()=>{l&&(e(l,s),o(),r())},[l,e]),(0,O.useEffect)(()=>{i&&(console.error("Signing error:",i),e(null,s),o(),r())},[i,e,o]),(0,O.useEffect)(()=>{if(n.isConnected&&s&&m({message:s}),!n.isConnected&&s){t({view:"Connect",namespace:"eip155"});let f=!1,x=setInterval(()=>{let u=document.getElementsByTagName("w3m-modal")[0];u&&u.className==="open"?f=!0:f&&(clearInterval(x),e(null,s),o(),r())},50);return()=>clearInterval(x)}},[n.isConnected,s]),b.default.createElement(b.default.Fragment,null)}function dt({onConnection:s}){let e=ae({namespace:"eip155"}),{open:n,close:t}=me(),{disconnect:r}=ee();return(0,O.useEffect)(()=>{r()},[]),(0,O.useEffect)(()=>{if(e.isConnected&&e.address){let o=e.address;s(o),t()}},[e.isConnected,e.address,s]),(0,O.useEffect)(()=>{if(!e.isConnected){n({view:"Connect",namespace:"eip155"});let o=!1,m=setInterval(()=>{let l=document.getElementsByTagName("w3m-modal")[0];l&&l.className==="open"?o=!0:o&&(clearInterval(m),s(null))},50);return()=>clearInterval(m)}},[e.isConnected,s]),b.default.createElement(b.default.Fragment,null)}function ut({messageToSign:s,onSignature:e,needsSignIn:n,onConnection:t}){return b.default.createElement(at,null,s&&b.default.createElement(ct,{messageToSign:s,onSignature:e}),n&&b.default.createElement(dt,{onConnection:t}))}export{ut as default};
