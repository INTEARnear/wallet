import{b as Se,c as Ne,d as Te,e as nt,f as ot,g as rt,h as se}from"./chunk-MHA2O77V.js";import{a as st,b as ie,c as Re,d as it,e as at,f as ae,g as k,h as ct,i as ce,j as ut,k as dt,l as ke,m as _e,n as lt,o as ft,p as pt,q as mt,r as ht,s as gt,t as Ct,v as wt}from"./chunk-TAP62CKP.js";import"./chunk-XVL5DJMZ.js";import"./chunk-JCWDJGXT.js";import{n as Oe}from"./chunk-6HHQFJDN.js";import"./chunk-NBB6K44E.js";import"./chunk-P6OKGMWB.js";import"./chunk-XVJ4QQYG.js";import"./chunk-MWGMXHZG.js";import"./chunk-QLVJW567.js";import"./chunk-7DJCKE43.js";import"./chunk-SA5NWCU7.js";import"./chunk-EDAA45PX.js";import"./chunk-S3KPEUSS.js";import"./chunk-V74C2HKT.js";import"./chunk-PPLSOLUM.js";import"./chunk-MKQASGGU.js";import"./chunk-DLVLGZ7R.js";import"./chunk-YCKXBVJA.js";import"./chunk-ZE7767IA.js";import"./chunk-ASCK67KS.js";import"./chunk-ZYZOIEZB.js";import{b as J,c as R,f as X}from"./chunk-6T7Q26JY.js";import"./chunk-3C4CKHE3.js";import"./chunk-K5RILM6W.js";import"./chunk-27YRW757.js";import"./chunk-SEJLZ3OT.js";import"./chunk-TI7CUUHJ.js";import"./chunk-NHUA5J6J.js";import"./chunk-4QOCBQPC.js";import"./chunk-PTZTZUDB.js";import"./chunk-RBOFKV5S.js";import"./chunk-Z6LVO3CP.js";import"./chunk-RL7GPJDA.js";import"./chunk-BDSQF46L.js";import"./chunk-N3PRX6SH.js";import"./chunk-MNAGPPOX.js";import"./chunk-EJ5H5H5L.js";import"./chunk-IPTO6NMX.js";import"./chunk-BI3DTO7P.js";import"./chunk-EEYGRRF2.js";import"./chunk-GLIZJUBT.js";import"./chunk-RLPEU2I3.js";import"./chunk-B2LU4KHT.js";import{d as Pe,e as Ze,f as et,g as tt,h as U}from"./chunk-RZQOM5QR.js";import"./chunk-HQPTEMSB.js";import"./chunk-IDZGCU4F.js";import"./chunk-ZS2R6O6N.js";import"./chunk-SQN7L5MN.js";import"./chunk-7GZ7JYLK.js";import"./chunk-6HADIPAO.js";import"./chunk-2T4BE52W.js";import{a as F}from"./chunk-3RVNKTWB.js";import"./chunk-XQOHLC2A.js";import{A as _,B as L,H as M,M as Je,U as Xe,X as be,Y,ga as S,j as x,k as V,p as N,r as Ie,s as $}from"./chunk-OXOEMY67.js";import"./chunk-HXA2I3EV.js";import"./chunk-JKAT2LPR.js";import"./chunk-WVZCG2XE.js";import{Rb as ze,Vb as Ye,X as Ve,zb as $e}from"./chunk-SH2H32CZ.js";import"./chunk-BDUWLAUS.js";import"./chunk-OBMTZ2R2.js";import"./chunk-6ZQQ3XQO.js";import{Aa as qe,Ba as B,Pa as je,Tb as W,Yb as z,db as Ge,na as Ae}from"./chunk-J26BEOSD.js";import"./chunk-MQMLE4BX.js";import"./chunk-UHIHVU5C.js";import"./chunk-EDRI7XUL.js";import{g as K,i as d,k as l,o as f}from"./chunk-JY5TIRRF.js";d();f();l();var O=K(F(),1);d();f();l();d();f();l();var Z=K(F(),1);d();f();l();d();f();l();d();f();l();function yt(n,e,t){let o=n[e.name];if(typeof o=="function")return o;let r=n[t];return typeof r=="function"?r:s=>e(n,s)}d();f();l();d();f();l();d();f();l();d();f();l();var vt="2.22.1";var xt=()=>`@wagmi/core@${vt}`;var Et=function(n,e,t,o){if(t==="a"&&!o)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?n!==e||!o:!e.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?o:t==="a"?o.call(n):o?o.value:e.get(n)},ue,It,T=class n extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return xt()}constructor(e,t={}){super(),ue.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});let o=t.cause instanceof n?t.cause.details:t.cause?.message?t.cause.message:t.details,r=t.cause instanceof n&&t.cause.docsPath||t.docsPath;this.message=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...r?[`Docs: ${this.docsBaseUrl}${r}.html${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...o?[`Details: ${o}`]:[],`Version: ${this.version}`].join(`
`),t.cause&&(this.cause=t.cause),this.details=o,this.docsPath=r,this.metaMessages=t.metaMessages,this.shortMessage=e}walk(e){return Et(this,ue,"m",It).call(this,this,e)}};ue=new WeakSet,It=function n(e,t){return t?.(e)?e:e.cause?Et(this,ue,"m",n).call(this,e.cause,t):e};var de=class extends T{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}};var le=class extends T{constructor({address:e,connector:t}){super(`Account "${e}" not found for connector "${t.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}},fe=class extends T{constructor({connectionChainId:e,connectorChainId:t}){super(`The current chain of the connector (id: ${t}) does not match the connection's chain (id: ${e}).`,{metaMessages:[`Current Chain ID:  ${t}`,`Expected Chain ID: ${e}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}},pe=class extends T{constructor({connector:e}){super(`Connector "${e.name}" unavailable while reconnecting.`,{details:["During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.","All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.","This error commonly occurs for connectors that asynchronously inject after reconnection has already started."].join(" ")}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}};d();f();l();async function At(n,e={}){let{assertChainId:t=!0}=e,o;if(e.connector){let{connector:i}=e;if(n.state.status==="reconnecting"&&!i.getAccounts&&!i.getChainId)throw new pe({connector:i});let[m,h]=await Promise.all([i.getAccounts().catch(g=>{if(e.account===null)return[];throw g}),i.getChainId()]);o={accounts:m,chainId:h,connector:i}}else o=n.state.connections.get(n.state.current);if(!o)throw new de;let r=e.chainId??o.chainId,s=await o.connector.getChainId();if(t&&s!==r)throw new fe({connectionChainId:r,connectorChainId:s});let p=o.connector;if(p.getClient)return p.getClient({chainId:r});let u=je(e.account??o.accounts[0]);if(u&&(u.address=B(u.address)),e.account&&!o.accounts.some(i=>i.toLowerCase()===u.address.toLowerCase()))throw new le({address:u.address,connector:p});let c=n.chains.find(i=>i.id===r),a=await o.connector.getProvider({chainId:r});return Ve({account:u,chain:c,name:"Connector Client",transport:i=>Ye(a)({...i,retryCount:0})})}d();f();l();async function bt(n,e={}){let t;if(e.connector)t=e.connector;else{let{connections:r,current:s}=n.state;t=r.get(s)?.connector}let o=n.state.connections;t&&(await t.disconnect(),t.emitter.off("change",n._internal.events.change),t.emitter.off("disconnect",n._internal.events.disconnect),t.emitter.on("connect",n._internal.events.connect),o.delete(t.uid)),n.setState(r=>{if(o.size===0)return{...r,connections:new Map,current:null,status:"disconnected"};let s=o.values().next().value;return{...r,connections:new Map(o),current:s.connector.uid}});{let r=n.state.current;if(!r)return;let s=n.state.connections.get(r)?.connector;if(!s)return;await n.storage?.setItem("recentConnectorId",s.id)}}d();f();l();function H(n,e){if(n===e)return!0;if(n&&e&&typeof n=="object"&&typeof e=="object"){if(n.constructor!==e.constructor)return!1;let t,o;if(Array.isArray(n)&&Array.isArray(e)){if(t=n.length,t!==e.length)return!1;for(o=t;o--!==0;)if(!H(n[o],e[o]))return!1;return!0}if(typeof n.valueOf=="function"&&n.valueOf!==Object.prototype.valueOf)return n.valueOf()===e.valueOf();if(typeof n.toString=="function"&&n.toString!==Object.prototype.toString)return n.toString()===e.toString();let r=Object.keys(n);if(t=r.length,t!==Object.keys(e).length)return!1;for(o=t;o--!==0;)if(!Object.hasOwn(e,r[o]))return!1;for(o=t;o--!==0;){let s=r[o];if(s&&!H(n[s],e[s]))return!1}return!0}return n!==n&&e!==e}d();f();l();var me=[];function q(n){let e=[...n.state.connections.values()];return n.state.status==="reconnecting"||H(me,e)?me:(me=e,e)}d();f();l();var Me=!1;async function Pt(n,e={}){if(Me)return[];Me=!0,n.setState(a=>({...a,status:a.current?"reconnecting":"connecting"}));let t=[];if(e.connectors?.length)for(let a of e.connectors){let i;typeof a=="function"?i=n._internal.connectors.setup(a):i=a,t.push(i)}else t.push(...n.connectors);let o;try{o=await n.storage?.getItem("recentConnectorId")}catch{}let r={};for(let[,a]of n.state.connections)r[a.connector.id]=1;o&&(r[o]=0);let s=Object.keys(r).length>0?[...t].sort((a,i)=>(r[a.id]??10)-(r[i.id]??10)):t,p=!1,u=[],c=[];for(let a of s){let i=await a.getProvider().catch(()=>{});if(!i||c.some(g=>g===i)||!await a.isAuthorized())continue;let h=await a.connect({isReconnecting:!0}).catch(()=>null);h&&(a.emitter.off("connect",n._internal.events.connect),a.emitter.on("change",n._internal.events.change),a.emitter.on("disconnect",n._internal.events.disconnect),n.setState(g=>{let E=new Map(p?g.connections:new Map).set(a.uid,{accounts:h.accounts,chainId:h.chainId,connector:a});return{...g,current:p?g.current:a.uid,connections:E}}),u.push({accounts:h.accounts,chainId:h.chainId,connector:a}),c.push(i),p=!0)}return(n.state.status==="reconnecting"||n.state.status==="connecting")&&(p?n.setState(a=>({...a,status:"connected"})):n.setState(a=>({...a,connections:new Map,current:null,status:"disconnected"}))),Me=!1,u}d();f();l();async function St(n,e){let{account:t,connector:o,...r}=e,s;return typeof t=="object"&&t.type==="local"?s=n.getClient():s=await At(n,{account:t,connector:o}),yt(s,ze,"signMessage")({...r,...t?{account:t}:{}})}d();f();l();function We(n,e){let{onChange:t}=e;return n.subscribe(()=>q(n),t,{equalityFn:H})}d();f();l();function Ue(n,e){let{initialState:t,reconnectOnMount:o}=e;return t&&!n._internal.store.persist.hasHydrated()&&n.setState({...t,chainId:n.chains.some(r=>r.id===t.chainId)?t.chainId:n.chains[0].id,connections:o?t.connections:new Map,status:o?"reconnecting":"disconnected"}),{async onMount(){n._internal.ssr&&(await n._internal.store.persist.rehydrate(),n._internal.mipd&&n._internal.connectors.setState(r=>{let s=new Set;for(let c of r??[])if(c.rdns){let a=Array.isArray(c.rdns)?c.rdns:[c.rdns];for(let i of a)s.add(i)}let p=[],u=n._internal.mipd?.getProviders()??[];for(let c of u){if(s.has(c.info.rdns))continue;let a=n._internal.connectors.providerDetailToConnector(c),i=n._internal.connectors.setup(a);p.push(i)}return[...r,...p]})),o?Pt(n):n.storage&&n.setState(r=>({...r,connections:new Map}))}}}var he=K(F(),1);function Nt(n){let{children:e,config:t,initialState:o,reconnectOnMount:r=!0}=n,{onMount:s}=Ue(t,{initialState:o,reconnectOnMount:r});t._internal.ssr||s();let p=(0,he.useRef)(!0);return(0,he.useEffect)(()=>{if(p.current&&t._internal.ssr)return s(),()=>{p.current=!1}},[]),e}var ee=(0,Z.createContext)(void 0);function ge(n){let{children:e,config:t}=n,o={value:t};return(0,Z.createElement)(Nt,n,(0,Z.createElement)(ee.Provider,o,e))}d();f();l();d();f();l();d();f();l();var Tt="2.19.5";var Ot=()=>`wagmi@${Tt}`;var Ce=class extends T{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiError"})}get docsBaseUrl(){return"https://wagmi.sh/react"}get version(){return Ot()}};d();f();l();var we=class extends Ce{constructor(){super("`useConfig` must be used within `WagmiProvider`.",{docsPath:"/api/WagmiProvider"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiProviderNotFoundError"})}};d();f();l();var Rt=K(F(),1);function j(n={}){let e=n.config??(0,Rt.useContext)(ee);if(!e)throw new we;return e}d();f();l();d();f();l();function De(n){return{mutationFn(e){return bt(n,e)},mutationKey:["disconnect"]}}d();f();l();function Qe(n){return{mutationFn(e){return St(n,e)},mutationKey:["signMessage"]}}d();f();l();var kt=K(F(),1);function _t(n={}){let e=j(n);return(0,kt.useSyncExternalStore)(t=>We(e,{onChange:t}),()=>q(e),()=>q(e))}d();f();l();function ye(n={}){let{mutation:e}=n,t=j(n),o=De(t),{mutate:r,mutateAsync:s,...p}=se({...e,...o});return{...p,connectors:_t({config:t}).map(u=>u.connector),disconnect:r,disconnectAsync:s}}d();f();l();function Ke(n={}){let{mutation:e}=n,t=j(n),o=Qe(t),{mutate:r,mutateAsync:s,...p}=se({...e,...o});return{...p,signMessage:r,signMessageAsync:s}}d();f();l();d();f();l();d();f();l();d();f();l();d();f();l();function Mt(n){let e=[],t,o;function r(u){let c=S.getCaipNetworks(x.CHAIN.EVM),a=Number(V.parseEvmChainId(u));if(!c.some(i=>String(i.id)===String(u))){let i=S.getActiveCaipNetwork(x.CHAIN.EVM)?.id||c[0]?.id;i&&Number.isInteger(Number(i))&&(a=Number(i))}if(!a)throw new Error("ChainId not found in networks");return a}function s(){return t||(t=Ne.getInstance({projectId:n.options.projectId,chainId:Y()?.caipNetworkId,enableLogger:n.options.enableAuthLogger,onTimeout:u=>{u==="iframe_load_failed"?U.open(R.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):u==="iframe_request_timeout"?U.open(R.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):u==="unverified_domain"&&U.open(R.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")},abortController:R.EmbeddedWalletAbortController,getActiveCaipNetwork:u=>Y(u),getCaipNetworks:u=>S.getCaipNetworks(u)})),t}async function p(u={}){let c=s(),a=u.chainId;if(u.isReconnecting){let b=V.parseEvmChainId(c.getLastUsedChainId()||""),v=n.chains?.[0].id;if(a=b||v,!a)throw new Error("ChainId not found in provider")}let i=be("eip155"),{address:m,chainId:h,accounts:g}=await et.authConnectorAuthenticate({authConnector:c,chainId:a,preferredAccountType:i,socialUri:u.socialUri,chainNamespace:x.CHAIN.EVM});e=g?.map(b=>b.address)||[m];let E=r(h);return{accounts:e,account:m,chainId:E,chain:{id:E,unsupported:!1}}}return u=>({id:x.CONNECTOR_ID.AUTH,name:x.CONNECTOR_NAMES.AUTH,type:"AUTH",chain:x.CHAIN.EVM,async connect(c={}){if(o){let i=await o;return{accounts:c.withCapabilities?i.accounts.map(m=>({address:m,capabilities:{}})):i.accounts,chainId:i.chainId}}o||(o=new Promise(i=>{i(p(c))}));let a=await o;return o=void 0,{accounts:c.withCapabilities?a.accounts.map(i=>({address:i,capabilities:{}})):a.accounts,chainId:a.chainId}},async disconnect(){await(await this.getProvider()).disconnect()},getAccounts(){return e?.length?(u.emitter.emit("change",{accounts:e}),Promise.resolve(e)):Promise.resolve([])},async getProvider(){return this.provider||(this.provider=Ne.getInstance({projectId:n.options.projectId,chainId:Y()?.caipNetworkId,enableLogger:n.options.enableAuthLogger,abortController:R.EmbeddedWalletAbortController,onTimeout:c=>{c==="iframe_load_failed"?U.open(R.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):c==="iframe_request_timeout"?U.open(R.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):c==="unverified_domain"&&U.open(R.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")},getActiveCaipNetwork:c=>Y(c),getCaipNetworks:c=>S.getCaipNetworks(c)})),Promise.resolve(this.provider)},async getChainId(){let c=await this.getProvider(),{chainId:a}=await c.getChainId();return r(a)},async isAuthorized(){let a=S.state.activeChain===x.CHAIN.EVM;if(x.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(h=>Xe.getConnectorId(h)===x.CONNECTOR_ID.AUTH)&&!a)return!1;let m=await this.getProvider();return Promise.resolve(m.getLoginEmailUsed())},async switchChain({chainId:c}){try{let a=u.chains.find(g=>g.id===c);if(!a)throw new z(new Error("chain not found on connector."));let i=await this.getProvider(),m=be("eip155"),h=await i.connect({chainId:c,preferredAccountType:m});return e=h?.accounts?.map(g=>g.address)||[h.address],u.emitter.emit("change",{chainId:Number(c),accounts:e}),a}catch(a){throw a instanceof Error?new z(a):a}},onAccountsChanged(c){c.length===0?this.onDisconnect():u.emitter.emit("change",{accounts:c.map(B)})},onChainChanged(c){let a=Number(c);u.emitter.emit("change",{chainId:a})},async onDisconnect(c){await(await this.getProvider()).disconnect()}})}d();f();l();ve.type="walletConnect";function ve(n){let e=n.isNewChainsStale??!0,t,o,r,s,p,u,c;return a=>({id:"walletConnect",name:"WalletConnect",type:ve.type,provider:n.universalProvider,async setup(){let i=await this.getProvider().catch(()=>null);i&&(s||(s=this.onConnect.bind(this),i.on("connect",s)),u||(u=this.onSessionDelete.bind(this),i.on("session_delete",u)))},async connect({...i}={}){try{let m=S.getCaipNetworks(),h=await this.getProvider();if(!h)throw new ke;p||(p=this.onDisplayUri,h.on("display_uri",p));let g=await this.isChainsStale();h.session&&g&&await h.disconnect();let E=M.state.universalProviderConfigOverride;if(!h.session||g){let G=Pe.createNamespaces(m,E);await h.connect({optionalNamespaces:G,..."pairingTopic"in i?{pairingTopic:i.pairingTopic}:{}}),this.setRequestedChainsIds(m.map(jt=>Number(jt.id)))}let b=await this.getAccounts(),v=await this.getChainId(),A=h.session?.namespaces?.eip155?.chains,I=A?.some(G=>Number(G.split(":")[1])===v),P=1;I?P=v:A?.[0]&&(P=Number(A[0].split(":")[1])),p&&(h.removeListener("display_uri",p),p=void 0),s&&(h.removeListener("connect",s),s=void 0),o||(o=this.onAccountsChanged.bind(this),h.on("accountsChanged",o)),r||(r=this.onChainChanged.bind(this),h.on("chainChanged",r)),c||(c=this.onDisconnect.bind(this),h.on("disconnect",c)),u||(u=this.onSessionDelete.bind(this),h.on("session_delete",u));let Q=E?.defaultChain;return h.setDefaultChain(Q??`eip155:${P}`),{accounts:b,chainId:P}}catch(m){throw/(user rejected|connection request reset)/i.test(m?.message)?new W(m):m}},async disconnect(){let i=await this.getProvider();try{await i?.disconnect()}catch(m){if(!/No matching key/i.test(m.message))throw m}finally{r&&(i?.removeListener("chainChanged",r),r=void 0),c&&(i?.removeListener("disconnect",c),c=void 0),s||(s=this.onConnect.bind(this),i?.on("connect",s)),o&&(i?.removeListener("accountsChanged",o),o=void 0),u&&(i?.removeListener("session_delete",u),u=void 0),this.setRequestedChainsIds([])}},async getAccounts(){let i=await this.getProvider();if(!i?.session?.namespaces)return[];let h=i?.session?.namespaces[x.CHAIN.EVM]?.accounts?.map(b=>b.split(":")[2])??[],g=new Set;return h.filter(b=>{let v=b?.toLowerCase();return g.has(v)?!1:(g.add(v),!0)})},async getProvider({chainId:i}={}){t||(t=n.universalProvider,t?.events.setMaxListeners(Number.POSITIVE_INFINITY));let m=_.getActiveNamespace(),h=S.getActiveCaipNetwork()?.id;if(i&&h!==i&&m){let g=_.getStoredActiveCaipNetworkId(),b=(m?S.getCaipNetworks(m):[])?.find(v=>v.id===g);b&&b.chainNamespace===x.CHAIN.EVM&&await this.switchChain?.({chainId:Number(b.id)})}return t},async getChainId(){let i=S.getActiveCaipNetwork(x.CHAIN.EVM)?.id;if(i)return i;let h=(await this.getProvider()).session?.namespaces[x.CHAIN.EVM]?.chains?.[0];return S.getCaipNetworks().find(E=>E.id===h)?.id},async isAuthorized(){try{let[i,m]=await Promise.all([this.getAccounts(),this.getProvider()]);return i.length?await this.isChainsStale()&&m.session?(await m.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:i,chainId:m}){let h=await this.getProvider();if(!h)throw new ke;let g=S.getCaipNetworks().find(E=>E.id===m);if(!g)throw new z(new st);try{await h.request({method:"wallet_switchEthereumChain",params:[{chainId:Ae(m)}]}),g?.caipNetworkId&&h.setDefaultChain(g?.caipNetworkId),a.emitter.emit("change",{chainId:Number(m)});let E=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...E,m]),{...g,id:g.id}}catch(E){let b=E;if(/(?:user rejected)/iu.test(b.message))throw new W(b);try{let v;i?.blockExplorerUrls?v=i.blockExplorerUrls:v=g.blockExplorers?.default.url?[g.blockExplorers?.default.url]:[];let A=g.rpcUrls?.chainDefault?.http||[],I={blockExplorerUrls:v,chainId:Ae(m),chainName:g.name,iconUrls:i?.iconUrls,nativeCurrency:g.nativeCurrency,rpcUrls:A};await h.request({method:"wallet_addEthereumChain",params:[I]});let P=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...P,m]),{...g,id:g.id}}catch(v){throw new W(v)}}},onAccountsChanged(i){i.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:i.map(m=>B(m))})},onChainChanged(i){let m=Number(i);a.emitter.emit("change",{chainId:m})},onConnect(i){this.setRequestedChainsIds(S.getCaipNetworks().map(m=>Number(m.id)))},async onDisconnect(i){this.setRequestedChainsIds([]),a.emitter.emit("disconnect");let m=await this.getProvider();o&&(m.removeListener("accountsChanged",o),o=void 0),r&&(m.removeListener("chainChanged",r),r=void 0),c&&(m.removeListener("disconnect",c),c=void 0),u&&(m.removeListener("session_delete",u),u=void 0),s||(s=this.onConnect.bind(this),m.on("connect",s))},onDisplayUri(i){a.emitter.emit("message",{type:"display_uri",data:i})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){return t?.session?.namespaces?t?.session?.namespaces[x.CHAIN.EVM]?.accounts?.map(h=>Number.parseInt(h.split(":")[1]??""))??[]:[]},async getRequestedChainsIds(){let i=await a.storage?.getItem(this.requestedChainsStorageKey)??[];return[...new Set(i)]},async isChainsStale(){if(!e)return!1;let i=a.chains.map(g=>g.id),m=this.getNamespaceChainsIds();if(m.length&&!m.some(g=>i.includes(g)))return!1;let h=await this.getRequestedChainsIds();return!i.every(g=>h.includes(Number(g)))},async setRequestedChainsIds(i){await a.storage?.setItem(this.requestedChainsStorageKey,i)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}})}d();f();l();d();f();l();d();f();l();var Rs=Symbol(),Gt=Symbol();var Wt=Object.getPrototypeOf,Ut=new WeakMap,Vt=n=>n&&(Ut.has(n)?Ut.get(n):Wt(n)===Object.prototype||Wt(n)===Array.prototype);var Dt=n=>Vt(n)&&n[Gt]||null;var Fe=n=>typeof n=="object"&&n!==null,$t=n=>Fe(n)&&!Le.has(n)&&(Array.isArray(n)||!(Symbol.iterator in n))&&!(n instanceof WeakMap)&&!(n instanceof WeakSet)&&!(n instanceof Error)&&!(n instanceof Number)&&!(n instanceof Date)&&!(n instanceof String)&&!(n instanceof RegExp)&&!(n instanceof ArrayBuffer)&&!(n instanceof Promise);var zt=(n,e,t,o)=>({deleteProperty(r,s){let p=Reflect.get(r,s);t(s);let u=Reflect.deleteProperty(r,s);return u&&o(["delete",[s],p]),u},set(r,s,p,u){let c=!n()&&Reflect.has(r,s),a=Reflect.get(r,s,u);if(c&&(Qt(a,p)||ne.has(p)&&Qt(a,ne.get(p))))return!0;t(s),Fe(p)&&(p=Dt(p)||p);let i=!te.has(p)&&Xt(p)?Ee(p):p;return e(s,i),Reflect.set(r,s,i,u),o(["set",[s],p,a]),!0}}),te=new WeakMap,Le=new WeakSet,Yt=new WeakMap,xe=[1],ne=new WeakMap,Qt=Object.is,Jt=(n,e)=>new Proxy(n,e),Xt=$t;var Zt=zt;function Ee(n={}){if(!Fe(n))throw new Error("object required");let e=ne.get(n);if(e)return e;let t=xe[0],o=new Set,r=(v,A=++xe[0])=>{t!==A&&(s=t=A,o.forEach(I=>I(v,A)))},s=t,p=(v=xe[0])=>(s!==v&&(s=v,c.forEach(([A])=>{let I=A[1](v);I>t&&(t=I)})),t),u=v=>(A,I)=>{let P=[...A];P[1]=[v,...P[1]],r(P,I)},c=new Map,a=(v,A)=>{let I=!Le.has(A)&&te.get(A);if(I){if((import.meta.env?import.meta.env.MODE:void 0)!=="production"&&c.has(v))throw new Error("prop listener already exists");if(o.size){let P=I[2](u(v));c.set(v,[I,P])}else c.set(v,[I])}},i=v=>{var A;let I=c.get(v);I&&(c.delete(v),(A=I[1])==null||A.call(I))},m=v=>(o.add(v),o.size===1&&c.forEach(([I,P],Q)=>{if((import.meta.env?import.meta.env.MODE:void 0)!=="production"&&P)throw new Error("remove already exists");let G=I[2](u(Q));c.set(Q,[I,G])}),()=>{o.delete(v),o.size===0&&c.forEach(([I,P],Q)=>{P&&(P(),c.set(Q,[I]))})}),h=!0,g=Zt(()=>h,a,i,r),E=Jt(n,g);ne.set(n,E);let b=[n,p,m];return te.set(E,b),Reflect.ownKeys(n).forEach(v=>{let A=Object.getOwnPropertyDescriptor(n,v);"value"in A&&A.writable&&(E[v]=n[v])}),h=!1,E}function Kt(n,e,t){let o=te.get(n);(import.meta.env?import.meta.env.MODE:void 0)!=="production"&&!o&&console.warn("Please use proxy object");let r,s=[],p=o[2],u=!1,a=p(i=>{if(s.push(i),t){e(s.splice(0));return}r||(r=Promise.resolve().then(()=>{r=void 0,u&&e(s.splice(0))}))});return u=!0,()=>{u=!1,a()}}function Be(){return{proxyStateMap:te,refSet:Le,snapCache:Yt,versionHolder:xe,proxyCache:ne}}d();f();l();function Ft(n,e,t,o){let r=n[e];return Kt(n,()=>{let s=n[e];Object.is(r,s)||t(r=s)},o)}var qs=Symbol();var{proxyStateMap:js,snapCache:Gs}=Be();var{proxyStateMap:Vs,snapCache:$s}=Be();var oe=Ee({pendingTransactions:0}),He={state:oe,subscribeKey(n,e){return Ft(oe,n,e)},increase(n){oe[n]+=1},decrease(n){oe[n]-=1},reset(n){oe[n]=0}};d();f();l();async function Lt(n){if(L.isSafeApp()){let{safe:e}=await import("./exports-GG6RJPW5.js");if(e&&!n.some(t=>t.type==="safe"))return e()}return null}async function Bt(n){try{let{baseAccount:e}=await import("./exports-GG6RJPW5.js");if(e&&!n.some(t=>t.id==="baseAccount"))return e()}catch(e){console.error("Failed to import Coinbase Wallet SDK:",e)}return null}var en={enable:!1,pollingInterval:3e4},re=class extends Ze{constructor(e){let t=X.extendCaipNetworks(e.networks,{projectId:e.projectId,customNetworkImageUrls:{},customRpcUrls:e.customRpcUrls});super(),this.balancePromises={},this.namespace=x.CHAIN.EVM,this.adapterType=x.ADAPTER_TYPES.WAGMI,this.projectId=e.projectId,this.pendingTransactionsFilter={...en,...e.pendingTransactionsFilter??{}},this.createConfig({...e,networks:t}),this.checkChainId()}construct(e){this.checkChainId(),this.setupWatchers()}async getAccounts(e){let t=this.getWagmiConnector(e.id);if(!t)return{accounts:[]};if(t.id===x.CONNECTOR_ID.AUTH){let s=await t.getProvider();if(!s?.user)return{accounts:[]};let{address:p,accounts:u}=s.user;return Promise.resolve({accounts:(u||[{address:p,type:"eoa"}]).map(c=>L.createAccount("eip155",c.address,c.type))})}let{addresses:o,address:r}=ae(this.wagmiConfig);return Promise.resolve({accounts:[...new Set(o||[r])].map(s=>L.createAccount("eip155",s||"","eoa"))})}checkChainId(){let{chainId:e}=ae(this.wagmiConfig);e&&this.emit("switchNetwork",{chainId:e})}getWagmiConnector(e){return this.wagmiConfig.connectors.find(t=>t.id===e)}createConfig(e){this.wagmiChains=e.networks.filter(r=>r.chainNamespace===x.CHAIN.EVM);let t={},o=[...e.connectors??[]];this.wagmiChains.forEach(r=>{let s=e.transports?.[r.id],p=X.getCaipNetworkId(r);s?t[r.id]=X.extendWagmiTransports(r,e.projectId,s):t[r.id]=X.getViemTransport(r,e.projectId,e.customRpcUrls?.[p])}),this.wagmiConfig=wt({...e,chains:this.wagmiChains,connectors:o,transports:t})}setupWatchPendingTransactions(){if(!this.pendingTransactionsFilter.enable||this.unwatchPendingTransactions)return;this.unwatchPendingTransactions=ht(this.wagmiConfig,{pollingInterval:this.pendingTransactionsFilter.pollingInterval,onError:()=>{},onTransactions:()=>{this.emit("pendingTransactions"),He.increase("pendingTransactions")}});let e=He.subscribeKey("pendingTransactions",t=>{t>=x.LIMITS.PENDING_TRANSACTIONS&&(this.unwatchPendingTransactions?.(),e())})}setupWatchers(){pt(this.wagmiConfig,{onChange:e=>{this.clearConnections(),this.addConnection(...e.map(t=>{let o=this.getCaipNetworks().find(s=>s.id===t.chainId),r=t.connector.id===x.CONNECTOR_ID.AUTH;return{accounts:t.accounts.map(s=>({address:this.toChecksummedAddress(s)})),caipNetwork:o,connectorId:t.connector.id,auth:r?{name:_.getConnectedSocialProvider(),username:_.getConnectedSocialUsername()}:void 0}}))}}),ft(this.wagmiConfig,{onChange:(e,t)=>{if(e.status==="disconnected"&&t.address&&this.emit("disconnect"),e?.chainId&&e?.chainId!==t?.chainId&&this.emit("switchNetwork",{chainId:e.chainId}),e.status==="connected"){let o=e.address!==t?.address,r=e.connector.id!==t.connector?.id,s=t.status!=="connected";(o||r||s)&&(this.setupWatchPendingTransactions(),this.handleAccountChanged({address:e.address,chainId:e.chainId,connector:e.connector}))}}})}async addThirdPartyConnectors(){let e=[],{enableCoinbase:t}=M.state||{};if(t!==!1){let r=await Bt(this.wagmiConfig.connectors);r&&e.push(r)}let o=await Lt(this.wagmiConfig.connectors);o&&e.push(o),await Promise.all(e.map(r=>{let s=this.configureInternalConnector(r);return this.addWagmiConnector(s)}))}addWagmiConnectors(){let e=[];M.state.enableInjected!==!1&&e.push(Ct({shimDisconnect:!0}));let{features:t,remoteFeatures:o,projectId:r,enableAuthLogger:s}=M.state,p=o?.email??t?.email??!0,u=o?.socials??t?.socials,c=Array.isArray(u)&&u?.length>0;(p||c)&&e.push(Mt({chains:this.wagmiChains,options:{projectId:r,enableAuthLogger:s}})),e.forEach(a=>{this.configureInternalConnector(a)})}configureInternalConnector(e){let t=this.wagmiConfig._internal.connectors.setup(e);return this.wagmiConfig._internal.connectors.setState(o=>[...o,t]),t}async handleAccountChanged({address:e,chainId:t,connector:o}){if(!this.namespace)throw new Error("WagmiAdapter:handleAccountChanged - namespace is required");let r=await o.getProvider().catch(()=>{});this.emit("accountChanged",{address:this.toChecksummedAddress(e),chainId:t,connector:{id:o.id,name:N.ConnectorNamesMap[o.id]??o.name,imageId:N.ConnectorImageIds[o.id],type:N.ConnectorTypesMap[o.type]??"EXTERNAL",info:o.id===x.CONNECTOR_ID.INJECTED?void 0:{rdns:o.id},provider:r,chain:this.namespace,chains:[]}})}async writeSolanaTransaction(){return Promise.resolve({hash:""})}async signMessage(e){try{return{signature:await dt(this.wagmiConfig,{message:e.message,account:e.address})}}catch{throw new Error("WagmiAdapter:signMessage - Sign message failed")}}async sendTransaction(e){let{chainId:t,address:o}=ae(this.wagmiConfig),r=this.wagmiChains?.find(u=>u.id===t),s={account:o,to:e.to,value:Number.isNaN(Number(e.value))?BigInt(0):BigInt(e.value),gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,data:e.data,chain:r,type:"legacy",parameters:["nonce"]};await ct(this.wagmiConfig,s);let p=await ut(this.wagmiConfig,s);return await lt(this.wagmiConfig,{hash:p,timeout:25e3}),{hash:p}}async writeContract(e){let{caipNetwork:t,...o}=e,r=Number(V.caipNetworkIdToNumber(t.caipNetworkId)),s=this.wagmiChains?.find(u=>u.id===r);return{hash:await gt(this.wagmiConfig,{chain:s,address:o.tokenAddress,account:o.fromAddress,abi:o.abi,functionName:o.method,args:o.args,__mode:"prepared"})}}async estimateGas(e){try{return{gas:await it(this.wagmiConfig,{account:e.address,to:e.to,data:e.data,type:"legacy"})}}catch{throw new Error("WagmiAdapter:estimateGas - error estimating gas")}}parseUnits(e){return $e(e.value,e.decimals)}formatUnits(e){return Ge(e.value,e.decimals)}async addWagmiConnector(e){if(!this.namespace)throw new Error("WagmiAdapter:addWagmiConnector - namespace is required");let{enableEIP6963:t}=M.state||{};if(e.type===x.CONNECTOR_ID.INJECTED&&t===!1||e.id===x.CONNECTOR_ID.AUTH||e.id===x.CONNECTOR_ID.WALLET_CONNECT)return;let o;e.id!==x.CONNECTOR_ID.BASE_ACCOUNT&&(o=await e.getProvider().catch(()=>{}));let r=Je.state.connectorImages;this.addConnector({id:e.id,explorerId:N.ConnectorExplorerIds[e.id]??N.ConnectorExplorerIds[e.name],imageUrl:r?.[e.id]??e.icon,name:N.ConnectorNamesMap[e.id]??e.name,imageId:N.ConnectorImageIds[e.id],type:N.ConnectorTypesMap[e.type]??"EXTERNAL",info:e.id===x.CONNECTOR_ID.INJECTED?void 0:{rdns:e.id},provider:o,chain:this.namespace,chains:[]})}async syncConnectors(){mt(this.wagmiConfig,{onChange:e=>{e.forEach(t=>this.addWagmiConnector(t))}}),this.addWagmiConnectors(),await Promise.all(this.wagmiConfig.connectors.map(e=>this.addWagmiConnector(e))),await this.addThirdPartyConnectors()}async syncConnections(){let e=this.connectors.filter(t=>{let{hasDisconnected:o,hasConnected:r}=J.getConnectorStorageInfo(t.id,this.namespace);return!o&&r}).map(t=>this.getWagmiConnector(t.id)).filter(Boolean);await ce(this.wagmiConfig,{connectors:e})}async syncConnection(e){let{id:t,chainId:o}=e,s=k(this.wagmiConfig).find(a=>a.connector.id===t),u=await this.getWagmiConnector(t)?.getProvider();if(L.isSafeApp()&&t===x.CONNECTOR_ID.SAFE&&!s?.accounts.length){let a=this.getWagmiConnector("safe");if(a){let i=await ie(this.wagmiConfig,{connector:a,chainId:Number(o)}),m=await a.getProvider();return{chainId:Number(o),address:this.toChecksummedAddress(i.accounts[0]),provider:m,type:s?.connector.type?.toUpperCase(),id:s?.connector.id}}}return{chainId:Number(s?.chainId),address:this.toChecksummedAddress(s?.accounts[0]),provider:u,type:s?.connector.type?.toUpperCase(),id:s?.connector.id}}async connectWalletConnect(e){try{let t=this.getWalletConnectConnector();await t.authenticate();let o=this.getWagmiConnector("walletConnect");if(!o)throw new Error("UniversalAdapter:connectWalletConnect - connector not found");let r=await ie(this.wagmiConfig,{connector:o,chainId:e?Number(e):void 0});return r.chainId!==Number(e)&&await _e(this.wagmiConfig,{chainId:r.chainId}),{clientId:await t.provider.client.core.crypto.getClientId()}}catch(t){throw t instanceof W?new $(t):Ie.isUserRejectedRequestError(t)?new $(t):t}}async connect(e){try{let{id:t,address:o,provider:r,type:s,info:p,chainId:u,socialUri:c}=e,a=this.getWagmiConnector(t);if(!a)throw new Error("connectionControllerClient:connectExternal - connector is undefined");r&&p&&a.id===x.CONNECTOR_ID.EIP6963&&a.setEip6963Wallet?.({provider:r,info:p});let i=this.wagmiConfig.state?.connections?.get(a.uid);if(i){await this.wagmiConfig.storage?.setItem("recentConnectorId",a.id);let g=[...i.accounts].sort((E,b)=>J.isLowerCaseMatch(E,o)?-1:J.isLowerCaseMatch(b,o)?1:0);return this.wagmiConfig?.setState(E=>({...E,connections:new Map(E.connections).set(a.uid,{accounts:g,chainId:i.chainId,connector:i.connector}),current:a.uid,status:"connected"})),{address:this.toChecksummedAddress(g[0]),chainId:i.chainId,provider:r,type:s,id:t}}let m=await ie(this.wagmiConfig,{connector:a,chainId:u?Number(u):void 0,socialUri:c}),h=r??await a.getProvider();return{address:this.toChecksummedAddress(m.accounts[0]),chainId:m.chainId,provider:h,type:s,id:t}}catch(t){throw t instanceof W?new $(t):Ie.isUserRejectedRequestError(t)?new $(t):t}}get connections(){return Array.from(this.wagmiConfig.state.connections.values()).map(e=>({accounts:e.accounts.map(t=>({address:this.toChecksummedAddress(t)})),connectorId:e.connector.id}))}async reconnect(e){let{id:t}=e,o=this.getWagmiConnector(t);if(!o)throw new Error("connectionControllerClient:connectExternal - connector is undefined");await ce(this.wagmiConfig,{connectors:[o]})}async getBalance(e){let t=e.address,o=this.getCaipNetworks().find(r=>r.id===e.chainId);if(!t)return Promise.resolve({balance:"0.00",symbol:"ETH"});if(o&&this.wagmiConfig){let r=`${o.caipNetworkId}:${e.address}`,s=this.balancePromises[r];if(s)return s;let p=_.getNativeBalanceCacheForCaipAddress(r);return p?{balance:p.balance,symbol:p.symbol}:(this.balancePromises[r]=new Promise(async u=>{try{let c=Number(e.chainId),a=await at(this.wagmiConfig,{address:e.address,chainId:c,token:e.tokens?.[o.caipNetworkId]?.address});_.updateNativeBalanceCache({caipAddress:r,balance:a.formatted,symbol:a.symbol,timestamp:Date.now()}),u({balance:a.formatted,symbol:a.symbol})}catch(c){console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance",c),u({balance:"0.00",symbol:"ETH"})}}).finally(()=>{delete this.balancePromises[r]}),this.balancePromises[r]||{balance:"0.00",symbol:"ETH"})}return{balance:"",symbol:""}}getWalletConnectProvider(){return this.getWagmiConnector("walletConnect")?.provider}async disconnect(e){if(e.id){let t=this.getWagmiConnector(e.id),r=k(this.wagmiConfig).find(s=>J.isLowerCaseMatch(s.connector.id,e.id));return await Re(this.wagmiConfig,{connector:t}),M.state.enableReconnect===!1&&this.deleteConnection(e.id),r?{connections:[{accounts:r.accounts.map(s=>({address:this.toChecksummedAddress(s)})),connectorId:r.connector.id}]}:{connections:[]}}return this.disconnectAll()}async disconnectAll(){let e=k(this.wagmiConfig),t=await Promise.allSettled(e.map(async o=>{let r=this.getWagmiConnector(o.connector.id);return r&&await Re(this.wagmiConfig,{connector:r}),o}));return this.wagmiConfig.state.connections.clear(),{connections:t.filter(o=>o.status==="fulfilled").map(({value:o})=>({accounts:o.accounts.map(r=>({address:this.toChecksummedAddress(r)})),connectorId:o.connector.id}))}}async switchNetwork(e){let{caipNetwork:t}=e,o=this.wagmiConfig.chains.find(g=>g.id.toString()===t.id.toString());if(!o)throw new Error("connectionControllerClient:switchNetwork - wagmiChain is undefined");let{name:r,nativeCurrency:s,rpcUrls:p,blockExplorers:u,id:c}=o,a=t.rpcUrls?.chainDefault?.http?.[0]??p.default.http[0]??"",i=u?.default.url??t.blockExplorers?.default?.url??"",m=s??t.nativeCurrency,h=r??t.name;await _e(this.wagmiConfig,{chainId:c,addEthereumChainParameter:{chainName:h,nativeCurrency:m,rpcUrls:[a],blockExplorerUrls:[i]}}),await super.switchNetwork(e)}async getCapabilities(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");let o=k(this.wagmiConfig)[0],r=o?this.getWagmiConnector(o.connector.id):null;if(!r)throw new Error("connectionControllerClient:getCapabilities - connector is undefined");let s=await r.getProvider();if(!s)throw new Error("connectionControllerClient:getCapabilities - provider is undefined");return await s.request({method:"wallet_getCapabilities",params:[e]})}async grantPermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");let o=k(this.wagmiConfig)[0],r=o?this.getWagmiConnector(o.connector.id):null;if(!r)throw new Error("connectionControllerClient:grantPermissions - connector is undefined");let s=await r.getProvider();if(!s)throw new Error("connectionControllerClient:grantPermissions - provider is undefined");return s.request({method:"wallet_grantPermissions",params:e})}async revokePermissions(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");let o=k(this.wagmiConfig)[0],r=o?this.getWagmiConnector(o.connector.id):null;if(!r)throw new Error("connectionControllerClient:revokePermissions - connector is undefined");let s=await r.getProvider();if(!s)throw new Error("connectionControllerClient:revokePermissions - provider is undefined");return s.request({method:"wallet_revokePermissions",params:e})}async walletGetAssets(e){if(!this.wagmiConfig)throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");let o=k(this.wagmiConfig)[0],r=o?this.getWagmiConnector(o.connector.id):null;if(!r)throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");let s=await r.getProvider();if(!s)throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");return s.request({method:"wallet_getAssets",params:[e]})}setAuthProvider(e){if(!this.namespace)throw new Error("WagmiAdapter:setAuthProvider - namespace is required");this.addConnector({id:x.CONNECTOR_ID.AUTH,type:"AUTH",name:x.CONNECTOR_NAMES.AUTH,provider:e,imageId:N.ConnectorImageIds[x.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}async setUniversalProvider(e){e.on("connect",()=>{let o=k(this.wagmiConfig),r=this.getWagmiConnector("walletConnect");if(r&&!o.find(s=>s.connector.id===r.id)){if(S.state.activeChain==="eip155")return;ce(this.wagmiConfig,{connectors:[r]})}});let t=ve({universalProvider:e});return this.configureInternalConnector(t),this.addConnector(new tt({provider:e,caipNetworks:this.getCaipNetworks(),namespace:"eip155"})),Promise.resolve()}toChecksummedAddress(e){return qe(e.toLowerCase())}};var D=K(F(),1);var tn=new ot,Ht="939345e3a30974b284f27b6a7918736f",nn={name:"Intear Wallet",description:"Intear Wallet",url:"https://wallet.intear.tech",icons:["/favicon.svg"]},qt=new re({networks:[Oe],projectId:Ht,ssr:!1});nt({adapters:[qt],networks:[Oe],projectId:Ht,metadata:nn,features:{analytics:!1,socials:!1,onramp:!1,swaps:!1,receive:!1,send:!1,email:!1},themeMode:"dark"});function on({children:n}){return O.default.createElement(ge,{config:qt.wagmiConfig},O.default.createElement(rt,{client:tn},n))}function rn({messageToSign:n,onSignature:e}){let t=Se({namespace:"eip155"}),{open:o,close:r}=Te(),{disconnect:s}=ye(),{signMessage:p,data:u,error:c}=Ke();return(0,D.useEffect)(()=>{u&&(e(u,n),s(),r())},[u,e]),(0,D.useEffect)(()=>{c&&(console.error("Signing error:",c),e(null,n),s(),r())},[c,e,s]),(0,D.useEffect)(()=>{if(t.isConnected&&n&&p({message:n}),!t.isConnected&&n){o({view:"Connect",namespace:"eip155"});let a=!1,i=setInterval(()=>{let m=document.getElementsByTagName("w3m-modal")[0];m&&m.className==="open"?a=!0:a&&(clearInterval(i),e(null,n),s(),r())},50);return()=>clearInterval(i)}},[t.isConnected,n]),O.default.createElement(O.default.Fragment,null)}function sn({onConnection:n}){let e=Se({namespace:"eip155"}),{open:t,close:o}=Te(),{disconnect:r}=ye();return(0,D.useEffect)(()=>{r()},[]),(0,D.useEffect)(()=>{if(e.isConnected&&e.address){let s=e.address;n(s),o()}},[e.isConnected,e.address,n]),(0,D.useEffect)(()=>{if(!e.isConnected){t({view:"Connect",namespace:"eip155"});let s=!1,p=setInterval(()=>{let u=document.getElementsByTagName("w3m-modal")[0];u&&u.className==="open"?s=!0:s&&(clearInterval(p),n(null))},50);return()=>clearInterval(p)}},[e.isConnected,n]),O.default.createElement(O.default.Fragment,null)}function an({messageToSign:n,onSignature:e,needsSignIn:t,onConnection:o}){return O.default.createElement(on,null,n&&O.default.createElement(rn,{messageToSign:n,onSignature:e}),t&&O.default.createElement(sn,{onConnection:o}))}export{an as default};
